<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://harriswilde.github.io</id>
    <title>TechZone</title>
    <updated>2020-02-29T05:01:54.385Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://harriswilde.github.io"/>
    <link rel="self" href="https://harriswilde.github.io/atom.xml"/>
    <subtitle>HarrisWilde祝诸君元旦快乐🎉</subtitle>
    <logo>https://harriswilde.github.io/images/avatar.png</logo>
    <icon>https://harriswilde.github.io/favicon.ico</icon>
    <rights>All rights reserved 2020, TechZone</rights>
    <entry>
        <title type="html"><![CDATA[C语言之结构体（下）]]></title>
        <id>https://harriswilde.github.io/post/7BMq0j8UT/</id>
        <link href="https://harriswilde.github.io/post/7BMq0j8UT/">
        </link>
        <updated>2020-02-29T04:25:58.000Z</updated>
        <content type="html"><![CDATA[<h1 id="动态申请结构体">动态申请结构体</h1>
<p>结构体也可以在堆里面动态申请：</p>
<pre><code class="language-c">//Example 01
#include &lt;stdio.h&gt;
...
int main(void)
{
    struct Info *i1;
    struct Info *i2;
    
    i1 = (struct Info *)malloc(sizeof(struct Info));
    i2 = (struct Info *)malloc(sizeof(struct Info));
    if (i1 == NULL || i2 == NULL)
    {
        printf(&quot;内存分配失败！\n&quot;);
        exit(1);
    }
    
    printf(&quot;请录入第一个同学的信息...\n&quot;);
    getInput(i1);
    putchar('\n');
    printf(&quot;请录入第二个学生的信息...\n&quot;);
    getInput(i2);

    printf(&quot;\n录入完毕，现在开始打印...\n\n&quot;);
    printf(&quot;打印第一个学生的信息...\n&quot;);
    printInfo(i1);
    putchar('\n');
    printf(&quot;打印第二个学生的信息...\n&quot;);
    printInfo(i2);
    
    free(i1);
    free(i2);
    
    return 0;
}
</code></pre>
<h1 id="实战建立一个图书馆数据库">实战：建立一个图书馆数据库</h1>
<p>实际上，我们建立的数组可以是指向结构体指针的数组。</p>
<p>代码实现如下：</p>
<pre><code class="language-c">//Example 02
#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;

#define MAX_SIZE 100

struct Date
{
    int year;
    int month;
    int day;
};

struct Book
{
    char title[128];
    char author[48];
    float price;
    struct Date date;
    char publisher[48];
};

void getInput(struct Book* book);//录入数据
void printBook(struct Book* book);//打印数据
void initLibrary(struct Book* lib[]);//初始化结构体
void printLibrary(struct Book* lib[]);//打印单本书数据
void releaseLibrary(struct Book* lib[]);//释放内存

void getInput(struct Book* book)
{
    printf(&quot;请输入书名：&quot;);
    scanf(&quot;%s&quot;, book-&gt;title);
    printf(&quot;请输入作者：&quot;);
    scanf(&quot;%s&quot;, book-&gt;author);
    printf(&quot;请输入售价：&quot;);
    scanf(&quot;%f&quot;, &amp;book-&gt;price);
    printf(&quot;请输入出版日期：&quot;);
    scanf(&quot;%d-%d-%d&quot;, &amp;book-&gt;date.year, &amp;book-&gt;date.month, &amp;book-&gt;date.day);
    printf(&quot;请输入出版社：&quot;);
    scanf(&quot;%s&quot;, book-&gt;publisher);
}

void printBook(struct Book* book)
{
    printf(&quot;书名：%s\n&quot;, book-&gt;title);
    printf(&quot;作者：%s\n&quot;, book-&gt;author);
    printf(&quot;售价：%.2f\n&quot;, book-&gt;price);
    printf(&quot;出版日期：%d-%d-%d\n&quot;, book-&gt;date.year, book-&gt;date.month, book-&gt;date.day);
    printf(&quot;出版社：%s\n&quot;, book-&gt;publisher);
}

void initLibrary(struct Book* lib[])
{
    for (int i = 0; i &lt; MAX_SIZE; i++)
    {
        lib[i] = NULL;
    }
}

void printLibrary(struct Book* lib[])
{
    for (int i = 0; i &lt; MAX_SIZE; i++)
    {
        if (lib[i] != NULL)
        {
            printBook(lib[i]);
            putchar('\n');
        }
    }
}

void releaseLibrary(struct Book* lib[])
{
    for (int i = 0; i &lt; MAX_SIZE; i++)
    {
        if (lib[i] != NULL)
        {
            free(lib[i]);
        }
    }
}

int main(void)
{
    struct Book* lib[MAX_SIZE];
    struct Book* p = NULL;
    int ch, index = 0;

    initLibrary(lib);

    while (1)
    {
        printf(&quot;请问是否要录入图书信息(Y/N):&quot;);
        do
        {
            ch = getchar();
        } while (ch != 'Y' &amp;&amp; ch != 'N');

        if (ch == 'Y')
        {
            if (index &lt; MAX_SIZE)
            {
                p = (struct Book*)malloc(sizeof(struct Book));
                getInput(p);
                lib[index] = p;
                index++;
                putchar('\n');
            }
            else
            {
                printf(&quot;数据库已满！\n&quot;);
                break;
            }
        }
        else
        {
            break;
        }
    }

    printf(&quot;\n数据录入完毕，开始打印验证...\n\n&quot;);
    printLibrary(lib);
    releaseLibrary(lib);

    return 0;
}
</code></pre>
<p>运行结果如下：</p>
<pre><code>//Consequence 02
请问是否要录入图书信息(Y/N):Y
请输入书名：人类简史
请输入作者：尤瓦尔·赫拉利
请输入售价：32.25
请输入出版日期：2016-3-4
请输入出版社：中信出版集团

请问是否要录入图书信息(Y/N):N

数据录入完毕，开始打印验证...

书名：人类简史
作者：尤瓦尔·赫拉利
售价：32.25
出版日期：2016-3-4
出版社：中信出版集团
</code></pre>
<h1 id="单链表">单链表</h1>
<p>我们知道，数组变量在内存中，是连续的，而且不可拓展。显然在一些情况下，这种数据结构拥有很大的局限性。比如移动数据的时候，会牵一发而动全身，尤其是反转这种操作更加令人窒息。那么，需要需要一种数据结构来弄出一种更加灵活的“数组”，那么这，就是<strong>链表</strong>。</p>
<p>本节我们只讲讲单链表。</p>
<p>所谓链表，就是由一个个<strong>结点</strong>组成的一个数据结构。每个结点都有<strong>数据域</strong>和<strong>指针域</strong>组成。其中数据域用来存储你想要存储的信息，而指针域用来存储下一个结点的地址。如图：</p>
<figure data-type="image" tabindex="1"><img src="https://timgsa.baidu.com/timg?image&amp;quality=80&amp;size=b9999_10000&amp;sec=1582172126913&amp;di=6235443bc28e35d4d02c9032141a9a3a&amp;imgtype=jpg&amp;src=http%3A%2F%2Fimg1.imgtn.bdimg.com%2Fit%2Fu%3D3182779591%2C3019656518%26fm%3D214%26gp%3D0.jpg" alt="单链表" loading="lazy"></figure>
<p>当然，链表最前面还有一个头指针，用来存储头结点的地址。</p>
<p>这样一来，链表中的每一个结点都可以不用挨个存放，因为有了指针把他们串起来。因此结点放在哪都无所谓，反正指针总是能够指向下一个元素。我们只需要知道头指针，就能够顺藤摸瓜地找到整个链表。</p>
<p>因此对于学籍数据库来说，我们只需要在Info结构体中加上一个指向自身类型的成员即可：</p>
<pre><code class="language-c">struct Info
{
    unsigned long identifier;
    char name[20];
    struct Date date;
    unsigned int years;
    struct Info* next;
};
</code></pre>
<h2 id="在单链表中插入元素">在单链表中插入元素</h2>
<h3 id="头插法">头插法</h3>
<figure data-type="image" tabindex="2"><img src="https://upload-images.jianshu.io/upload_images/10074272-da68e6d07f274ea0.jpg" alt="头插法" loading="lazy"></figure>
<p>这种每次都将数据插入单链表的头部（头指针后面）的插入法就叫头插法。</p>
<p>如果要把学生信息加入到单链表，可以这么写：</p>
<pre><code class="language-c">void addInfo(struct Info** students)//students是头指针
{
    struct Info* info, *temp;
    info = (struct Info*)malloc(sizeof(struct Info));
    if (info == NULL)
    {
        printf(&quot;内存分配失败！\n&quot;);
        exit(1);
    }
    
    getInput(info);
    
    if (*students != NULL)
    {
        temp = *students;
        *students = info;
        info-&gt;next = temp;
    }
    else
    {
        *students = info;
        info-&gt;next = NULL;
    }
}
</code></pre>
<blockquote>
<p>由于students存放的是头指针，因此我们需要传入它的地址传递给函数，才能够改变它本身的值。而students本身又是一个指向Info结构体的指针，所以参数的类型应该就是<code>struct Info**</code>。</p>
</blockquote>
<p>往单链表里面添加一个结点，也就是先申请一个结点，然后判断链表是否为空。如果为空，那么直接将头指针指向它，然后<code>next</code>成员指向<code>NULL</code>。若不为空，那么先将<code>next</code>指向头指针原本指向的结点，然后将头指针指向新结点即可。</p>
<p>那么，打印链表也变得很简单：</p>
<pre><code class="language-c">void printStu(struct Info* students)
{
    struct Info* info;
    int count = 1;
    
    info = students;
    while (book != NULL)
    {
        printf(&quot;Student%d:\n&quot;, count);
        printf(&quot;姓名：%s\n&quot;, info-&gt;name);
        printf(&quot;学号：%d\n&quot;, info-&gt;identifier);
        info = info-&gt;next;
        count++;
    }
}
</code></pre>
<p>想要读取单链表里面的数据，只需要迭代单链表中的每一个结点，直到<code>next</code>成员为<code>NULL</code>，即表示单链表的结束。</p>
<p>最后，当然还是别忘了释放空间：</p>
<pre><code class="language-c">void releaseStu(struct Info** students)
{
    struct Info* temp;
    
    while (*students != NULL)
    {
        temp = *students;
        *students = (*students)-&gt;next;
        free(temp);
    }
}
</code></pre>
<h3 id="尾插法">尾插法</h3>
<p>与头插法类似，尾插法就是把每一个数据都插入到链表的末尾。</p>
<pre><code class="language-c">void addInfo(struct Info** students)
{
    struct Info* info, *temp;
    info = (struct Info*)malloc(sizeof(struct Info));
    if (info == NULL)
    {
        printf(&quot;内存分配失败！\n&quot;);
        exit(1);
    }
    
    getInput(info);
    
    if (*students != NULL)
    {
        temp = *students;
        *students = info;
        //定位到链表的末尾的位置
        while (temp-&gt;next != NULL)
        {
            temp = temp-&gt;next;
        }
        //插入数据
        temp-&gt;next = info;
        info-&gt;next = temp;
    }
    else
    {
        *students = info;
        info-&gt;next = NULL;
    }
}
</code></pre>
<p>这么一来，程序执行的效率难免要降低很多，因为每次插入数据，都要先遍历一次链表。如果链表很长，那么对于插入数据来说就是一次灾难。不过，我们可以给程序添加一个指针，让它永远都指向链表的尾部，这样一来，就可以用很少的空间换取很高的程序执行效率。</p>
<p>代码更改如下：</p>
<pre><code class="language-c">void addInfo(struct Info** students)
{
    struct Info* info, *temp;
    static struct Info* tail;//设置静态指针
    info = (struct Info*)malloc(sizeof(struct Info));
    if (info == NULL)
    {
        printf(&quot;内存分配失败！\n&quot;);
        exit(1);
    }
    
    getInput(info);
    
    if (*students != NULL)
    {
        tail-&gt;next = info;
        info-&gt;next = NULL;
    }
    else
    {
        *students = info;
        info-&gt;next = NULL;
    }
}
</code></pre>
<h2 id="搜索单链表">搜索单链表</h2>
<p>单链表是我们用来存储数据的一个容器，那么有时候需要快速查找信息就需要开发相关搜索的功能。比如说输入学号，查找同学的所有信息。</p>
<pre><code class="language-c">struct Info *searchInfo(struct Info* students, long* target)
{
    struct Info* info;
    info = students;
    while (info != NULL)
    {
        if (info-&gt;identifier == target)
        {
            break;
        }
        info = info-&gt;next;
    }
    
    return book;
};

void printInfo(struct Info* info)
{
    ...
}
...

int main(void)
{
    ...
    printf(&quot;\n请输入学生学号：&quot;);
    scanf(&quot;%d&quot;, input);
    info = searchInfo(students, input);
    if (info == NULL)
    {
        printf(&quot;抱歉，未找到相关结果！\n&quot;);
    }
    else
    {
        do
        {
            printf(&quot;相关结果如下：\n&quot;);
            printInfo(book);
        } while ((info = searchInfo(info-&gt;next, input)) != NULL);
    }
    
    releaseInfo(...);
    return 0;
}
</code></pre>
<h2 id="插入结点到指定位置">插入结点到指定位置</h2>
<p>到了这里，才体现出链表真正的优势。</p>
<p>设想一下，如果有一个有序数组，现在要求你去插入一个数字，插入完成之后，数组依然保持有序。你会怎么做？</p>
<p>没错，你应该会挨个去比较，然后找到合适的位置（当然这里也可以使用二分法，比较节省算力），把这个位置后面的所有数都往后移动一个位置，然后将我们要插入的数字放入刚刚我们腾出来的空间里面。</p>
<p>你会发现，这样的处理方法，经常需要移动大量的数据，对于程序的执行效率来说，是一个不利因素。那么链表，就无所谓。反正在内存中，链表的存储毫无逻辑，我们只需要改变指针的值就可以实现链表的中间插入。</p>
<pre><code class="language-c">//Example 03
#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;

struct Node
{
    int value;
    struct Node* next;
};

void insNode(struct Node** head, int value)
{
    struct Node* pre;
    struct Node* cur;
    struct Node* New;

    cur = *head;
    pre = NULL;

    while (cur != NULL &amp;&amp; cur-&gt;value &lt; value)
    {
        pre = cur;
        cur = cur-&gt;next;
    }

    New = (struct Node*)malloc(sizeof(struct Node));
    if (New == NULL)
    {
        printf(&quot;内存分配失败！\n&quot;);
        exit(1);
    }
    New-&gt;value = value;
    New-&gt;next = cur;

    if (pre == NULL)
    {
        *head = New;
    }
    else
    {
        pre-&gt;next = New;
    }
}

void printNode(struct Node* head)
{
    struct Node* cur;

    cur = head;
    while (cur != NULL)
    {
        printf(&quot;%d &quot;, cur-&gt;value);
        cur = cur-&gt;next;
    }
    putchar('\n');
}

int main(void)
{
    struct Node* head = NULL;
    int input;

    printf(&quot;开始插入整数...\n&quot;);
    while (1)
    {
        printf(&quot;请输入一个整数，输入-1表示结束：&quot;);
        scanf(&quot;%d&quot;, &amp;input);
        if (input == -1)
        {
            break;
        }
        insNode(&amp;head, input);
        printNode(head);
    }

    return 0;
}
</code></pre>
<p>运行结果如下：</p>
<pre><code>//Consequence 03
开始插入整数...
请输入一个整数，输入-1表示结束：4
4
请输入一个整数，输入-1表示结束：5
4 5
请输入一个整数，输入-1表示结束：3
3 4 5
请输入一个整数，输入-1表示结束：6
3 4 5 6
请输入一个整数，输入-1表示结束：2
2 3 4 5 6
请输入一个整数，输入-1表示结束：5
2 3 4 5 5 6
请输入一个整数，输入-1表示结束：1
1 2 3 4 5 5 6
请输入一个整数，输入-1表示结束：7
1 2 3 4 5 5 6 7
请输入一个整数，输入-1表示结束：-1
</code></pre>
<h2 id="删除结点">删除结点</h2>
<p>删除结点的思路也差不多，首先修改待删除的结点的上一个结点的指针，将其指向待删除结点的下一个结点。然后释放待删除结点的空间。</p>
<pre><code class="language-c">...
void delNode(struct Node** head, int value)
{
    struct Node* pre;
    struct Node* cur;
    
    cur = *head;
    pre = NULL;
    while (cur != NULL &amp;&amp; cur-&gt;value != value)
    {
        pre = cur;
        cur = cur-&gt;next;
    }
    if (cur == NULL)
    {
        printf(&quot;未找到匹配项!\n&quot;);
        return ;
    }
    else
    {
        if (pre == NULL)
        {
            *head = cur-&gt;next;
        }
        else
        {
            pre-&gt;next = cur-&gt;next;
        }
        free(cur);
    }
}
</code></pre>
<h1 id="内存池">内存池</h1>
<p>C语言的内存管理，从来都是一个让人头秃的问题。要想更自由地管理内存，就必须去堆中申请，然后还需要考虑何时释放，万一释放不当，或者没有及时释放，造成的后果都是难以估量的。</p>
<p>当然如果就这些，那倒也还不算什么。问题就在于，如果大量地使用<code>malloc</code>和<code>free</code>函数来申请内存，首先使要经历一个从应用层切入系统内核层，调用完成之后，再返回应用层的一系列步骤，实际上使非常浪费时间的。更重要的是，还会产生大量的内存碎片。比如，先申请了一个1KB的空间，紧接着又申请了一个8KB的空间。而后，这个1KB使用完了，被释放，但是这个空间却只有等到下一次有刚好1KB的空间申请，才能够被重新调用。这么一来，极限情况下，整个堆有可能被弄得支离破碎，最终导致大量内存浪费。</p>
<p>那么这种情况下，我们解决这类问题的思路，就是创建一个内存池。</p>
<p>内存池，实际上就是我们让程序创建出来的一块额外的缓存区域，如果有需要释放内存，先不必使用<code>free</code>函数，如果内存池有空，那么直接放入内存池。同样的道理，下一次程序申请空间的时候，先检查下内存池里面有没有合适的内存，如果有，则直接拿出来调用，如果没有，那么再使用<code>malloc</code>。</p>
<p>其实内存池我们就可以使用单链表来进行维护，下面通过一个通讯录的程序来说明内存池的运用。</p>
<p>普通的版本：</p>
<pre><code class="language-c">//Example 04 V1
#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;string.h&gt;

struct Person
{
	char name[40];
	char phone[20];
	struct Person* next;
};

void getInput(struct Person* person);
void printPerson(struct Person* person);
void addPerson(struct Person** contects);
void changePerson(struct Person* contacts);
void delPerson(struct Person** contacts);
struct Person* findPerson(struct Person* contacts);
void displayContacts(struct Person* contacts);
void releaseContacts(struct Person** contacts);

void getInput(struct Person* person)
{
	printf(&quot;请输入姓名：&quot;);
	scanf(&quot;%s&quot;, person-&gt;name);
	printf(&quot;请输入电话：&quot;);
	scanf(&quot;%s&quot;, person-&gt;phone);
}

void addPerson(struct Person** contacts)
{
	struct Person* person;
	struct Person* temp;

	person = (struct Person*)malloc(sizeof(struct Person));
	if (person == NULL)
	{
		printf(&quot;内存分配失败！\n&quot;);
		exit(1);
	}

	getInput(person);

	//将person添加到通讯录中
	if (*contacts != NULL)
	{
		temp = *contacts;
		*contacts = person;
		person-&gt;next = temp;
	}
	else
	{
		*contacts = person;
		person-&gt;next = NULL;
	}
}

void printPerson(struct Person* person)
{
	printf(&quot;联系人：%s\n&quot;, person-&gt;name);
	printf(&quot;电话：%s\n&quot;, person-&gt;phone);
}

struct Person* findPerson(struct Person* contacts)
{
	struct Person* current;
	char input[40];

	printf(&quot;请输入联系人：&quot;);
	scanf(&quot;%s&quot;, input);

	current = contacts;
	while (current != NULL &amp;&amp; strcmp(current-&gt;name, input))
	{
		current = current-&gt;next;
	}

	return current;
}

void changePerson(struct Person* contacts)
{
	struct Person* person;

	person = findPerson(contacts);
	if (person == NULL)
	{
		printf(&quot;找不到联系人！\n&quot;);
	}
	else
	{
		printf(&quot;请输入联系电话：&quot;);
		scanf(&quot;%s&quot;, person-&gt;phone);
	}
}

void delPerson(struct Person** contacts)
{
	struct Person* person;
	struct Person* current;
	struct Person* previous;

	//先找到待删除的节点的指针
	person = findPerson(*contacts);
	if (person == NULL)
	{
		printf(&quot;找不到该联系人！\n&quot;);
	}
	else
	{
		current = *contacts;
		previous = NULL;

		//将current定位到待删除的节点
		while (current != NULL &amp;&amp; current != person)
		{
			previous = current;
			current = current-&gt;next;
		}

		if (previous == NULL)
		{
			//若待删除的是第一个节点
			*contacts = current-&gt;next;
		}
		else
		{
			//若待删除的不是第一个节点
			previous-&gt;next = current-&gt;next;
		}

		free(person);//将内存空间释放
	}
}

void displayContacts(struct Person* contacts)
{
	struct Person* current;

	current = contacts;
	while (current != NULL)
	{
		printPerson(current);
		current = current-&gt;next;
	}
}

void releaseContacts(struct Person** contacts)
{
	struct Person* temp;

	while (*contacts != NULL)
	{
		temp = *contacts;
		*contacts = (*contacts)-&gt;next;
		free(temp);
	}
}

int main(void)
{
	int code;
	struct Person* contacts = NULL;
	struct Person* person;

	printf(&quot;| 欢迎使用通讯录管理程序 |\n&quot;);
	printf(&quot;|--- 1:插入新的联系人 ---|\n&quot;);
	printf(&quot;|--- 2:查找现有联系人 ---|\n&quot;);
	printf(&quot;|--- 3:更改现有联系人 ---|\n&quot;);
	printf(&quot;|--- 4:删除现有联系人 ---|\n&quot;);
	printf(&quot;|--- 5:显示当前通讯录 ---|\n&quot;);
	printf(&quot;|--- 6:退出通讯录程序 ---|\n&quot;);

	while (1)
	{
		printf(&quot;\n请输入指令代码：&quot;);
		scanf(&quot;%d&quot;, &amp;code);
		switch (code)
		{
		case 1:addPerson(&amp;contacts); break;
		case 2:person = findPerson(contacts);
			if (person == NULL)
			{
				printf(&quot;找不到该联系人！\n&quot;);
			}
			else
			{
				printPerson(person);
			}
			break;
		case 3:changePerson(contacts); break;
		case 4:delPerson(&amp;contacts); break;
		case 5:displayContacts(contacts); break;
		case 6:goto END;
		}
	}

END://此处直接跳出恒循环
	releaseContacts(&amp;contacts);

	return 0;

}
</code></pre>
<p>运行结果如下：</p>
<pre><code>//Consequence 04 V1
| 欢迎使用通讯录管理程序 |
|--- 1:插入新的联系人 ---|
|--- 2:查找现有联系人 ---|
|--- 3:更改现有联系人 ---|
|--- 4:删除现有联系人 ---|
|--- 5:显示当前通讯录 ---|
|--- 6:退出通讯录程序 ---|

请输入指令代码：1
请输入姓名：HarrisWilde
请输入电话：0101111

请输入指令代码：1
请输入姓名：Jack
请输入电话：0101112

请输入指令代码：1
请输入姓名：Rose
请输入电话：0101113

请输入指令代码：2
请输入联系人：HarrisWilde
联系人：HarrisWilde
电话：0101111

请输入指令代码：2
请输入联系人：Mike
找不到该联系人！

请输入指令代码：5
联系人：Rose
电话：0101113
联系人：Jack
电话：0101112
联系人：HarrisWilde
电话：0101111

请输入指令代码：3
请输入联系人：HarrisWilde
请输入联系电话：0101234

请输入指令代码：5
联系人：Rose
电话：0101113
联系人：Jack
电话：0101112
联系人：HarrisWilde
电话：0101234

请输入指令代码：6
</code></pre>
<p>下面加入内存池：</p>
<pre><code class="language-c">//Example 04 V2
#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;string.h&gt;

#define MAX 1024

struct Person
{
	char name[40];
	char phone[20];
	struct Person* next;
};

struct Person* pool = NULL;
int count;

void getInput(struct Person* person);
void printPerson(struct Person* person);
void addPerson(struct Person** contects);
void changePerson(struct Person* contacts);
void delPerson(struct Person** contacts);
struct Person* findPerson(struct Person* contacts);
void displayContacts(struct Person* contacts);
void releaseContacts(struct Person** contacts);
void releasePool(void);

void getInput(struct Person* person)
{
	printf(&quot;请输入姓名：&quot;);
	scanf(&quot;%s&quot;, person-&gt;name);
	printf(&quot;请输入电话：&quot;);
	scanf(&quot;%s&quot;, person-&gt;phone);
}

void addPerson(struct Person** contacts)
{
	struct Person* person;
	struct Person* temp;

	//如果内存池不是空的，那么首先从里面获取空间
	if (pool != NULL)
	{
		person = pool;
		pool = pool-&gt;next;
		count--;
	}
	//内存池为空，则直接申请
	else
	{
		person = (struct Person*)malloc(sizeof(struct Person));
		if (person == NULL)
		{
			printf(&quot;内存分配失败！\n&quot;);
			exit(1);
		}
	}


	getInput(person);

	//将person添加到通讯录中
	if (*contacts != NULL)
	{
		temp = *contacts;
		*contacts = person;
		person-&gt;next = temp;
	}
	else
	{
		*contacts = person;
		person-&gt;next = NULL;
	}
}

void printPerson(struct Person* person)
{
	printf(&quot;联系人：%s\n&quot;, person-&gt;name);
	printf(&quot;电话：%s\n&quot;, person-&gt;phone);
}

struct Person* findPerson(struct Person* contacts)
{
	struct Person* current;
	char input[40];

	printf(&quot;请输入联系人：&quot;);
	scanf(&quot;%s&quot;, input);

	current = contacts;
	while (current != NULL &amp;&amp; strcmp(current-&gt;name, input))
	{
		current = current-&gt;next;
	}

	return current;
}

void changePerson(struct Person* contacts)
{
	struct Person* person;

	person = findPerson(contacts);
	if (person == NULL)
	{
		printf(&quot;找不到联系人！\n&quot;);
	}
	else
	{
		printf(&quot;请输入联系电话：&quot;);
		scanf(&quot;%s&quot;, person-&gt;phone);
	}
}

void delPerson(struct Person** contacts)
{
	struct Person* person;
	struct Person* current;
	struct Person* previous;
	struct Person* temp;
	{

	};

	//先找到待删除的节点的指针
	person = findPerson(*contacts);
	if (person == NULL)
	{
		printf(&quot;找不到该联系人！\n&quot;);
	}
	else
	{
		current = *contacts;
		previous = NULL;

		//将current定位到待删除的节点
		while (current != NULL &amp;&amp; current != person)
		{
			previous = current;
			current = current-&gt;next;
		}

		if (previous == NULL)
		{
			//若待删除的是第一个节点
			*contacts = current-&gt;next;
		}
		else
		{
			//若待删除的不是第一个节点
			previous-&gt;next = current-&gt;next;
		}

		//判断内存池中有没有空位
		if (count &lt; MAX)
		{
			//使用头插法将person指向的空间插入内存池中
			if (pool != NULL)
			{
				temp = pool;
				pool = person;
				person-&gt;next = temp;
			}
			else
			{
				pool = person;
				person-&gt;next = NULL;
			}
			count++;
		}
		//没有空位，直接释放
		else
		{
			free(person);//将内存空间释放
		}
	}
}

void displayContacts(struct Person* contacts)
{
	struct Person* current;

	current = contacts;
	while (current != NULL)
	{
		printPerson(current);
		current = current-&gt;next;
	}
}

void releaseContacts(struct Person** contacts)
{
	struct Person* temp;

	while (*contacts != NULL)
	{
		temp = *contacts;
		*contacts = (*contacts)-&gt;next;
		free(temp);
	}
}

void releasePool(void)
{
	struct Person* temp;
	while (pool != NULL)
	{
		temp = pool;
		pool = pool-&gt;next;
		free(temp);
	}
}

int main(void)
{
	int code;
	struct Person* contacts = NULL;
	struct Person* person;

	printf(&quot;| 欢迎使用通讯录管理程序 |\n&quot;);
	printf(&quot;|--- 1:插入新的联系人 ---|\n&quot;);
	printf(&quot;|--- 2:查找现有联系人 ---|\n&quot;);
	printf(&quot;|--- 3:更改现有联系人 ---|\n&quot;);
	printf(&quot;|--- 4:删除现有联系人 ---|\n&quot;);
	printf(&quot;|--- 5:显示当前通讯录 ---|\n&quot;);
	printf(&quot;|--- 6:退出通讯录程序 ---|\n&quot;);

	while (1)
	{
		printf(&quot;\n请输入指令代码：&quot;);
		scanf(&quot;%d&quot;, &amp;code);
		switch (code)
		{
		case 1:addPerson(&amp;contacts); break;
		case 2:person = findPerson(contacts);
			if (person == NULL)
			{
				printf(&quot;找不到该联系人！\n&quot;);
			}
			else
			{
				printPerson(person);
			}
			break;
		case 3:changePerson(contacts); break;
		case 4:delPerson(&amp;contacts); break;
		case 5:displayContacts(contacts); break;
		case 6:goto END;
		}
	}

END://此处直接跳出恒循环
	releaseContacts(&amp;contacts);
	releasePool();

	return 0;

}
</code></pre>
<h1 id="typedef">typedef</h1>
<h2 id="给数据类型起别名">给数据类型起别名</h2>
<p>C语言是一门古老的语言，它是在1969至1973年间，由两位天才丹尼斯·里奇和肯·汤普逊在贝尔实验室以B语言为基础开发出来的，用于他们的重写UNIX计划（这也为后来UNIX系统的可移植性打下了基础，之前的UNIX是使用汇编语言编写的，当然也是这两位为了玩一个自己设计的游戏而编写的）。天才就是和咱常人不一样，不过他俩的故事，在这篇里面不多啰嗦，我们回到话题。</p>
<p>虽然C语言诞生的很早，但是却依旧不是最早的高级编程语言。目前公认的最早的高级编程语言，是IBM公司于1957年开发的FORTRAN语言。C语言诞生之时，FORTRAN已经统领行业数十年之久。因此，C语言要想快速吸纳FORTRAN中的潜在用户，就必须做出一些妥协。</p>
<p>我们知道，不同的语言的语法，一般来说是不同的，甚至还有较大的差距。比如：</p>
<p>C:</p>
<pre><code class="language-c">int a, b, c;
float i, j, k;
</code></pre>
<p>而FORTRAN语言是这样的：</p>
<pre><code class="language-fortran">integer :: a, b, c;
real :: i, j, k;
</code></pre>
<p>如果让FORTRAN用户使用原来的变量名称进行使用，那么就能够快速迁移到C语言上面来，这就是<code>typedef</code>的用处之一。</p>
<p>我们使用FORTRAN语言的类型名，那就这么办：</p>
<pre><code class="language-c">typedef int integer;
typedef float real;

integer a, b, c;
real i, j, k;
</code></pre>
<h2 id="结构体的搭档">结构体的搭档</h2>
<p>虽然结构体的出现能够让我们有一个更科学的数据结构来管理数据，但是每次使用结构体都需要<code>struct...</code>，未免显得有些冗长和麻烦。有了<code>typedef</code>的助攻，我们就可以很轻松地给结构体类型起一个容易理解的名字：</p>
<pre><code class="language-c">typedef struct date
{
    int year;
    int month;
    int day;
} DATE;//为了区分，一般用全大写

int main(void)
{
    DATE* date;
    ...
}
</code></pre>
<p>甚至还可以顺便给它的指针也定义一个别名：</p>
<pre><code class="language-c">typedef struct date
{
    int year;
    int month;
    int day;
} DATE, *PDATE;
</code></pre>
<h2 id="进阶">进阶</h2>
<p>我们还可以利用<code>typedef</code>来简化一些比较复杂的命令。</p>
<p>比如：</p>
<pre><code class="language-c">int (*ptr) [5];
</code></pre>
<p>我们知道这是一个数组指针，指向一个5元素的数组。那么我们可以改写成这样：</p>
<pre><code class="language-c">typedef int(*PTR_TO_ARRAY)[3];
</code></pre>
<p>这样就可以把很复杂的声明变得很简单：</p>
<pre><code class="language-c">PTR_TO_ARRAY a = &amp;array;
</code></pre>
<p>取名的时候要尽量使用容易理解的名字，这样才能达到使用<code>typedef</code>的最终目的。</p>
<h1 id="共用体">共用体</h1>
<p>共用体也称联合体。</p>
<h2 id="声明">声明</h2>
<p>和结构体还是有点像：</p>
<pre><code class="language-c">union 共用体名称
{
    成员1;
    成员2;
    成员3;
};
</code></pre>
<p>但是两者有本质的不同。共用体的每一个成员共用一段内存，那么这也就意味着它们不可能同时被正确地访问。如：</p>
<pre><code class="language-c">//Example 05
#include &lt;stdio.h&gt;
#include &lt;string.h&gt;

union Test
{
	int i;
	double pi;
	char str[9];
};

int main(void)
{
	union Test test;

	test.i = 10;
	test.pi = 3.14;
	strcpy(test.str, &quot;TechZone&quot;);

	printf(&quot;test.i: %d\n&quot;, test.i);
	printf(&quot;test.pi: %.2f\n&quot;, test.pi);
	printf(&quot;test.str: %s\n&quot;, test.str);

	return 0;
}
</code></pre>
<p>执行结果如下：</p>
<pre><code>//Consequence 05
test.i: 1751344468
test.pi: 3946574856045802736197446431383475413237648487838717723111623714247921409395495328582015991082102150186282825269379326297769425957893182570875995348588904500564659454087397032067072.00
test.str: TechZone
</code></pre>
<p>可以看到，共用体只能正确地展示出最后一次被赋值的成员。共用体的内存应该要能够满足最大的成员能够正常存储。但是并不一定等于最大的成员的尺寸，因为还要考虑内存对齐的问题。</p>
<p>共用体可以类似结构体一样来定义和声明，但是共用体还可以允许不带名字：</p>
<pre><code class="language-c">union
{
	int i;
	char ch;
	float f;
} a, b;
</code></pre>
<h2 id="初始化">初始化</h2>
<p>共用体不能在同一时间存放多个成员，所以不能批量初始化</p>
<pre><code class="language-c">union data
{
    int i;
    char ch;
    float f;
};

union data a = {520};        //初始化第一个成员
union data b = a;            //直接使用一个共用体初始化另一个共用体
union data c = {.ch = 'C'};  //C99的特性，指定初始化成员
</code></pre>
<h1 id="枚举">枚举</h1>
<p>枚举是一个基本的数据类型，它可以让数据更简洁。</p>
<p>如果写一个判断星期的文章，我们当然可以使用宏定义来使代码更加易懂，不过：</p>
<pre><code class="language-c">#define MON 1
#define TUE 2
#define WED 3
#define THU 4
#define FRI 5
#define SAT 6
#define SUN 7
</code></pre>
<p>这样的写法有点费键盘。那么枚举就简单多了：</p>
<pre><code class="language-c">enum DAY
{
      MON=1, TUE, WED, THU, FRI, SAT, SUN
};
</code></pre>
<blockquote>
<p>**注意：**第一个枚举成员的默认值为整型的 0，后续枚举成员的值在前一个成员上加 1。我们在这个实例中把第一个枚举成员的值定义为 1，第二个就为 2，以此类推。</p>
</blockquote>
<p>枚举变量的定义和声明方法和共用体一样，也可以省略枚举名，直接声明变量名。</p>
<pre><code class="language-c">//Example 06
#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;

int main()
{

    enum color { red = 1, green, blue };

    enum  color favorite_color;

    printf(&quot;请输入你喜欢的颜色: (1. red, 2. green, 3. blue): &quot;);
    scanf(&quot;%d&quot;, &amp;favorite_color);

    //输出结果
    switch (favorite_color)
    {
    case red:
        printf(&quot;你喜欢的颜色是红色&quot;);
        break;
    case green:
        printf(&quot;你喜欢的颜色是绿色&quot;);
        break;
    case blue:
        printf(&quot;你喜欢的颜色是蓝色&quot;);
        break;
    default:
        printf(&quot;你没有选择你喜欢的颜色&quot;);
    }

    return 0;
}
</code></pre>
<p>执行结果如下：</p>
<pre><code>//Consequence 06
请输入你喜欢的颜色: (1. red, 2. green, 3. blue): 3
你喜欢的颜色是蓝色
</code></pre>
<p>也可以把整数转换为枚举类型：</p>
<pre><code class="language-c">//Example 07

#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;

int main()
{
    enum day
    {
        saturday,
        sunday,
        monday,
        tuesday,
        wednesday,
        thursday,
        friday
    } workday;

    int a = 1;
    enum day weekend;
    weekend = (enum day) a;  //使用强制类型转换
    //weekend = a; //错误
    printf(&quot;weekend:%d&quot;, weekend);
    return 0;
}
</code></pre>
<p>运行结果如下：</p>
<pre><code>//Consequence 07
weekend:1
</code></pre>
<h1 id="位域">位域</h1>
<p>C语言除了开发桌面应用等，还有一个很重要的领域，那就是<strong>单片机</strong>开发。单片机上的硬件资源十分有限，容不得我们去肆意挥洒。单片机使一种集成电路芯片，使采用超大规模集成电路技术把具有数据处理能力的CPU、RAM、ROM、I/O、中断系统、定时器/计数器等功能（有的还包括显示驱动电路、脉宽调制电路、模拟多路转换器、A/D转换器等电路）集成到一块硅片上构成的一个小而完善的微型计算机系统，在工控领域使用广泛。</p>
<p>对于这样的设备，通常内存只有256B，那么能够给我们利用的资源就十分珍贵了。在这种情况下，如果我们只需要定义一个变量来存放布尔值，一般就申请一个整型变量，通过1和0来间接存储。但是，显然1和0只用1个bit就能够放完，而一个整型却是4个字节，也就是32bit。这就造成了内存的浪费。</p>
<p>好在，C语言为我们提供了一种数据结构，称为<strong>位域</strong>（也叫位端、位字段）。也就是把一个字节中的二进制位划分，并且你能够指定每个区域的位数。每个域有一个域名，并允许程序中按域名进行单独操作。</p>
<p>使用位域的做法是在结构体定义的时候，在结构体成员后面使用冒号（:）和数字来表示该成员所占的位数。</p>
<pre><code class="language-c">//Example 08
#include &lt;stdio.h&gt;

int main(void)
{
	struct Test
	{
		unsigned int a : 1;
		unsigned int b : 1;
		unsigned int c : 2;
	} test;
	
	test.a = 0;
	test.b = 1;
	test.c = 2;

	printf(&quot;a = %d, b = %d, c = %d\n&quot;, test.a, test.b, test.c);
	printf(&quot;size of test = %d\n&quot;, sizeof(test));

	return 0;
}
</code></pre>
<p>运行结果如下：</p>
<pre><code>//Consequence 08
a = 0, b = 1, c = 2
size of test = 4
</code></pre>
<p>如此一来，结构体<code>test</code>只用了4bit，却存放下了0、1、2三个整数。但是由于2在二进制中是10，因此占了2个bit。如果把<code>test.b</code>赋值为2，那么：</p>
<pre><code>//Consequence 08 V2
a = 0, b = 0, c = 2
size of test = 4
</code></pre>
<p>可以看到，b中的10溢出了，只剩下0。</p>
<p>当然，位域的宽度不能够超过本身类型的长度，比如：</p>
<pre><code class="language-c">unsigned int a : 100;
</code></pre>
<p>那么就会报错：</p>
<pre><code>错误	C2034	“main::test::a”: 位域类型对位数太小
</code></pre>
<p>位域成员也可以没有名称，只要给出类型和宽度即可：</p>
<pre><code class="language-c">struct Test
{
    unsigned int x : 1;
    unsigned int y : 2;
    unsigned int z : 3;
    unsigned int : 26;
};
</code></pre>
<p>无名位域一般用来作为填充或者调整成员的位置，因为没有名称，所以无名位域并不能够拿来使用。</p>
<blockquote>
<p>C语言的标准只说明unsigned int和signed int支持位域，然后C99增加了_Bool类型也支持位域，其他数据类型理论上是不支持的。不过大多数编译器在具体实现时都进行了扩展，额外支持了signed char、unsigned char以及枚举类型，所以如果对char类型的结构体成员使用位域，基本上也没什么问题。但如果考虑到程序的可移植性，就需要谨慎对待了。另外，由于内存的基本单位是字节，而位域只是字节的一部分，所以并不能对位域进行取地址运算。</p>
</blockquote>
<p>虽然科技发展日新月异，但是秉承着节约成本这个放之四海而皆准的原则，还是要注意使用！毕竟5毛钱可能是小钱，但是乘以5000万呢？</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[C语言之结构体（上）]]></title>
        <id>https://harriswilde.github.io/post/M4QwK7i-6/</id>
        <link href="https://harriswilde.github.io/post/M4QwK7i-6/">
        </link>
        <updated>2020-02-17T13:29:26.000Z</updated>
        <content type="html"><![CDATA[<p>有的时候，我们所遇到的数据结构，不仅仅是一群数字或者是字符串那么简单。比如我们每一个人的学籍信息，学号是一个长整数，名字却是字符；甚至有更复杂的情况，这种问题在现实生活中并不少见。我们之前学过一种叫数组的数据结构，它可以允许我们把很多同类型的数据集中在一起处理。相对于之前，这已经是一次极大的进步。但是，新的问题，往往又会出现，这个时候，我们就得上更高端的装备——结构体。</p>
<p>相比于数组，结构体有以下的更强大的优势：</p>
<ul class="contains-task-list">
<li class="task-list-item"><input class="task-list-item-checkbox" checked="" disabled="" type="checkbox" id="task-item-1821936"><label class="task-list-item-label" for="task-item-1821936"> 批量存储数据</label></li>
<li class="task-list-item"><input class="task-list-item-checkbox" checked="" disabled="" type="checkbox" id="task-item-1078034"><label class="task-list-item-label" for="task-item-1078034"> 存储不同类型的数据</label></li>
<li class="task-list-item"><input class="task-list-item-checkbox" checked="" disabled="" type="checkbox" id="task-item-6583966"><label class="task-list-item-label" for="task-item-6583966"> 支持嵌套</label></li>
</ul>
<h1 id="结构体的声明与定义">结构体的声明与定义</h1>
<h2 id="声明">声明</h2>
<p>结构体的声明使用<code>struct</code>关键字，如果我们想要把我们的学籍信息组织以下的话，可以这样表示：</p>
<pre><code class="language-c">struct Info
{
    unsigned long identifier;//学号，用无符号长整数表示
    char name[20];//名字，用字符数组表示
    unsigned int year;//入学年份，用无符号整数表示
    unsigned int years;//学制，用无符号整数表示
}
</code></pre>
<p>这样，我们就相当于描绘好了一个框架，以后要用的话直接定义一个这种类型的变量就好了。</p>
<h2 id="定义">定义</h2>
<p>我们刚刚申请了一个名叫<code>Info</code>的结构体类型，那么理论上我们可以像声明其他变量的操作一样，去声明我们的结构体操作，但是C语言中规定，声明结构体变量的时候，<code>struct</code>关键字是不可少的。</p>
<p><code>struct 结构体类型名 结构体变量名</code></p>
<p>不过，你可以在某个函数里面定义：</p>
<pre><code class="language-c">#include &lt;stdio.h&gt;

struct Info
{
    unsigned long identifier;//学号，用无符号长整数表示
    char name[20];//名字，用字符数组表示
    unsigned int year;//入学年份，用无符号整数表示
    unsigned int years;//学制，用无符号整数表示
};

int main(void)
{
    /**
     *在main函数中声明结构体变量
     *结构体变量名叫info
     *struct关键字不能丢
     */
    struct Info info;
    ...
}
</code></pre>
<p>也可以在声明的时候就把变量名定义下来（此时这个变量是全局变量）：</p>
<pre><code class="language-c">#include &lt;stdio.h&gt;

struct Info
{
    unsigned long identifier;//学号，用无符号长整数表示
    char name[20];//名字，用字符数组表示
    unsigned int year;//入学年份，用无符号整数表示
    unsigned int years;//学制，用无符号整数表示
} info;
/**
 *此时直接定义了变量
 *该变量是全局变量
 *变量名叫info
 */

int main(void)
{
    ...
}
</code></pre>
<h2 id="访问结构体成员">访问结构体成员</h2>
<p>结构体成员的访问有点不同于以往的任何变量，它是采用点号运算符<code>.</code>来访问成员的。比如，<code>info.name</code>就是引用<code>info</code>结构体的<code>name</code>成员，是一个字符数组，而<code>info.year</code>则可以查到入学年份，是个无符号整型。</p>
<p>比如，下面开始录入学生的信息：</p>
<pre><code class="language-c">//Example 01
#include &lt;stdio.h&gt;

struct Info
{
    unsigned long identifier;//学号，用无符号长整数表示
    char name[20];//名字，用字符数组表示
    unsigned int year;//入学年份，用无符号整数表示
    unsigned int years;//学制，用无符号整数表示
};

int main(void)
{
    struct Info info;

    printf(&quot;请输入学生的学号：&quot;);
    scanf(&quot;%d&quot;, &amp;info.identifier);
    printf(&quot;请输入学生的姓名：&quot;);
    scanf(&quot;%s&quot;, info.name);
    printf(&quot;请输入学生的入学年份：&quot;);
    scanf(&quot;%d&quot;, &amp;info.year);
    printf(&quot;请输入学生的学制：&quot;);
    scanf(&quot;%d&quot;, &amp;info.years);

    printf(&quot;\n数据录入完毕\n\n&quot;);

    printf(&quot;学号：%d\n姓名：%s\n入学年份：%d\n学制：%d\n毕业时间：%d\n&quot;, \
        info.identifier, info.name, info.year, info.years, info.year + info.years);
    return 0;
}
</code></pre>
<p>运行结果如下：</p>
<pre><code>//Consequence 01
请输入学生的学号：20191101
请输入学生的姓名：Harris
请输入学生的入学年份：2019
请输入学生的学制：4

数据录入完毕

学号：20191101
姓名：Harris
入学年份：2019
学制：4
毕业时间：2023
</code></pre>
<h2 id="初始化结构体">初始化结构体</h2>
<p>像数组一样，结构体也可以在定义的时候初始化，方法也几乎一样：</p>
<pre><code class="language-c">struct Info info = {
    20191101,
    &quot;Harris&quot;,
    2019,
    4
};
</code></pre>
<p>在C99标准中，还支持给指定元素赋值（就像数组一样）：</p>
<pre><code class="language-c">struct Info info = {
    .name = &quot;Harris&quot;,
    .year = 2019
};
</code></pre>
<p>对于没有被初始化的成员，则<strong>数值型</strong>成员初始化为0，<strong>字符型</strong>成员初始化为‘\0’。</p>
<h2 id="对齐">对齐</h2>
<p>下面这个代码，大家来看看会发生什么：</p>
<pre><code class="language-c">//EXample 02 V1
#include &lt;stdio.h&gt;

int main(void)
{
    struct A
    {
        char a;
        int b;
        char c;
    } a = {'a', 10, 'o'};
    
    printf(&quot;size of a = %d\n&quot;, sizeof(a));
    
    return 0;
}
</code></pre>
<p>我们之前学过，<code>char</code>类型的变量占1字节，<code>int</code>类型的变量占4字节，那么这么一算，一个结构体A型的变量应该就是6字节了。别急，我们看运行结果：</p>
<pre><code>//COnsequence 02 V1
size of a = 12
</code></pre>
<p>怎么变成12了呢？标准更新了？老师教错了？都不是。我们把代码改一下：</p>
<pre><code class="language-c">//EXample 02 V2
#include &lt;stdio.h&gt;

int main(void)
{
    struct A
    {
        char a;
        char c;
        int b;
    } a = {'a', 'o', 10};
    
    printf(&quot;size of a = %d\n&quot;, sizeof(a));
    
    return 0;
}
</code></pre>
<p>结果：</p>
<pre><code>//Consequence 02 V2
size of a = 8
</code></pre>
<p>实际上，这是编译器对我们程序的一种优化——内存对齐。在第一个例子中，第一个和第三个成员是<code>char</code>类型是1个字节，而中间的<code>int</code>却有4个字节，为了对齐，两个<code>char</code>也占用了4个字节，于是就是12个字节。</p>
<p>而在第二个例子里面，前两个都是<code>char</code>，最后一个是<code>int</code>，那么前两个可以一起占用4个字节（实际只用2个，第一个例子也同理，只是为了访问速度更快，而不是为了扩展），最后的<code>int</code>占用4字节，合起来就是8个字节。</p>
<p>关于如何声明结构体来节省内存容量，可以阅读下面的这篇文章，作者是艾瑞克·雷蒙，时尚最具争议性的黑客之一，被公认为开源运动的主要领导者之一：</p>
<p><a href="https://harriswilde.github.io/post/LUjp1bkYi/">英文原版</a>，<a href="https://harriswilde.github.io/post/LUjp1bkYi/">中文版</a></p>
<h1 id="结构体嵌套">结构体嵌套</h1>
<p>在学籍里面，如果我们的日期想要更加详细一些，精确到day，这时候就可以使用结构体嵌套来完成：</p>
<pre><code class="language-c">#include &lt;stdio.h&gt;

struct Date
{
    unsigned int year;
    unsigned int month;
    unsigned int day;
};

struct Info
{
    unsigned long identifier;//学号，用无符号长整数表示
    char name[20];//名字，用字符数组表示
    struct Date date;/*---入学日期，用结构体Date表示---*/
    unsigned int years;//学制，用无符号整数表示
};

int main(void)
{
    ...
}
</code></pre>
<p>如此一来，比我们单独声明普通变量快多了。</p>
<p>不过，这样访问变量，就必须用点号一层层往下访问。比如要访问<code>day</code>这个成员，那就只能<code>info.date.day</code>而不能直接<code>info.date</code>或者<code>info,day</code>。</p>
<pre><code class="language-c">//Example 03
#include &lt;stdio.h&gt;

struct Date
{
    unsigned int year;
    unsigned int month;
    unsigned int day;
};

struct Info
{
    unsigned long identifier;//学号，用无符号长整数表示
    char name[20];//名字，用字符数组表示
    struct Date date;/*---入学日期，用结构体Date表示---*/
    unsigned int years;//学制，用无符号整数表示
};

int main(void)
{
    struct Info info;
    printf(&quot;请输入学生的学号：&quot;);
    scanf(&quot;%d&quot;, &amp;info.identifier);
    printf(&quot;请输入学生的姓名：&quot;);
    scanf(&quot;%s&quot;, info.name);
    printf(&quot;请输入学生的入学年份：&quot;);
    scanf(&quot;%d&quot;, &amp;info.date.year);
    printf(&quot;请输入学生的入学月份：&quot;);
    scanf(&quot;%d&quot;, &amp;info.date.month);
    printf(&quot;请输入学生的入学日期：&quot;);
    scanf(&quot;%d&quot;, &amp;info.date.day);
    printf(&quot;请输入学生的学制：&quot;);
    scanf(&quot;%d&quot;, &amp;info.years);

    printf(&quot;\n数据录入完毕\n\n&quot;);

    printf(&quot;学号：%d\n姓名：%s\n入学时间：%d/%d/%d\n学制：%d\n毕业时间：%d\n&quot;,\
           info.identifier, info.name,\
           info.date.year, info.date.month, info.date.day,\
           info.years, info.date.year + info.years);
    return 0;
}
</code></pre>
<p>运行结果如下：</p>
<pre><code>//Consequence 03
请输入学生的学号：20191101
请输入学生的姓名：Harris
请输入学生的入学年份：2019
请输入学生的入学月份：9
请输入学生的入学日期：7
请输入学生的学制：4

数据录入完毕

学号：20191101
姓名：Harris
入学时间：2019/9/7
学制：4
毕业时间：2023
</code></pre>
<h1 id="结构体数组">结构体数组</h1>
<p>刚刚我们演示了存储一个学生的学籍信息的时候，使用结构体的例子。那么，如果要录入一批学生，这时候我们就可以沿用之前的思路，使用结构体数组。</p>
<p>我们知道，数组的定义，就是存放一堆相同类型的数据的容器。而结构体一旦被我们声明，那么你就可以把它看作一个类型，只不过是你自己定义的罢了。</p>
<p>定义结构体数组也很简单：</p>
<pre><code class="language-c">struct 结构体类型
{
    成员;
} 数组名[长度];

/****或者这样****/

struct 结构体类型
{
    成员;
};
struct 结构体类型 数组名[长度];
</code></pre>
<h1 id="结构体指针">结构体指针</h1>
<p>既然我们可以把结构体看作一个类型，那么也就必然有对应的指针变量。</p>
<pre><code class="language-c">struct Info* pinfo;
</code></pre>
<p>但是在指针这里，结构体和数组就不一样了。我们知道，数组名实际上就是指向这个数组第一个元素的地址，所以可以将数组名直接赋值给指针。而结构体的变量名并不是指向该结构体的地址，所以要使用取地址运算符<code>&amp;</code>才能获取地址：</p>
<pre><code class="language-c">pinfo = &amp;info;
</code></pre>
<p>通过结构体指针来访问结构体有以下两种方法：</p>
<ol>
<li><code>(*结构体指针).成员名</code></li>
<li><code>结构体指针-&gt;成员名</code></li>
</ol>
<p>第一个方法由于点号运算符比指针的取值运算符优先级更高，因此需要加一个小括号来确定优先级，让指针先解引用变成结构体变量，在使用点号的方法去访问。</p>
<p>相比之下，第二种方法就直观许多。</p>
<p>这两种方法在实现上是完全等价的，但是点号只能用于结构体变量，而箭头只能够用于指针。</p>
<p>第一种方法：</p>
<pre><code class="language-c">#include &lt;stdio.h&gt;
...
int main(void)
{
    struct Info *p;
    p = &amp;info;
    
    printf(&quot;学号：\n&quot;, (*p).identifier);
    printf(&quot;姓名：\n&quot;, (*p).name);
    printf(&quot;入学时间：%d/%d/%d\n&quot;, (*p).date.year, (*p).date.month, (*p).date.day);
    printf(&quot;学制：\n&quot;, (*p).years);
    return 0;
}
</code></pre>
<p>第二种方法：</p>
<pre><code class="language-c">#include &lt;stdio.h&gt;
...
int main(void)
{
    struct Info *p;
    p = &amp;info;
    
    printf(&quot;学号：\n&quot;, p -&gt; identifier);
    printf(&quot;姓名：\n&quot;, p -&gt; name);
    printf(&quot;入学时间：%d/%d/%d\n&quot;, p -&gt; date.year, p -&gt; date.month, p -&gt; date.day);
    printf(&quot;学制：\n&quot;, p -&gt; years);
    return 0;
}
</code></pre>
<h1 id="传递结构体信息">传递结构体信息</h1>
<h2 id="传递结构体变量">传递结构体变量</h2>
<p>我们先来看看下面的代码：</p>
<pre><code class="language-c">//Example 04
#include &lt;stdio.h&gt;

int main(void)
{
    struct Test
    {
        int x;
        int y;
    }t1, t2;

    t1.x = 3;
    t1.y = 4;
    t2 = t1;

    printf(&quot;t2.x = %d, t2.y = %d\n&quot;, t2.x, t2.y);
    return 0;
}
</code></pre>
<p>运行结果如下：</p>
<pre><code>//Consequence 04
t2.x = 3, t2.y = 4
</code></pre>
<p>这么看来，结构体是可以直接赋值的。那么既然这样，作为函数的参数和返回值也自然是没问题的了。</p>
<p>先来试试作为参数:</p>
<pre><code class="language-c">//Example 05
#include &lt;stdio.h&gt;
struct Date
{
    unsigned int year;
    unsigned int month;
    unsigned int day;
};

struct Info
{
    unsigned long identifier;
    char name[20];
    struct Date date;
    unsigned int years;
};

struct Info getInput(struct Info info);
void printInfo(struct Info info);

struct Info getInput(struct Info info)
{
    printf(&quot;请输入学号：&quot;);
    scanf(&quot;%d&quot;, &amp;info.identifier);
    printf(&quot;请输入姓名：&quot;);
    scanf(&quot;%s&quot;, info.name);
    printf(&quot;请输入入学年份：&quot;);
    scanf(&quot;%d&quot;, &amp;info.date.year);
    printf(&quot;请输入月份：&quot;);
    scanf(&quot;%d&quot;, &amp;info.date.month);
    printf(&quot;请输入日期：&quot;);
    scanf(&quot;%d&quot;, &amp;info.date.day);
    printf(&quot;请输入学制：&quot;);
    scanf(&quot;%d&quot;, &amp;info.years);

    return info;
}

void printInfo(struct Info info)
{
    printf(&quot;学号：%d\n姓名：%s\n入学时间：%d/%d/%d\n学制：%d\n毕业时间：%d\n&quot;, \
        info.identifier, info.name, \
        info.date.year, info.date.month, info.date.day, \
        info.years, info.date.year + info.years);
}

int main(void)
{
    struct Info i1 = {};
    struct Info i2 = {};
    printf(&quot;请录入第一个同学的信息...\n&quot;);
    i1 = getInput(i1);
    putchar('\n');
    printf(&quot;请录入第二个学生的信息...\n&quot;);
    i2 = getInput(i2);

    printf(&quot;\n录入完毕，现在开始打印...\n\n&quot;);
    printf(&quot;打印第一个学生的信息...\n&quot;);
    printInfo(i1);
    putchar('\n');
    printf(&quot;打印第二个学生的信息...\n&quot;);
    printInfo(i2);

    return 0;
}
</code></pre>
<p>运行结果如下：</p>
<pre><code>//Consequence 05
请录入第一个同学的信息...
请输入学号：20191101
请输入姓名：Harris
请输入入学年份：2019
请输入月份：9
请输入日期：7
请输入学制：4

请录入第二个学生的信息...
请输入学号：20191102
请输入姓名：Joy
请输入入学年份：2019
请输入月份：9
请输入日期：8
请输入学制：5

录入完毕，现在开始打印...

打印第一个学生的信息...
学号：20191101
姓名：Harris
入学时间：2019/9/7
学制：4
毕业时间：2023

打印第二个学生的信息...
学号：20191102
姓名：Joy
入学时间：2019/9/8
学制：5
毕业时间：2024
</code></pre>
<h2 id="传递指向结构体变量的指针">传递指向结构体变量的指针</h2>
<p>早期的C语言是不允许直接将结构体作为参数直接传递进去的。主要是考虑到如果结构体的内存占用太大，那么整个程序的内存开销就会爆炸。不过现在的C语言已经放开了这方面的限制。</p>
<p>不过，作为一名合格的开发者，我们应该要去珍惜硬件资源。那么，传递指针就是一个很好的办法。</p>
<p>将刚才的代码修改一下：</p>
<pre><code class="language-c">//Example 06
#include &lt;stdio.h&gt;
struct Date
{
    unsigned int year;
    unsigned int month;
    unsigned int day;
};

struct Info
{
    unsigned long identifier;
    char name[20];
    struct Date date;
    unsigned int years;
};

void getInput(struct Info *info);
void printInfo(struct Info *info);

void getInput(struct Info *info)
{
    printf(&quot;请输入学号：&quot;);
    scanf(&quot;%d&quot;, &amp;info-&gt;identifier);
    printf(&quot;请输入姓名：&quot;);
    scanf(&quot;%s&quot;, info-&gt;name);
    printf(&quot;请输入入学年份：&quot;);
    scanf(&quot;%d&quot;, &amp;info-&gt;date.year);
    printf(&quot;请输入月份：&quot;);
    scanf(&quot;%d&quot;, &amp;info-&gt;date.month);
    printf(&quot;请输入日期：&quot;);
    scanf(&quot;%d&quot;, &amp;info-&gt;date.day);
    printf(&quot;请输入学制：&quot;);
    scanf(&quot;%d&quot;, &amp;info-&gt;years);
}

void printInfo(struct Info *info)
{
    printf(&quot;学号：%d\n姓名：%s\n入学时间：%d/%d/%d\n学制：%d\n毕业时间：%d\n&quot;, \
        info-&gt;identifier, info-&gt;name, \
        info-&gt;date.year, info-&gt;date.month, info-&gt;date.day, \
        info-&gt;years, info-&gt;date.year + info-&gt;years);
}

int main(void)
{
    struct Info i1 = {};
    struct Info i2 = {};
    printf(&quot;请录入第一个同学的信息...\n&quot;);
    getInput(&amp;i1);
    putchar('\n');
    printf(&quot;请录入第二个学生的信息...\n&quot;);
    getInput(&amp;i2);

    printf(&quot;\n录入完毕，现在开始打印...\n\n&quot;);
    printf(&quot;打印第一个学生的信息...\n&quot;);
    printInfo(&amp;i1);
    putchar('\n');
    printf(&quot;打印第二个学生的信息...\n&quot;);
    printInfo(&amp;i2);

    return 0;
}
</code></pre>
<p>此时传递的就是一个指针，而不是一个庞大的结构体。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[失传的结构体打包艺术]]></title>
        <id>https://harriswilde.github.io/post/qb0i5L7tn/</id>
        <link href="https://harriswilde.github.io/post/qb0i5L7tn/">
        </link>
        <updated>2020-02-17T08:38:35.000Z</updated>
        <summary type="html"><![CDATA[<blockquote>
<p>《失传的结构体打包艺术》(中文版)<br>
转载自：<a href="https://github.com/ludx/The-Lost-Art-of-C-Structure-Packing">https://github.com/ludx/The-Lost-Art-of-C-Structure-Packing</a><br>
作者：Eric S. Raymond<br>
原文链接：<a href="http://www.catb.org/esr/structure-packing/">http://www.catb.org/esr/structure-packing/</a></p>
</blockquote>
]]></summary>
        <content type="html"><![CDATA[<blockquote>
<p>《失传的结构体打包艺术》(中文版)<br>
转载自：<a href="https://github.com/ludx/The-Lost-Art-of-C-Structure-Packing">https://github.com/ludx/The-Lost-Art-of-C-Structure-Packing</a><br>
作者：Eric S. Raymond<br>
原文链接：<a href="http://www.catb.org/esr/structure-packing/">http://www.catb.org/esr/structure-packing/</a></p>
</blockquote>
<!-- more -->
<h1 id="谁应阅读本文">谁应阅读本文</h1>
<p>本文探讨如何通过手工重新打包C结构体声明，来减小内存空间占用。你需要掌握基本的C语言知识，以理解本文所讲述的内容。</p>
<p>如果你在内存容量受限的嵌入式系统中写程序，或者编写操作系统内核代码，就有必要了解这项技术。如果数据集巨大，应用时常逼近内存极限，这项技术会有所帮助。倘若你非常非常关心如何最大限度地减少处理器缓存段（cache-line）未命中情况的发生，这项技术也有所裨益。</p>
<p>最后，理解这项技术是通往其他C语言艰深话题的门径。若不掌握，就算不上高级C程序员。当你自己也能写出这样的文档，并且有能力明智地评价它之后，才称得上C语言大师。</p>
<h1 id="缘何写作本文">缘何写作本文</h1>
<p>2013年底，我大量应用了一项C语言优化技术，这项技术是我早在二十余年前就已掌握的，但彼时之后，鲜有使用。</p>
<p>我需要减少一个程序对内存空间的占用，它使用了上千（有时甚至几十万）C结构体实例。这个程序是cvs-fast-export，在将其应用于大规模软件仓库时，程序会出现内存耗尽错误。</p>
<p>通过精心调整结构成体员的顺序，可以在这种情况下大幅减少内存占用。其效果显著——在上述案例中，可以减少40%的内存空间。程序应用于更大的软件仓库，也不会因内存耗尽而崩溃。</p>
<p>但随着工作展开，我意识到这项技术在近些年几乎已被遗忘。Web搜索证实了我的想法，现今的C程序员们似乎已不再谈论这些话题，至少从搜索引擎中看不到。维基百科有些条目涉及这一主题，但未曾有人完整阐述。</p>
<p>事出有因。计算机科学课程（正确地）引导人们远离微观优化，转而寻求更理想的算法。计算成本一路走低，令压榨内存的必要性变得越来越低。旧日里，黑客们通过在陌生的硬件架构中跌跌撞撞学习——如今已不多见。</p>
<p>然而这项技术在关键时刻仍颇具价值，并且只要内存容量有限，价值就始终存在。本文意在节省C程序员重新发掘这项技术所需的时间，让他们有精力关注更重要任务。</p>
<h1 id="对齐要求">对齐要求</h1>
<p>首先需要了解的是，对于现代处理器，C编译器在内存中放置基本C数据类型的方式受到约束，以令内存的访问速度更快。</p>
<p>在x86或ARM处理器中，基本C数据类型通常并不存储于内存中的随机字节地址。实际情况是，除char外，所有其他类型都有“对齐要求”：char可起始于任意字节地址，2字节的short必须从偶数字节地址开始，4字节的int或float必须从能被4整除的地址开始，8比特的long和double必须从能被8整除的地址开始。无论signed（有符号）还是unsigned（无符号）都不受影响。</p>
<p>用行话来说，x86和ARM上的基本C类型是“自对齐（self-aligned）”的。关于指针，无论32位（4字节）还是64位（8字节）也都是自对齐的。</p>
<p>自对齐可令访问速度更快，因为它有利于生成单指令（single-instruction）存取这些类型的数据。另一方面，如若没有对齐约束，可能最终不得不通过两个或更多指令访问跨越机器字边界的数据。字符数据是种特殊情况，因其始终处在单一机器字中，所以无论存取何处的字符数据，开销都是一致的。这也就是它不需要对齐的原因。</p>
<p>我提到“现代处理器”，是因为有些老平台强迫C程序违反对齐规则（例如，为int指针分配一个奇怪的地址并试图使用它），不仅令速度减慢，还会导致非法指令错误。例如Sun SPARC芯片就有这种问题。事实上，如果你下定决心，并恰当地在处理器中设置标志位（e18），在x86平台上，也能引发这种错误。</p>
<p>另外，自对齐并非唯一规则。纵观历史，有些处理器，由其是那些缺乏桶式移位器（Barrel shifter）的处理器限制更多。如果你从事嵌入式系统领域编程，有可能掉进这些潜伏于草丛之中的陷阱。小心这种可能。</p>
<p>你还可以通过pragma指令（通常为<code>#pragma pack</code>）强迫编译器不采用处理器惯用的对齐规则。但请别随意运用这种方式，因为它强制生成开销更大、速度更慢的代码。通常，采用我在下文介绍的方式，可以节省相同或相近的内存。</p>
<p>使用#pragma pack的唯一理由是——假如你需让C语言的数据分布，与某种位级别的硬件或协议完全匹配（例如内存映射硬件端口），而违反通用对齐规则又不可避免。如果你处于这种困境，且不了解我所讲述的内容，那你已深陷泥潭，祝君好运。</p>
<h1 id="填充">填充</h1>
<p>我们来看一个关于变量在内存中分布的简单案例。思考形式如下的一系列变量声明，它们处在一个C模块的顶层。</p>
<pre><code class="language-C">char *p;
char c;
int x;
</code></pre>
<p>假如你对数据对齐一无所知，也许以为这3个变量将在内存中占据一段连续空间。也就是说，在32位系统上，一个4字节指针之后紧跟着1字节的char，其后又紧跟着4字节int。在64位系统中，唯一的区别在于指针将占用8字节。</p>
<p>然而实际情况（在x86、ARM或其他采用自对齐类型的平台上）如下。存储p需要自对齐的4或8字节空间，这取决于机器字的大小。这是指针对齐——极其严格。</p>
<p>c紧随其后，但接下来x的4字节对齐要求，将强制在分布中生成了一段空白，仿佛在这段代码中插入了第四个变量，如下所示。</p>
<pre><code class="language-C">char *p;      /* 4 or 8 bytes */
char c;       /* 1 byte */
char pad[3];  /* 3 bytes */
int x;        /* 4 bytes */
</code></pre>
<p>字符数组<code>pad[3]</code>意味着在这个结构体中，有3个字节的空间被浪费掉了。老派术语将其称之为“废液（slop）”。</p>
<p>如果x为2字节short：</p>
<pre><code class="language-C">char *p;
char c;
short x;
</code></pre>
<p>在这个例子中，实际分布将会是：</p>
<pre><code class="language-C">char *p;      /* 4 or 8 bytes */
char c;       /* 1 byte */
char pad[1];  /* 1 byte */
short x;      /* 2 bytes */
</code></pre>
<p>另一方面，如果x为64位系统中的long：</p>
<pre><code class="language-C">char *p;
char c;
long x;
</code></pre>
<p>我们将得到：</p>
<pre><code class="language-C">char *p;     /* 8 bytes */
char c;      /* 1 byte */
char pad[7]; /* 7 bytes */
long x;      /* 8 bytes */
</code></pre>
<p>若你一路仔细读下来，现在可能会思索，何不首先声明较短的变量？</p>
<pre><code class="language-C">char c;
char *p;
int x;
</code></pre>
<p>假如实际内存分布可以写成下面这样：</p>
<pre><code class="language-C">char c;
char pad1[M];
char *p;
char pad2[N];
int x;
</code></pre>
<p>那<code>M</code>与<code>N</code>分别为几何？</p>
<p>首先，在此例中，<code>N</code>将为0，<code>x</code>的地址紧随<code>p</code>之后，能确保是与指针对齐的，因为指针的对齐要求总比int严格。</p>
<p><code>M</code>的值就不易预测了。编译器若是恰好将<code>c</code>映射为机器字的最后一个字节，那么下一个字节（<code>p</code>的第一个字节）将恰好由此开始，并恰好与指针对齐。这种情况下，<code>M</code>将为0。</p>
<p>不过更有可能的情况是，<code>c</code>将被映射为机器字的首字节。于是乎<code>M</code>将会用于填充，以使<code>p</code>指针对齐——32位系统中为3字节，64位系统中为7字节。</p>
<p>中间情况也有可能发生。M的值有可能在0到7之间（32位系统为0到3），因为char可以从机器字的任何位置起始。</p>
<p>倘若你希望这些变量占用的空间更少，那么可以交换<code>x</code>与<code>c</code>的次序。</p>
<pre><code class="language-C">char *p;     /* 8 bytes */
long x;      /* 8 bytes */
char c;      /* 1 byte */
</code></pre>
<p>通常，对于C代码中的少数标量变量（scalar variable），采用调换声明次序的方式能节省几个有限的字节，效果不算明显。而将这种技术应用于非标量变量（nonscalar variable）——尤其是结构体，则要有趣多了。</p>
<p>在讲述这部分内容前，我们先对标量数组做个说明。在具有自对齐类型的平台上，char、short、int、long和指针数组都没有内部填充，每个成员都与下一个成员自动对齐。</p>
<p>在下一节我们将会看到，这种情况对结构体数组并不适用。</p>
<h1 id="结构体的对齐和填充">结构体的对齐和填充</h1>
<p>通常情况下，结构体实例以其最宽的标量成员为基准进行对齐。编译器之所以如此，是因为此乃确保所有成员自对齐，实现快速访问最简便的方法。</p>
<p>此外，在C语言中，结构体的地址，与其第一个成员的地址一致——不存在头填充（leading padding）。小心：在C++中，与结构体相似的类，可能会打破这条规则！（是否真的如此，要看基类和虚拟成员函数是如何实现的，与不同的编译器也有关联。）</p>
<p>假如你对此有疑惑，ANSI C提供了一个<code>offsetof()</code>宏，可用于读取结构体成员位移。</p>
<p>考虑这个结构体：</p>
<pre><code class="language-C">struct foo1 {
    char *p;
    char c;
    long x;
};
</code></pre>
<p>假定处在64位系统中，任何<code>struct fool</code>的实例都采用8字节对齐。不出所料，其内存分布将会像下面这样：</p>
<pre><code class="language-C">struct foo1 {
    char *p;     /* 8 bytes */
    char c;      /* 1 byte */
    char pad[7]; /* 7 bytes */
    long x;      /* 8 bytes */
};
</code></pre>
<p>看起来仿佛与这些类型的变量单独声明别无二致。但假如我们将<code>c</code>放在首位，就会发现情况并非如此。</p>
<pre><code class="language-C">struct foo2 {
    char c;      /* 1 byte */
    char pad[7]; /* 7 bytes */
    char *p;     /* 8 bytes */
    long x;      /* 8 bytes */
};
</code></pre>
<p>如果成员是互不关联的变量，<code>c</code>便可能从任意位置起始，<code>pad</code>的大小则不再固定。因为<code>struct foo2</code>的指针需要与其最宽的成员为基准对齐，这变得不再可能。现在<code>c</code>需要指针对齐，接下来填充的7个字节被锁定了。</p>
<p>现在，我们来谈谈结构体的尾填充（trailing padding）。为了解释它，需要引入一个基本概念，我将其称为结构体的“跨步地址（stride address）”。它是在结构体数据之后，与结构体对齐一致的首个地址。</p>
<p>结构体尾填充的通用法则是：编译器将会对结构体进行尾填充，直至它的跨步地址。这条法则决定了<code>sizeof()</code>的返回值。</p>
<p>考虑64位x86或ARM系统中的这个例子：</p>
<pre><code class="language-C">struct foo3 {
    char *p;     /* 8 bytes */
    char c;      /* 1 byte */
};

struct foo3 singleton;
struct foo3 quad[4];
</code></pre>
<p>你以为<code>sizeof(struct foo3)</code>的值是9，但实际是16。它的跨步地址是<code>(&amp;p)[2]</code>。于是，在<code>quad</code>数组中，每个成员都有7字节的尾填充，因为下个结构体的首个成员需要在８字节边界上对齐。内存分布就好像这个结构是这样声明的：</p>
<pre><code class="language-C">struct foo3 {
    char *p;     /* 8 bytes */
    char c;      /* 1 byte */
    char pad[7];
};
</code></pre>
<p>作为对比，思考下面的例子：</p>
<pre><code class="language-C">struct foo4 {
    short s;     /* 2 bytes */
    char c;      /* 1 byte */
};
</code></pre>
<p>因为<code>s</code>只需要2字节对齐，跨步地址仅在<code>c</code>的1字节之后，整个<code>struct foo4</code>也只需要1字节的尾填充。形式如下：</p>
<pre><code class="language-C">struct foo4 {
    short s;     /* 2 bytes */
    char c;      /* 1 byte */
    char pad[1];
};
</code></pre>
<p><code>sizeof(struct foo4)</code>的返回值将为4。</p>
<p>现在我们考虑位域（bitfields）。利用位域，你能声明比字符宽度更小的成员，低至１位，例如：</p>
<pre><code class="language-C">struct foo5 {
    short s;
    char c;
    int flip:1;
    int nybble:4;
    int septet:7;
};
</code></pre>
<p>关于位域需要了解的是，它们是由字（或字节）层面的掩码和移位指令实现的。从编译器的角度来看，<code>struct foo5</code>中的位域就像２字节、16位的字符数组，只用到了其中12位。为了使结构体的长度是其最宽成员长度<code>sizeof(short)</code>的整数倍，接下来进行了填充。</p>
<pre><code class="language-C">struct foo5 {
    short s;       /* 2 bytes */
    char c;        /* 1 byte */
    int flip:1;    /* total 1 bit */
    int nybble:4;  /* total 5 bits */
    int septet:7;  /* total 12 bits */
    int pad1:4;    /* total 16 bits = 2 bytes */
    char pad2;     /* 1 byte */
};
</code></pre>
<p>这是最后一个重要细节：如果你的结构体中含有结构体成员，内层结构体也要和最长的标量有相同的对齐。假如你写下了这段代码：</p>
<pre><code class="language-C">struct foo6 {
    char c;
    struct foo5 {
        char *p;
        short x;
    } inner;
};
</code></pre>
<p>内层结构体成员<code>char *p</code>强迫外层结构体与内层结构体指针对齐一致。在64位系统中，实际的内存分布将类似这样：</p>
<pre><code class="language-C">struct foo6 {
    char c;           /* 1 byte */
    char pad1[7];     /* 7 bytes */
    struct foo6_inner {
        char *p;      /* 8 bytes */
        short x;      /* 2 bytes */
        char pad2[6]; /* 6 bytes */
    } inner;
};
</code></pre>
<p>它启示我们，能通过重新打包节省空间。24个字节中，有13个为填充，浪费了超过50%的空间！</p>
<h1 id="结构体成员重排">结构体成员重排</h1>
<p>理解了编译器在结构体中间和尾部插入填充的原因与方式后，我们来看看如何榨出这些废液。此即结构体打包的技艺。</p>
<p>首先注意，废液只存在于两处。其一是较大的数据类型（需要更严格的对齐）跟在较小的数据类型之后。其二是结构体自然结束的位置在跨步地址之前，这里需要填充，以使下个结构体能正确地对齐。</p>
<p>消除废液最简单的方式，是按对齐值递减重新对结构体成员排序。即让所有指针对齐成员排在最前面，因为在64位系统中它们占用8字节；然后是4字节的int；再然后是2字节的short，最后是字符。</p>
<p>因此，以简单的链表结构体为例：</p>
<pre><code class="language-C">struct foo7 {
    char c;
    struct foo7 *p;
    short x;
};
</code></pre>
<p>将隐含的废液写明，形式如下：</p>
<pre><code class="language-C">struct foo7 {
    char c;         /* 1 byte */
    char pad1[7];   /* 7 bytes */
    struct foo7 *p; /* 8 bytes */
    short x;        /* 2 bytes */
    char pad2[6];   /* 6 bytes */
};
</code></pre>
<p>总共是24字节。如果按长度重排，我们得到：</p>
<pre><code class="language-C">struct foo8 {
    struct foo8 *p;
    short x;
    char c;
};
</code></pre>
<p>考虑到自对齐，我们看到所有数据域之间都不需填充。因为有较严对齐要求（更长）成员的跨步地址对不太严对齐要求的（更短）成员来说，总是合法的对齐地址。重打包过的结构体只需要尾填充：</p>
<pre><code class="language-C">struct foo8 {
    struct foo8 *p; /* 8 bytes */
    short x;        /* 2 bytes */
    char c;         /* 1 byte */
    char pad[5];    /* 5 bytes */
};
</code></pre>
<p>重新打包将空间降为16字节。也许看起来不算很多，但假如这个链表的长度有20万呢？将会积少成多。</p>
<p>注意，重新打包不能确保在所有情况下都能节省空间。将这项技术应用于更靠前<code>struct foo6</code>的那个例子，我们得到：</p>
<pre><code class="language-C">struct foo9 {
    struct foo9_inner {
        char *p;      /* 8 bytes */
        int x;        /* 4 bytes */
    } inner;
    char c;           /* 1 byte */
};
</code></pre>
<p>将填充写明：</p>
<pre><code class="language-C">struct foo9 {
    struct foo9_inner {
        char *p;      /* 8 bytes */
        int x;        /* 4 bytes */
        char pad[4];  /* 4 bytes */
    } inner;
    char c;           /* 1 byte */
    char pad[7];      /* 7 bytes */
};
</code></pre>
<p>结果还是24字节，因为<code>c</code>无法作为内层结构体的尾填充。要想节省空间，你需要得新设计数据结构。</p>
<h1 id="棘手的标量案例">棘手的标量案例</h1>
<p>只有在符号调试器能显示枚举类型的名称而非原始整型数字时，使用枚举来代替<code>#define</code>才是个好办法。然而，尽管枚举必定与某种整型兼容，但Ｃ标准却没有指明究竟是何种底层整型。</p>
<p>请当心，重打包结构体时，枚举型变量通常是int，这与编译器相关；但也可能是short、long、甚至默认为char。编译器可能会有progma预处理指令或命令行选项指定枚举的尺寸。</p>
<p><code>long double</code>是个类似的故障点。有些C平台以80位实现，有些是128位，还有些80位平台将其填充到96或128位。</p>
<p>以上两种情况，最好用<code>sizeof()</code>来检查存储尺寸。</p>
<p>最后，在x86 Linux系统中，double有时会破自对齐规则的例；在结构体内，8字节的double可能只要求4字节对齐，而在结构体外，独立的double变量又是8字节自对齐。这与编译器和选项有关。</p>
<h1 id="可读性与缓存局部性">可读性与缓存局部性</h1>
<p>尽管按尺寸重排是最简单的消除废液的方式，却不一定是正确的方式。还有两个问题需要考量：可读性与缓存局部性。</p>
<p>程序不仅与计算机交流，还与其他人交流。甚至（尤其是！）交流的对象只有将来你自己时，代码可读性依然重要。</p>
<p>笨拙地、机械地重排结构体可能有损可读性。倘若有可能，最好这样重排成员：将语义相关的数据放在一起，形成连贯的组。最理想的情况是，结构体的设计应与程序的设计相通。</p>
<p>当程序频繁访问某一结构体或其一部分时，若能将其放入一个缓存段，对提高性能颇有帮助。缓存段是这样的内存块——当处理器获取内存中的任何单个地址时，会把整块数据都取出来。　在64位x86上，一个缓存段为64字节，它开始于自对齐的地址。其他平台通常为32字节。</p>
<p>为保持可读性所做的工作（将相关和同时访问的数据放在临近位置）也会提高缓存段的局部性。这些都是需要明智地重排，并对数据的存取模式了然于心的原因。</p>
<p>如果代码从多个线程并发访问同一结构体，还存在第三个问题：缓存段弹跳（cache line bouncing）。为了尽量减少昂贵的总线通信，应当这样安排数据——在一个更紧凑的循环里，从一个缓存段中读数据，而向另一个写入数据。</p>
<p>是的，某些时候，这种做法与前文将相关数据放入与缓存段长度相同块的做法矛盾。多线程的确是个难题。缓存段弹跳和其他多线程优化问题是很高级的话题，值得单独为它们写份指导。这里我所能做的，只是让你了解有这些问题存在。</p>
<h1 id="其他打包技术">其他打包技术</h1>
<p>在为结构体瘦身时，重排序与其他技术结合在一起效果最好。例如结构体中有几个布尔标志，可以考虑将其压缩成1位的位域，然后把它们打包放在原本可能成为废液的地方。</p>
<p>你可能会有一点儿存取时间的损失，但只要将工作集合压缩得足够小，那点损失可以靠避免缓存未命中补偿。</p>
<p>更通用的原则是，选择能把数据类型缩短的方法。以cvs-fast-export为例，我使用的一个压缩方法是：利用RCS和CVS在1982年前还不存在这个事实，我弃用了64位的Unix<code>time_t</code>（在1970年开始为零），转而用了一个32位的、从1982-01-01T00:00:00开始的偏移量；这样日期会覆盖到2118年。（注意：若使用这类技巧，要用边界条件检查以防讨厌的Bug！）</p>
<p>这不仅减小了结构体的可见尺寸，还可以消除废液和/或创造额外的机会来进行重新排序。这种良性串连的效果不难被触发。</p>
<p>最冒险的打包方法是使用union。假如你知道结构体中的某些域永远不会跟另一些域共同使用，可以考虑用union共享它们存储空间。不过请特别小心并用回归测试验证。因为如果分析出现一丁点儿错误，就会引发从程序崩溃到微妙数据损坏（这种情况糟得多）间的各种错误。</p>
<h1 id="工具">工具</h1>
<p>clang编译器有个Wpadded选项，可以生成有关对齐和填充的信息。</p>
<p>还有个叫pahole的工具，我自己没用过，但据说口碑很好。该工具与编译器协同工作，生成关于结构体填充、对齐和缓存段边界报告。</p>
<h1 id="证明和例外">证明和例外</h1>
<p>读者可以下载一段程序源代码<a href="http://www.catb.org/esr/structure-packing/packtest.c">packtest.c</a>，验证上文有关标量和结构体尺寸的结论。</p>
<p>如果你仔细检查各种编译器、选项和罕见硬件的稀奇组合，会发现我前面提到的部分规则存在例外。越早期的处理器设计例外越常见。</p>
<p>理解这些规则的第二个层次是，知其何时及如何会被打破。在我学习它们的日子里（1980年代早期），我们把不理解这些规则的人称为“所有机器都是VAX综合症”的牺牲品。记住，世上所有电脑并非都是PC。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[The Lost Art of Structure Packing]]></title>
        <id>https://harriswilde.github.io/post/LUjp1bkYi/</id>
        <link href="https://harriswilde.github.io/post/LUjp1bkYi/">
        </link>
        <updated>2020-02-17T08:02:49.000Z</updated>
        <summary type="html"><![CDATA[<blockquote>
<p>《失传的结构体打包艺术》(英文原版)<br>
作者：Eric S. Raymond<br>
原文链接：<a href="http://www.catb.org/esr/structure-packing/">http://www.catb.org/esr/structure-packing/</a></p>
</blockquote>
]]></summary>
        <content type="html"><![CDATA[<blockquote>
<p>《失传的结构体打包艺术》(英文原版)<br>
作者：Eric S. Raymond<br>
原文链接：<a href="http://www.catb.org/esr/structure-packing/">http://www.catb.org/esr/structure-packing/</a></p>
</blockquote>
<!-- more -->
<h1 id="who-should-read-this">Who should read this</h1>
<p>This page is about a technique for reducing the memory footprint of programs in compiled languages with C-like structures - manually repacking these declarations for reduced size. To read it, you will require basic knowledge of the C programming language.</p>
<p>You need to know this technique if you intend to write code for memory-constrained embedded systems, or operating-system kernels. It is useful if you are working with application data sets so large that your programs routinely hit memory limits. It is good to know in any application where you really, really care about optimizing your use of memory bandwidth and minimizing cache-line misses.</p>
<p>Finally, knowing this technique is a gateway to other esoteric C topics. You are not an advanced C programmer until you have grasped these rules. You are not a master of C until you could have written this document yourself and can criticize it intelligently.</p>
<p>This document originated with &quot;C&quot; in the title, but many of the techniques discussed here also apply to the Go language - and should generalize to any compiled language with C-like structures. There is a note discussing Go and Rust towards the end.</p>
<h1 id="why-i-wrote-it">Why I wrote it</h1>
<p>This webpage exists because in late 2013 I found myself heavily applying an optimization technique that I had learned more than two decades previously and not used much since.</p>
<p>I needed to reduce the memory footprint of a program that used thousands - sometimes hundreds of thousands - of C struct instances. The program was cvs-fast-export and the problem was that it was dying with out-of-memory errors on large repositories.</p>
<p>There are ways to reduce memory usage significantly in situations like this, by rearranging the order of structure members in careful ways. This can lead to dramatic gains - in my case I was able to cut the working-set size by around 40%, enabling the program to handle much larger repositories without dying.</p>
<p>But as I worked, and thought about what I was doing, it began to dawn on me that the technique I was using has been more than half forgotten in these latter days. A little web research confirmed that programmers don’t seem to talk about it much any more, at least not where a search engine can see them. A couple of Wikipedia entries touch the topic, but I found nobody who covered it comprehensively.</p>
<p>There are actually reasons for this that aren’t stupid. CS courses (rightly) steer people away from micro-optimization towards finding better algorithms. The plunging price of machine resources has made squeezing memory usage less necessary. And the way hackers used to learn how to do it back in the day was by bumping their noses on strange hardware architectures - a less common experience now.</p>
<p>But the technique still has value in important situations, and will as long as memory is finite. This document is intended to save programmers from having to rediscover the technique, so they can concentrate effort on more important things.</p>
<h1 id="alignment-requirements">Alignment requirements</h1>
<p>The first thing to understand is that, on modern processors, the way your compiler lays out basic datatypes in memory is constrained in order to make memory accesses faster. Our examples are in C, but any compiled language generates code under the same constraints.</p>
<p>Storage for the basic C datatypes on an x86 or ARM processor doesn’t normally start at arbitrary byte addresses in memory. Rather, each type except char has an alignment requirement; chars can start on any byte address, but 2-byte shorts must start on an even address, 4-byte ints or floats must start on an address divisible by 4, and 8-byte longs or doubles must start on an address divisible by 8. Signed or unsigned makes no difference.</p>
<p>The jargon for this is that basic C types on x86 and ARM are self-aligned. Pointers, whether 32-bit (4-byte) or 64-bit (8-byte) are self-aligned too.</p>
<p>Self-alignment makes access faster because it facilitates generating single-instruction fetches and puts of the typed data. Without alignment constraints, on the other hand, the code might end up having to do two or more accesses spanning machine-word boundaries. Characters are a special case; they’re equally expensive from anywhere they live inside a single machine word. That’s why they don’t have a preferred alignment.</p>
<p>I said &quot;on modern processors&quot; because on some older ones forcing your C program to violate alignment rules (say, by casting an odd address into an int pointer and trying to use it) didn’t just slow your code down, it caused an illegal instruction fault. This was the behavior, for example, on Sun SPARC chips. In fact, with sufficient determination and the right (e18) hardware flag set on the processor, you can still trigger this on x86.</p>
<p>Also, self-alignment is not the only possible rule. Historically, some processors (especially those lacking <a href="https://en.wikipedia.org/wiki/Barrel_shifter">barrel shifters</a>) have had more restrictive ones. If you do embedded systems, you might trip over one of these lurking in the underbrush. Be aware this is possible.</p>
<p>From when it was first written at the beginning of 2014 until late 2016, this section ended with the last paragraph. During that period I’ve learned something rather reassuring from working with the source code for the reference implementation of NTP. It does packet analysis by reading packets off the wire directly into memory that the rest of the code sees as a struct, relying on the assumption of minimal self-aligned padding.</p>
<p>The interesting news is that NTP has apparently being getting away with this for decades across a very wide span of hardware, operating systems, and compilers, including not just Unixes but under Windows variants as well. This suggests that platforms with padding rules other than self-alignment are either nonexistent or confined to such specialized niches that they’re never either NTP servers or clients.</p>
<h1 id="padding">Padding</h1>
<p>Now we’ll look at a simple example of variable layout in memory. Consider the following series of variable declarations in the top level of a C module:</p>
<pre><code class="language-c">char *p;
char c;
int x;
</code></pre>
<p>If you didn’t know anything about data alignment, you might assume that these three variables would occupy a continuous span of bytes in memory. That is, on a 32-bit machine 4 bytes of pointer would be immediately followed by 1 byte of char and that immediately followed by 4 bytes of int. And a 64-bit machine would be different only in that the pointer would be 8 bytes.</p>
<p>In fact, the hidden assumption that the allocated order of static variables is their source order is not necessarily valid; the C standards don’t mandate it. I’m going to ignore this detail because (a) that hidden assumption is usually correct anyway, and (b) the actual purpose of talking about padding and packing outside structures is to prepare you for what happens inside them.</p>
<p>Here’s what actually happens (on an x86 or ARM or anything else with self-aligned types). The storage for p starts on a self-aligned 4- or 8-byte boundary depending on the machine word size. This is pointer alignment - the strictest possible.</p>
<p>The storage for c follows immediately. But the 4-byte alignment requirement of x forces a gap in the layout; it comes out as though there were a fourth intervening variable, like this:</p>
<pre><code class="language-c">char *p;      /* 4 or 8 bytes */
char c;       /* 1 byte */
char pad[3];  /* 3 bytes */
int x;        /* 4 bytes */
</code></pre>
<p>The <code>pad[3]</code> character array represents the fact that there are three bytes of waste space in the structure. The old-school term for this was &quot;slop&quot;. The value of the padding bits is undefined; in particular it is not guaranteed that they will be zeroed.</p>
<p>Compare what happens if <code>x</code> is a 2-byte short:</p>
<pre><code class="language-c">char *p;
char c;
short x;
</code></pre>
<p>In that case, the actual layout will be this:</p>
<pre><code class="language-c">char *p;      /* 4 or 8 bytes */
char c;       /* 1 byte */
char pad[1];  /* 1 byte */
short x;      /* 2 bytes */
</code></pre>
<p>On the other hand, if x is a long on a 64-bit machine</p>
<pre><code class="language-c">char *p;
char c;
long x;
</code></pre>
<p>we end up with this:</p>
<pre><code class="language-c">char *p;     /* 8 bytes */
char c;      /* 1 byte */
char pad[7]; /* 7 bytes */
long x;      /* 8 bytes */
</code></pre>
<p>If you have been following carefully, you are probably now wondering about the case where the shorter variable declaration comes first:</p>
<pre><code class="language-c">char c;
char *p;
int x;
</code></pre>
<p>If the actual memory layout were written like this</p>
<pre><code class="language-c">char c;
char pad1[M];
char *p;
char pad2[N];
int x;
</code></pre>
<p>what can we say about <code>M</code> and <code>N</code>?</p>
<p>First, in this case <code>N</code> will be zero. The address of <code>x</code>, coming right after <code>p</code>, is guaranteed to be pointer-aligned, which is never less strict than int-aligned.</p>
<p>The value of <code>M</code> is less predictable. If the compiler happened to map <code>c</code> to the last byte of a machine word, the next byte (the first of <code>p</code>) would be the first byte of the next one and properly pointer-aligned. M would be zero.</p>
<p>It is more likely that <code>c</code> will be mapped to the <em>first</em> byte of a machine word. In that case M will be whatever padding is needed to ensure that <code>p</code> has pointer alignment - 3 on a 32-bit machine, 7 on a 64-bit machine.</p>
<p>Intermediate cases are possible. M can be anything from 0 to 7 (0 to 3 on 32-bit) because a char can start on any byte boundary in a machine word.</p>
<p>If you wanted to make those variables take up less space, you could get that effect by swapping <code>x</code> with <code>c</code> in the original sequence.</p>
<pre><code class="language-c">char *p;     /* 8 bytes */
long x;      /* 8 bytes */
char c;      /* 1 byte
</code></pre>
<p>Usually, for the small number of scalar variables in your C programs, bumming out the few bytes you can get by changing the order of declaration won’t save you enough to be significant. The technique becomes more interesting when applied to nonscalar variables - especially structs.</p>
<p>Before we get to those, let’s dispose of arrays of scalars. On a platform with self-aligned types, arrays of char/short/int/long/pointer have no internal padding; each member is automatically self-aligned at the end of the next one.</p>
<p>All these rules and examples map over to Go with only syntactic changes.</p>
<p>In the next section we will see that the same is <strong>not</strong> necessarily true of structure arrays.</p>
<h1 id="structure-alignment-and-padding">Structure alignment and padding</h1>
<p>In general, a struct instance will have the alignment of its widest scalar member. Compilers do this as the easiest way to ensure that all the members are self-aligned for fast access.</p>
<p>Also, in C (and Go, and Rust) the address of a struct is the same as the address of its first member - there is no leading padding. Beware: in C++, classes that look like structs may break this rule! (Whether they do or not depends on how base classes and virtual member functions are implemented, and varies by compiler.)</p>
<p>(When you’re in doubt about this sort of thing, ANSI C provides an offsetof() macro which can be used to read out structure member offsets.)</p>
<p>Consider this struct:</p>
<pre><code class="language-c">struct foo1 {
    char *p;
    char c;
    long x;
};
</code></pre>
<p>Assuming a 64-bit machine, any instance of <code>struct foo1</code> will have 8-byte alignment. The memory layout of one of these looks unsurprising, like this:</p>
<pre><code class="language-c">struct foo1 {
    char *p;     /* 8 bytes */
    char c;      /* 1 byte
    char pad[7]; /* 7 bytes */
    long x;      /* 8 bytes */
};
</code></pre>
<p>It's laid out exactly as though variables of these types has been separately declared. But if we put <code>c</code> first, that's no longer true.</p>
<pre><code class="language-c">struct foo2 {
    char c;      /* 1 byte */
    char pad[7]; /* 7 bytes */
    char *p;     /* 8 bytes */
    long x;      /* 8 bytes */
};
</code></pre>
<p>If the members were separate variables, <code>c</code> could start at any byte boundary and the size of <code>pad</code> might vary. Because <code>struct foo2</code> has the pointer alignment of its widest member, that’s no longer possible. Now <code>c</code> has to be pointer-aligned, and following padding of 7 bytes is locked in.</p>
<p>Now let’s talk about trailing padding on structures. To explain this, I need to introduce a basic concept which I’ll call the <em>stride address</em> of a structure. It is the first address following the structure data that has the <strong>same alignment as the structure.</strong></p>
<p>The general rule of trailing structure padding is this: the compiler will behave as though the structure has trailing padding out to its stride address. This rule controls what <code>sizeof()</code> will return.</p>
<p>Consider this example on a 64-bit x86 or ARM machine:</p>
<pre><code class="language-c">struct foo3 {
    char *p;     /* 8 bytes */
    char c;      /* 1 byte */
};

struct foo3 singleton;
struct foo3 quad[4];
</code></pre>
<p>You might think that <code>sizeof(struct foo3)</code> should be 9, but it’s actually 16. The stride address is that of <code>(&amp;p)[2]</code>. Thus, in the <code>quad</code> array, each member has 7 bytes of trailing padding, because the first member of each following struct wants to be self-aligned on an 8-byte boundary. The memory layout is as though the structure had been declared like this:</p>
<pre><code class="language-c">struct foo3 {
    char *p;     /* 8 bytes */
    char c;      /* 1 byte */
    char pad[7];
};
</code></pre>
<p>For contrast, consider the following example:</p>
<pre><code class="language-c">struct foo4 {
    short s;     /* 2 bytes */
    char c;      /* 1 byte */
};
</code></pre>
<p>Because <code>s</code> only needs to be 2-byte aligned, the stride address is just one byte after <code>c</code>, and <code>struct foo4</code> as a whole only needs one byte of trailing padding. It will be laid out like this:</p>
<pre><code class="language-c">struct foo4 {
    short s;     /* 2 bytes */
    char c;      /* 1 byte */
    char pad[1];
};
</code></pre>
<p>and <code>sizeof(struct foo4)</code> will return 4.</p>
<p>Here's a last important detail: If your structure has structure members, the inner structs want to have the alignment of longest scalar too. Suppose you write this:</p>
<pre><code class="language-c">struct foo5 {
    char c;
    struct foo5_inner {
        char *p;
        short x;
    } inner;
};
</code></pre>
<p>The <code>char *p</code> member in the inner struct forces the outer struct to be pointer-aligned as well as the inner. Actual layout will be like this on a 64-bit machine:</p>
<pre><code class="language-c">struct foo5 {
    char c;           /* 1 byte*/
    char pad1[7];     /* 7 bytes */
    struct foo5_inner {
        char *p;      /* 8 bytes */
        short x;      /* 2 bytes */
        char pad2[6]; /* 6 bytes */
    } inner;
};
</code></pre>
<p>This structure gives us a hint of the savings that might be possible from repacking structures. Of 24 bytes, 13 of them are padding. That’s more than 50% waste space!</p>
<h1 id="bitfields">Bitfields</h1>
<p>Now let’s consider C bitfields. What they give you the ability to do is declare structure fields of smaller than character width, down to 1 bit, like this:</p>
<pre><code class="language-c">struct foo6 {
    short s;
    char c;
    int flip:1;
    int nybble:4;
    int septet:7;
};
</code></pre>
<p>The thing to know about bitfields is that they are implemented with word- and byte-level mask and rotate instructions operating on machine words, and cannot cross word boundaries. C99 guarentees that bit-fields will be packed as tightly as possible, provided they don’t cross storage unit boundaries (6.7.2.1 #10).</p>
<p>This restriction is relaxed in C11 (6.7.2.1p11) and C++14 ([class.bit]p1); these revisions do not actually require <code>struct foo9</code> to be 64 bits instead of 32; a bit-field can span multiple allocation units instead of starting a new one. It’s up to the implementation to decide; GCC leaves it up to the ABI, which for x64 does prevent them from sharing an allocation unit.</p>
<p>Assuming we’re on a 32-bit machine, the C99 rules imply that the layout may look like this:</p>
<pre><code class="language-c">struct foo6 {
    short s;       /* 2 bytes */
    char c;        /* 1 byte */
    int flip:1;    /* total 1 bit */
    int nybble:4;  /* total 5 bits */
    int pad1:3;    /* pad to an 8-bit boundary */
    int septet:7;  /* 7 bits */
    int pad2:25;   /* pad to 32 bits */
};
</code></pre>
<p>But this isn’t the only possibility, because the C standard does not specify that bits are allocated low-to-high. So the layout could look like this:</p>
<pre><code class="language-c">struct foo6 {
    short s;       /* 2 bytes */
    char c;        /* 1 byte */
    int pad1:3;    /* pad to an 8-bit boundary */
    int flip:1;    /* total 1 bit */
    int nybble:4;  /* total 5 bits */
    int pad2:25;   /* pad to 32 bits */
    int septet:7;  /* 7 bits */
};
</code></pre>
<p>That is, the padding could precede rather than following the payload bits.</p>
<p>Note also that, as with normal structure padding, the padding bits are not guaranteed to be zero; C99 mentions this.</p>
<p>Note that the base type of a bit field is interpreted for signedness but not necessarily for size. It is up to implementors whether &quot;short flip:1&quot; or &quot;long flip:1&quot; are supported, and whether those base types change the size of the storage unit the field is packed into.</p>
<p>Proceed with caution and check with -Wpadded if you have it available (e.g. under clang). Compilers on exotic hardware might interpret the C99 rules in surprising ways; older compilers might not quite follow them.</p>
<p>The restriction that bitfields cannot cross machine word boundaries means that, while the first two of the following structures pack into one and two 32-bit words as you’d expect, the third (<code>struct foo9</code>) takes up three 32-bit words in C99, in the last of which only one bit is used.</p>
<pre><code class="language-c">struct foo7 {
    int bigfield:31;      /* 32-bit word 1 begins */
    int littlefield:1;
};

struct foo8 {
    int bigfield1:31;     /* 32-bit word 1 begins /*
    int littlefield1:1;
    int bigfield2:31;     /* 32-bit word 2 begins */
    int littlefield2:1;
};

struct foo9 {
    int bigfield1:31;     /* 32-bit word 1 begins */
    int bigfield2:31;     /* 32-bit word 2 begins */
    int littlefield1:1;
    int littlefield2:1;   /* 32-bit word 3 begins */
};
</code></pre>
<p>Again, C11 and C++14 may pack foo9 tighter, but it would perhaps be unwise to count on this.</p>
<p>On the other hand, <code>struct foo8</code> would fit into a single 64-bit word if the machine has those.</p>
<h1 id="structure-reordering">Structure reordering</h1>
<p>Now that you know how and why compilers insert padding in and after your structures we’ll examine what you can do to squeeze out the slop. This is the art of structure packing.</p>
<p>The first thing to notice is that slop only happens in two places. One is where storage bound to a larger data type (with stricter alignment requirements) follows storage bound to a smaller one. The other is where a struct naturally ends before its stride address, requiring padding so the next one will be properly aligned.</p>
<p>The simplest way to eliminate slop is to reorder the structure members by decreasing alignment. That is: make all the pointer-aligned subfields come first, because on a 64-bit machine they will be 8 bytes. Then the 4-byte ints; then the 2-byte shorts; then the character fields.</p>
<p>So, for example, consider this simple linked-list structure:</p>
<pre><code class="language-c">struct foo10 {
    char c;
    struct foo10 *p;
    short x;
};
</code></pre>
<p>With the implied slop made explicit, here it is:</p>
<pre><code class="language-c">struct foo10 {
    char c;          /* 1 byte */
    char pad1[7];    /* 7 bytes */
    struct foo10 *p; /* 8 bytes */
    short x;         /* 2 bytes */
    char pad2[6];    /* 6 bytes */
};
</code></pre>
<p>That’s 24 bytes. If we reorder by size, we get this:</p>
<pre><code class="language-c">struct foo11 {
    struct foo11 *p;
    short x;
    char c;
};
</code></pre>
<p>Considering self-alignment, we see that none of the data fields need padding. This is because the stride address for a (longer) field with stricter alignment is always a validly-aligned start address for a (shorter) field with less strict requirements. All the repacked struct actually requires is trailing padding:</p>
<pre><code class="language-c">struct foo11 {
    struct foo11 *p; /* 8 bytes */
    short x;         /* 2 bytes */
    char c;          /* 1 byte */
    char pad[5];     /* 5 bytes */
};
</code></pre>
<p>Our repack transformation drops the size from 24 to 16 bytes. This might not seem like a lot, but suppose you have a linked list of 200K of these? The savings add up fast - especially on memory-constrained embedded systems or in the core part of an OS kernel that has to stay resident.</p>
<p>Note that reordering is not guaranteed to produce savings. Applying this technique to an earlier example, <code>struct foo5</code>, we get this:</p>
<pre><code class="language-c">struct foo12 {
    struct foo5 {
        char *p;      /* 8 bytes */
        short x;      /* 2 bytes */
    } inner;
    char c;           /* 1 byte*/
};
</code></pre>
<p>With padding written out, this is</p>
<pre><code class="language-c">struct foo12 {
    struct foo5 {
        char *p;      /* 8 bytes */
        short x;      /* 2 bytes */
        char pad[6];  /* 6 bytes */
    } inner;
    char c;           /* 1 byte*/
    char pad[7];      /* 7 bytes */
};
</code></pre>
<p>It’s still 24 bytes because <code>c</code> cannot back into the inner struct’s trailing padding. To collect that gain you would need to redesign your data structures.</p>
<p>Curiously, strictly ordering your structure fields by <em>increasing</em> size also works to mimimize padding. You can minimize padding with any order in which (a) all fields of any one size are in a continuous span (completely eliminating padding between them), and (b) the gaps between those spans are such that the sizes on either side have as few doubling steps of difference from each other as possible. Usually this means no padding at all on one side.</p>
<p>Even more general minimal-padding orders are possible. Example:</p>
<pre><code class="language-c">struct foo13 {
    int32_t i;
    int32_t i2;
    char octet[8];
    int32_t i3;
    int32_t i4;
    int64_t l;
    int32_t i5;
    int32_t i6;
};
</code></pre>
<p>This struct has zero padding under self-alignment rules. Working out why is a useful exercise to develop your understanding.</p>
<p>Since shipping the first version of this guide I have been asked why, if reordering for minimal slop is so simple, C compilers don’t do it automatically. The answer: C is a language originally designed for writing operating systems and other code close to the hardware. Automatic reordering would interfere with a systems programmer’s ability to lay out structures that exactly match the byte and bit-level layout of memory-mapped device control blocks.</p>
<p>Go hews to the C philosophy and does not reorder fields. Rust makes the opposite choice; by default, its compiler may reorder structure fields.</p>
<h1 id="awkward-scalar-cases">Awkward scalar cases</h1>
<p>Using enumerated types instead of #defines is a good idea, if only because symbolic debuggers have those symbols available and can show them rather than raw integers. But, while enums are guaranteed to be compatible with an integral type, the C standard does not specify which underlying integral type is to be used for them.</p>
<p>Be aware when repacking your structs that while enumerated-type variables are usually ints, this is compiler-dependent; they could be shorts, longs, or even chars by default. Your compiler may have a pragma or command-line option to force the size.</p>
<p>The <code>long double</code> type is a similar trouble spot. Some C platforms implement this in 80 bits, some in 128, and some of the 80-bit platforms pad it to 96 or 128 bits.</p>
<p>In both cases it's best to use <code>sizeof()</code> to check the storage size.</p>
<p>Finally, under x86 Linux doubles are sometimes an exception to the self-alignment rule; an 8-byte double may require only 4-byte alignment within a struct even though standalone doubles variables have 8-byte self-alignment. This depends on compiler and options.</p>
<h1 id="readability-and-cache-locality">Readability and cache locality</h1>
<p>While reordering by size is the simplest way to eliminate slop, it’s not necessarily the right thing. There are two more issues: readability and cache locality.</p>
<p>Programs are not just communications to a computer, they are communications to other human beings. Code readability is important even (or especially!) when the audience of the communication is only your future self.</p>
<p>A clumsy, mechanical reordering of your structure can harm readability. When possible, it is better to reorder fields so they remain in coherent groups with semantically related pieces of data kept close together. Ideally, the design of your structure should communicate the design of your program.</p>
<p>When your program frequently accesses a structure, or parts of a structure, it is helpful for performance if the accesses tend to fit within a cache line - the memory block fetched by your processor when it is told to get any single address within the block. On 64-bit x86 a cache line is 64 bytes beginning on a self-aligned address; on other platforms it is often 32 bytes.</p>
<p>The things you should do to preserve readability - grouping related and co-accessed data in adjacent fields - also improve cache-line locality. These are both reasons to reorder intelligently, with awareness of your code’s data-access patterns.</p>
<p>If your code does concurrent access to a structure from multiple threads, there’s a third issue: cache line bouncing. To minimize expensive bus traffic, you should arrange your data so that reads come from one cache line and writes go to another in your tighter loops.</p>
<p>And yes, this sometimes contradicts the previous guidance about grouping related data in the same cache-line-sized block. Multithreading is hard. Cache-line bouncing and other multithread optimization issues are very advanced topics which deserve an entire tutorial of their own. The best I can do here is make you aware that these issues exist.</p>
<h1 id="other-packing-techniques">Other packing techniques</h1>
<p>Reordering works best when combined with other techniques for slimming your structures. If you have several boolean flags in a struct, for example, consider reducing them to 1-bit bitfields and packing them into a place in the structure that would otherwise be slop.</p>
<p>You’ll take a small access-time penalty for this - but if it squeezes the working set enough smaller, that penalty will be swamped by your gains from avoided cache misses.</p>
<p>More generally, look for ways to shorten data field sizes. In cvs-fast-export, for example, one squeeze I applied was to use the knowledge that RCS and CVS repositories didn't exist before 1982. I dropped a 64-bit Unix <code>time_t</code> (zero date at the beginning of 1970) for a 32-bit time offset from 1982-01-01T00:00:00; this will cover dates to 2118. (Note: if you pull a trick like this, do a bounds check whenever you set the field to prevent nasty bugs!)</p>
<p>Each such field shortening not only decreases the explicit size of your structure, it may remove slop and/or create additional opportunities for gains from field reordering. Virtuous cascades of such effects are not very hard to trigger.</p>
<p>The riskiest form of packing is to use unions. If you know that certain fields in your structure are never used in combination with certain other fields, consider using a union to make them share storage. But be extra careful and verify your work with regression testing, because if your lifetime analysis is even slightly wrong you will get bugs ranging from crashes to (much worse) subtle data corruption.</p>
<h1 id="overriding-alignment-rules">Overriding alignment rules</h1>
<p>Sometimes you can coerce your compiler into not using the processor’s normal alignment rules by using a pragma, usually <code>#pragma pack</code>. GCC and clang have a &quot;packed&quot; attribute you can attach to individual structure declarations; GCC has an -fpack-struct option for entire compilations.</p>
<p>Do not do this casually, as it forces the generation of more expensive and slower code. Usually you can save as much memory, or almost as much, with the techniques I describe here.</p>
<p>The only good reason for <code>#pragma pack</code> is if you have to exactly match your C data layout to some kind of bit-level hardware or protocol requirement, like a memory-mapped hardware port, and violating normal alignment is required for that to work. If you’re in that situation, and you don’t already know everything else I’m writing about here, you’re in deep trouble and I wish you luck.</p>
<h1 id="tools">Tools</h1>
<p>The clang compiler has a -Wpadded option that causes it to generate messages about alignment holes and padding. Some versions also have an undocumented -fdump-record-layouts option that yields <a href="http://lists.cs.uiuc.edu/pipermail/cfe-dev/2014-July/037778.html">more information</a>.</p>
<p>If you're using C11, you can deploy static_assert to check your assumptions about type and structure sizes. Example:</p>
<pre><code class="language-c">#include &lt;assert.h&gt;
struct foo4 {
    short s;     /* 2 bytes */
    char c;      /* 1 byte */
};
static_assert(sizeof(struct foo4) == 4, &quot;Check your assumptions&quot;);
</code></pre>
<p>I have not used it myself, but several respondents speak well of a program called pahole. This tool cooperates with a compiler to produce reports on your structures that describe padding, alignment, and cache line boundaries. This was at one time a standalone C program, but that is now unmaintained; s script with the name pahole now ships with gdb and that is what you should use.</p>
<p>I’ve received a report that a proprietary code auditing tool called &quot;PVS Studio&quot; can detect structure-packing opportunities.</p>
<h1 id="proof-and-exceptional-cases">Proof and exceptional cases</h1>
<p>You can download sourcecode for a little program that demonstrates the assertions about scalar and structure sizes made above. It is <a href="http://www.catb.org/esr/structure-packing/packtest.c">packtest.c</a>.</p>
<p>If you look through enough strange combinations of compilers, options, and unusual hardware, you will find exceptions to some of the rules I have described. They get more common as you go back in time to older processor designs.</p>
<p>The next level beyond knowing these rules is knowing how and when to expect that they will be broken. In the years when I learned them (the early 1980s) we spoke of people who didn’t get this as victims of &quot;all-the-world’s-a-VAX syndrome&quot;. Remember that not all the world is a PC.</p>
<h1 id="go-and-rust">Go and Rust</h1>
<p>The Go language is in many respects similar to C. It has structures and arrays, though not bitfields or unions. Go compilers have the same optimization and alignment issues as C compilers. One important difference is that the Go specification <strong>requires</strong> structure fields to be self-aligned. As in C, array elements are padded up to the following stride address.</p>
<p>Therefore, if you know the implications of self-aligment in C, you can apply them directly to calculating sizes and offsets in Go and to space-optimizing Go structures. The obvious correspondence mostly works.</p>
<p>I say &quot;mostly&quot; because Go has one odd quirk. Since Go 1.5, a zero-length field at the end of a struct (that is, a zero-length array or empty struct) is sized and aligned as though it is one byte. The reasons for this are discussed in an essay <a href="https://dave.cheney.net/2015/10/09/padding-is-hard">Padding is Hard</a> by one of the Go developers.</p>
<p>Rust follows C-like field alignment rules if a structure is annotated with &quot;repr(C)&quot;. Otherwise (by default) all bets are off: padding rules are (deliberately) unspecified and the compiler may even reorder structure members. It is probably best to let the Rust compiler do space optimization rather than forcing it.</p>
<h1 id="supporting-this-work">Supporting this work</h1>
<p>If you were educated or entertained by this document, please sign up for my <a href="https://www.patreon.com/esr">Patreon feed</a>. The time needed to write and maintain documents like this one is not free, and while I enjoying giving them to the world my bills won’t pay themselves. Even a few dollars a month - from enough of you - helps a lot.</p>
<h1 id="related-reading">Related Reading</h1>
<p>This section exists to collect pointers to essays which I judge to be good companions to this one.</p>
<p><a href="http://blog.regehr.org/archives/213">A Guide to Undefined Behavior in C and C++</a></p>
<p><a href="http://www.catb.org/esr/time-programming/">Time, Clock, and Calendar Programming In C</a></p>
<p><a href="http://www.catb.org/esr/faqs/things-every-hacker-once-knew/">Things Every Hacker Once Knew</a></p>
<h1 id="version-history">Version history</h1>
<p>2.2 @ 2019-12-19 Minor markup fix.</p>
<p>2.1 @ 2019-02-14 Correct a minor error in one of the examples pointed out by Luis Emilio Moreno Durán.</p>
<p>2.0 @ 2018-08-06 Drop &quot;C&quot; out of the title as these techniques are applicable to Go and Rust as well. More coverage of Go and Rust. The pahole tool has been replaced by a script in the gdb distribution.</p>
<p>1.19 @ 2018-02-12 Describe usefulness of static_assert() in C11. Added Go and Rust coverage.</p>
<p>1.18 @ 2017-06-01 More general zero-padding orders. C11 and C14 relax a constraint on bitfield packing.</p>
<p>1.17 @ 2016-11-14 Typo fixes.</p>
<p>1.16 @ 2016-10-21 Answer an objection about allocation order being unrelated to source order.</p>
<p>1.15 @ 2016-10-20 Note the field evidence from NTP.</p>
<p>1.14 @ 2015-12-19 Typo correction: -Wpadding → -Wpadded.</p>
<p>1.13 @ 2015-11-23 Be explicit about padding bits being undefined. More about bitfields.</p>
<p>1.12 @ 2015-11-11 Major revision of section on bitfields reflecting C99 rules.</p>
<p>1.11 @ 2015-07-23 Mention the clang -fdump-record-layouts option.</p>
<p>1.10 @ 2015-02-20 Mention attributepacked, -fpack-struct, and PVS Studio.</p>
<p>1.9 @ 2014-10-01 Added link to &quot;Time, Clock, and Calendar Programming In C&quot;.</p>
<p>1.8 @ 2014-05-20 Improved explanation for the bitfield examples,</p>
<p>1.7 @ 2014-05-17 Correct a minor error in the description of the layout of struct foo8.</p>
<p>1.6 @ 2014-05-14 Emphasize that bitfields cannot cross word boundaries. Idea from Dale Gulledge.</p>
<p>1.5 @ 2014-01-13 Explain why structure member reordering is not done automatically.</p>
<p>1.4 @ 2014-01-04 A note about double under x86 Linux.</p>
<p>1.3 @ 2014-01-03 New sections on awkward scalar cases, readability and cache locality, and tools.</p>
<p>1.2 @ 2014-01-02 Correct an erroneous address calculation.</p>
<p>1.1 @ 2014-01-01Explain why aligned accesses are faster. Mention offsetof. Various minor fixes, including the packtest.c download link.</p>
<p>1.0 @ 2014-01-01 Initial release.</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[排序算法：插入排序和希尔排序]]></title>
        <id>https://harriswilde.github.io/post/nTjkYzZnf/</id>
        <link href="https://harriswilde.github.io/post/nTjkYzZnf/">
        </link>
        <updated>2020-02-14T08:57:50.000Z</updated>
        <content type="html"><![CDATA[<h1 id="插入排序">插入排序</h1>
<p>疫情期间，大家都闲坏了吧？应该没少打扑克牌吧。设想一下，你从牌堆中摸牌的时候，大概率是乱序的。那么你是怎么样把乱序的牌整理成有序的呢？</p>
<p>首先你会假定第一张牌是有序的，然后把后面的牌不断地插到前面的有序牌里的合适位置，最后，牌就从无序的变成有序的了。</p>
<p>那么，插入排序也是一样的道理，看下面动画，<strong>蓝色的代表乱序，绿色代表有序，橙色的代表正在比较</strong>。</p>
<figure data-type="image" tabindex="1"><img src="https://s2.ax1x.com/2020/02/14/1XmBB4.gif" alt="插入排序" loading="lazy"></figure>
<p>代码实现如下：</p>
<pre><code class="language-c">//C
void sort(int arr[])
{
    for (int i = 1; i &lt; sizeof(arr)/sizeof(arr[0]); i++)
    {
        int value = arr[i];
        for (j = i - 1; j &gt;= 0; j--)
        {
            if (arr[j] &gt; value)
            {
                arr[j+1] = arr[j]; //移动数据
            }
            else
            {
                break;
            }
        }
        arr[j+1] = value; //插入数据
    }
}
</code></pre>
<pre><code class="language-java">//Java
public static void sort(int[] arr) {
    int n = arr.length;
    for (int i = 1; i &lt; n; ++i) {
        int value = arr[i];
        int j = 0;//插入的位置
        for (j = i-1; j &gt;= 0; j--) {
            if (arr[j] &gt; value) {
                arr[j+1] = arr[j];//移动数据
            } else {
                break;
            }
        }
        arr[j+1] = value; //插入数据
    }
}
</code></pre>
<pre><code class="language-python">#Python
def sort(arr):
    for i in range(1, len(arr)):
        value = arr[i]
        for j in range(0, i-1, -1):
            if arr[j] &gt; value:
                arr[j+1] = arr[j];
            else:
                break
        arr[j+1] = value
</code></pre>
<p>插入排序是<strong>稳定排序</strong>。</p>
<p>这种算法感觉比冒泡什么的快一些（实际上时间复杂度为<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>O</mi><mrow><mo>(</mo><msup><mi>n</mi><mn>2</mn></msup><mo>)</mo></mrow></msub></mrow><annotation encoding="application/x-tex">O_{(n^2)}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.03853em;vertical-align:-0.3551999999999999em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.34480000000000005em;"><span style="top:-2.5198em;margin-left:-0.02778em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mopen mtight">(</span><span class="mord mtight"><span class="mord mathdefault mtight">n</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.7463142857142857em;"><span style="top:-2.786em;margin-right:0.07142857142857144em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mclose mtight">)</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.3551999999999999em;"><span></span></span></span></span></span></span></span></span></span>，但受数据影响较大），但是如果数据量很大的话，那么这样挨个比较的话，效率就非常低了。</p>
<p>因此，人们就想出一个办法：使用二分法来查找。</p>
<p>也就是说，当后面的数据想要插入前面的有序数列的时候，不是挨个挨个比较，而是直接和有序数列的中间值进行比较，假设大于中间值，就和中间值到末尾的一段的数列的中间值进行比较，一直持续下去直到找到正确的位置。这样在理想情况下可以节省很多时间。</p>
<p>但是在数据分布比较散的情况下，有时候还是需要移动很多位。那么这种情况下，人们就开始着手改进插入排序，其中希尔改进的插入排序最为出名，也就是<strong>希尔排序</strong>。</p>
<h1 id="希尔排序">希尔排序</h1>
<p>希尔排序改进了插入排序的缺点，可以实现元素的跳跃移动。</p>
<figure data-type="image" tabindex="2"><img src="https://s2.ax1x.com/2020/02/14/1jcQdU.gif" alt="希尔排序" loading="lazy"></figure>
<p>希尔排序又叫做<strong>缩小增量排序</strong>，图中的<strong>Gap</strong>就是增量的意思。所谓增量，可以理解为一个跨度。插入排序中广为诟病的依次移动，当加上了跨度之后就可以实现跳跃移动。而每一轮排完之后跨度都会减小，直到跨度为1，就完成了排序。实际上，跨度为1的时候就是普通的插入排序。只不过经过了前面的洗礼之后，数据已经基本变得有序了，最后一轮的插入只是很简单地完善一下而已。</p>
<p>代码实现如下：</p>
<pre><code class="language-c">void shellSort( long int array[], int length)
{
    int i;
    int j;
    int k;
    int gap;    //gap是分组的步长
    long int temp;   //希尔排序是在直接插入排序的基础上实现的,所以仍然需要哨兵
    for(gap=length/2; gap&gt;0; gap=gap/2)
    {
        //以GAP为间隔分组
        for(i=0; i&lt;gap; i++)
        {
            /*
             每一组做插入排序
             */
            for(j=i+gap; j&lt;length; j=j+gap)
            {
                //如果当前元素比这一组中的前一个元素要小
                if(array[j] &lt; array[j - gap])
                {
                    //记录当前这个更小的元素 temp
                    temp = array[j];    //哨兵
                    k = j - gap;
                    //把这一组中之前所有比temp小的元素都往后挪一个位置
                    while(k&gt;=0 &amp;&amp; array[k]&gt;temp)
                    {
                        array[k + gap] = array[k];
                        k = k - gap;
                    }
                    //把挪出来的空位，放入temp
                    array[k + gap] = temp;
                }
            }
        }
    }
}
</code></pre>
<pre><code class="language-java">//Java
public static void shell_sort(int[] arr) {
    int length = arr.length;
    //区间
    int gap = 1;
    while (gap &lt; length) {
        gap = gap * 3 + 1;
    }
    while (gap &gt; 0) {
        for (int i = gap; i &lt; length; i++) {
            int tmp = arr[i];
            int j = i - gap;
            //跨区间排序
            while (j &gt;= 0 &amp;&amp; arr[j] &gt; tmp) {
                arr[j + gap] = arr[j];
                j -= gap;
            }
            arr[j + gap] = tmp;
        }
        gap = gap / 3;
    }
}
</code></pre>
<pre><code class="language-python">#Python
def shell_sort(arr):
	gap = len(arr)//3 + 1
	while gap &gt; 0:
		for i in range(gap):
			for j in range(i + gap, len(arr), gap):
				if arr[j] &lt; arr[j - gap]:
					temp = arr[j]
					k = j - gap
					while k &gt;= 0 and arr[k] &gt; temp:
						arr[k + gap] = arr[k]
						k -= gap
					arr[k + gap] = temp
		if gap == 1:
			break
		gap = gap//3 + 1
</code></pre>
<p>至于这个增量gap到底该取多少，目前没有定论。最初shell提出取<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>g</mi><mi>a</mi><mi>p</mi><mo>=</mo><mfrac><mi>n</mi><mn>2</mn></mfrac></mrow><annotation encoding="application/x-tex">gap=\frac{n}{2}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="mord mathdefault">a</span><span class="mord mathdefault">p</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1.040392em;vertical-align:-0.345em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.695392em;"><span style="top:-2.6550000000000002em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">2</span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.394em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">n</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.345em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span>向下取整，<code>gap /= 2</code>向下取整，直到<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>g</mi><mi>a</mi><mi>p</mi><mo>=</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">gap=1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="mord mathdefault">a</span><span class="mord mathdefault">p</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span>。但由于直到最后一步，在奇数位置的元素才会与偶数位置的元素进行比较，这样使用这个序列的效率会很低。后来Knuth提出取<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>g</mi><mi>a</mi><mi>p</mi><mo>=</mo><mi>n</mi><mo>∣</mo><mn>3</mn><mo>+</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">gap = n\mid 3 +1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="mord mathdefault">a</span><span class="mord mathdefault">p</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">n</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">∣</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.72777em;vertical-align:-0.08333em;"></span><span class="mord">3</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span>还有人提出都取奇数为好，也有人提出gap互质为好。应用不同的序列会使希尔排序算法的性能有很大的差异。</p>
<p>最后，希尔排序是一个不稳定排序，时间复杂度为<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>O</mi><mrow><mo>(</mo><msup><mi>n</mi><mn>1.3</mn></msup><mo>)</mo></mrow></msub></mrow><annotation encoding="application/x-tex">O_{(n^{1.3})}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.03853em;vertical-align:-0.3551999999999999em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.34480000000000005em;"><span style="top:-2.5198em;margin-left:-0.02778em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mopen mtight">(</span><span class="mord mtight"><span class="mord mathdefault mtight">n</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.7463142857142857em;"><span style="top:-2.786em;margin-right:0.07142857142857144em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight"><span class="mord mtight">1</span><span class="mord mtight">.</span><span class="mord mtight">3</span></span></span></span></span></span></span></span></span><span class="mclose mtight">)</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.3551999999999999em;"><span></span></span></span></span></span></span></span></span></span>。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[排序算法：选择排序]]></title>
        <id>https://harriswilde.github.io/post/FojWe45tS/</id>
        <link href="https://harriswilde.github.io/post/FojWe45tS/">
        </link>
        <updated>2020-02-13T08:02:58.000Z</updated>
        <content type="html"><![CDATA[<p>所谓选择排序，就是每次将剩余区间内最大（或者最小）的数放在最右边（或者最左边），从而达到排序的算法。之所以叫做<strong>选择排序</strong>，是因为每一次都选出剩下的最大或者最小值来达到排序。</p>
<p>看动画：</p>
<img src="https://s2.ax1x.com/2020/02/13/1L9TK0.gif" alt="选择排序" style="zoom:67%;" />
<p>如图，每次将最大的放在右边，遍历完成之后就是一个有序数列了。</p>
<p>代码实现如下：</p>
<pre><code class="language-c">//C
#include &lt;stdio.h&gt;
void sort(int arr[])
{
    for (int i = sizeof(arr)/sizeof(arr[0]) - 1; i &gt;= 0; i--)
    {
        for(int j = 0; j &lt; i; j++)
        {
            int temp = 0;
            if (arr[j] &gt; arr[i])
            {
                temp = arr[j];
                arr[j] = arr[i];
                arr[i] = temp;
            }
        }
    }
}

</code></pre>
<pre><code class="language-java">//Java
public class SelectionSort implements IArraySort {

    @Override
    public int[] sort(int[] sourceArray) throws Exception {
        int[] arr = Arrays.copyOf(sourceArray, sourceArray.length);

        // 总共要经过 N-1 轮比较
        for (int i = 0; i &lt; arr.length - 1; i++) {
            int min = i;

            // 每轮需要比较的次数 N-i
            for (int j = i + 1; j &lt; arr.length; j++) {
                if (arr[j] &lt; arr[min]) {
                    // 记录目前能找到的最小值元素的下标
                    min = j;
                }
            }

            // 将找到的最小值和i位置所在的值进行交换
            if (i != min) {
                int tmp = arr[i];
                arr[i] = arr[min];
                arr[min] = tmp;
            }

        }
        return arr;
    }
}
</code></pre>
<pre><code class="language-python">#Python
def sort(arr):
    for i in range(0, len(arr), -1):
        for j in range(0, i):
            if arr[j] &gt; arr[i]:
                arr[j], arr[i] = arr[i], arr[j]
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[排序算法：冒泡排序及其优化]]></title>
        <id>https://harriswilde.github.io/post/wi0begzME/</id>
        <link href="https://harriswilde.github.io/post/wi0begzME/">
        </link>
        <updated>2020-02-13T04:21:33.000Z</updated>
        <content type="html"><![CDATA[<h1 id="冒泡排序">冒泡排序</h1>
<p>冒泡排序属于几种排序算法里面的最简单的一种，不需要什么高深的思维，就可以很快理解。</p>
<p>冒泡排序实际上就是把相邻的数相互比较，把大的放右边（或者左边，这取决于你想顺序排还是倒序排）。如果把大的放右边，那么第一轮遍历之后，就会把这组数据中最大的放到最后边。</p>
<p>此时，最后一个已经是固定的了，依次把前面的按照这样的套路排序下去就行了。</p>
<p>下面这个动画可能会更直观地帮助你理解：</p>
<img src="https://s2.ax1x.com/2020/02/13/1qJg2R.gif" alt="冒泡排序" style="zoom:67%;" />
<p>代码实现如下：</p>
<p>C:</p>
<pre><code class="language-c">#include &lt;stdio.h&gt;
void sort(int arr[])
{
    for (int i = 0; i &lt; sizeof(arr)/sizeof(arr[0]) - 1; i++)
    {
        for(int j = 0; j &lt; sizeof(arr)/sizeof(arr[0]) - 1 - i; j++)
        {
            int temp = 0;
            if (arr[j] &gt; arr[j + 1])
            {
                temp = arr[j];
                arr[j] = arr[j + 1];
                arr[j + 1] = temp;
            }
        }
    }
}
</code></pre>
<p>Java:</p>
<pre><code class="language-java">public static void sort(int arr[]){
    for( int i = 0 ; i &lt; arr.length - 1 ; i++ ){
        for(int j = 0;j &lt; arr.length - 1 - i ; j++){
            int temp = 0;
            if(arr[j] &gt; arr[j + 1]){
                temp = arr[j];
                arr[j] = arr[j + 1];
                arr[j + 1] = temp;
            }
        }
    }
}
</code></pre>
<p>Python:</p>
<pre><code class="language-python">def sort(arr):
    for i in range(len(arr)):
        for j in range(len(arr) - i):
            if arr[j] &gt; arr[j + 1]:
                arr[j], arr[j + 1] = arr[j + 1], arr[j]
</code></pre>
<p>我们看到双层循环，就不难推出这个算法的时间复杂度为<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>O</mi><mrow><mo>(</mo><msup><mi>n</mi><mn>2</mn></msup><mo>)</mo></mrow></msub></mrow><annotation encoding="application/x-tex">O_{(n^2)}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.03853em;vertical-align:-0.3551999999999999em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.34480000000000005em;"><span style="top:-2.5198em;margin-left:-0.02778em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mopen mtight">(</span><span class="mord mtight"><span class="mord mathdefault mtight">n</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.7463142857142857em;"><span style="top:-2.786em;margin-right:0.07142857142857144em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mclose mtight">)</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.3551999999999999em;"><span></span></span></span></span></span></span></span></span></span>，且为稳定排序。</p>
<p>其实通过我们上面的动图发现，当排到第4轮的时候，实际上整个列表就已经是有序的了，那么接下来的几轮，就是在浪费时间和资源。那么既然如此，有没有优化的方案呢？</p>
<p>当然是有的。</p>
<h1 id="冒泡排序优化版鸡尾酒排序">冒泡排序优化版：鸡尾酒排序</h1>
<p>我们所设想的，应该是这样：</p>
<img src="https://s2.ax1x.com/2020/02/17/3iGzhd.gif" alt="鸡尾酒排序" style="zoom:67%;" />
<p>这个思路也很好实现。只需要设一个变量用来做标记，当某一次遍历的时候，一个元素都没有替换，那么就可以视为已经有序，后面的遍历就全省了。</p>
<p>代码实现如下：</p>
<p>C:</p>
<pre><code class="language-c">#include &lt;stdio.h&gt;
void swap(int a[], b, c)//设置交换数据的函数
{
    int temp = 0;
    if (b &lt; c)
    {
        if (a[b] &gt; a[c])
        {
            temp = a[b];
            a[b] = a[c];
            a[c] = temp;
        }
    }
}

void cocatailSort(int a[])
{
    int length = sizeof(a)/sizeof(a[0]);
    int flag1 = 1, flag2 = 1;
    for (int i = 0, i &lt; length / 2, i++)
    {
        flag1 = 1;
        flag2 = 1;
        for(int j=i;j&lt;length-i-1;j++)
        {
            if(array[j] &gt; array[j+1]) { 
            swap(array, j, j+1) ; 
            flag1 = false ; //若已交换则更改变量
        }
        for(int j=length-i-1;j&gt;i;j--)
        { 
            if(array[j] &lt; array[j-1])
            { 
                 swap(array, j-1, j) ; 
                 flag2 = false ; //若已交换则更改变量
            } 
        } 
        if(flag1 &amp;&amp; flag2)
        { //来回一趟都没有交换则跳出
            break ; 
        }
}
</code></pre>
<p>Java:</p>
<pre><code class="language-java">public static void swap(int[] a, int b, int c) { //交换数据的函数
    int temp = 0 ; 
    if(b &lt; c) { 
      if(a[b] &gt; a[c]) { 
        temp = a[b] ; 
        a[b] = a[c] ; 
        a[c] = temp ;  
      } 
    } 
  } 

public static void cocatailSortFlag(int[] array) { 
    int length = array.length ; 
    boolean flag1,flag2 = true ; 
    //来回循环length/2次 
    for(int i=0;i&lt;length/2;i++) { 
      flag1 = true ; //初始化标记变量
      flag2 = true ; 
      for(int j=i;j&lt;length-i-1;j++) { 
        if(array[j] &gt; array[j+1]) { 
          swap(array, j, j+1) ; 
          flag1 = false ; //若已交换则更改变量
        } 
      } 
      for(int j=length-i-1;j&gt;i;j--) { 
        if(array[j] &lt; array[j-1]) { 
          swap(array, j-1, j) ; 
          flag2 = false ; //若已交换则更改变量
        } 
      } 
      if(flag1 &amp;&amp; flag2) { //来回一趟都没有交换则跳出
        break ; 
      } 
    } 
  } 
</code></pre>
<p>Python:</p>
<pre><code class="language-python">def sort(arr):
    flag1, flag2 = True
    #来回循环len/2次
    for i in range(len(arr) - 2):
        flag1, flag2 = True
        for j in range(i, len(arr) - i - 1):
            if arr[j] &gt; arr[j+1]:
                arr[j], arr[j+1] = arr[j+1], arr[j]
                flag1 = False
        for j in range(len(arr) - i - 1, i, -1):
            if arr[j] &lt; arr[j+1]:
                arr[j], arr[j+1] = arr[j+1], arr[j]
                flag2 = False
        if flag1 and flag2:
            break
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Python序列、列表及其方法]]></title>
        <id>https://harriswilde.github.io/post/NEar5wUsO/</id>
        <link href="https://harriswilde.github.io/post/NEar5wUsO/">
        </link>
        <updated>2020-02-11T13:40:02.000Z</updated>
        <content type="html"><![CDATA[<p>在上一节里面我们讲到了变量。但是，生活中也并不是哪里的数据都适合使用变量来存储。比如，一些成堆出现的数据。那么，本节就要引入一个新的概念：<strong>数据结构</strong>。</p>
<p>所谓数据结构，实际上就是通过某种方式（比如给元素编号），组织在一起的数据集合。在Python中，最基本的数据结构就是<strong>序列(sequence)</strong>。序列中的每一个元素都被分配一个序号，也就是元素的位置，称之为<strong>索引</strong>。但是，Python的索引是<strong>从0开始</strong>，而不是我们习惯的从1开始。</p>
<p>Python包括6中内建序列：列表(list)，元组(tuple)，字符串(string)，Unicode字符串(Unicode string)，buffer对象和xrange对象。本节只讨论<strong>列表</strong>和<strong>元组</strong>。</p>
<p>另外，序列中的元素也可以是一个序列，如：</p>
<pre><code class="language-python">&gt;&gt;&gt; edward = ['Edward Gumby', 42]
&gt;&gt;&gt; john = ['John Smith', 50]
&gt;&gt;&gt; database = [edward, john]
&gt;&gt;&gt; database
[['Edward Gumby', 42], ['John Smith', 50]]
</code></pre>
<h1 id="通用序列操作">通用序列操作</h1>
<p>所有下序列类型都可以进行某些特定的操作。包括<strong>索引(indexing)</strong>，<strong>分片(slicing)</strong>，<strong>加(adding)</strong>，<strong>乘(multiplying)</strong>，<strong>成员资格</strong>以及<strong>迭代(iteration，本节不讲)</strong>。除此之外，Python还有计算序列长度，找出最大最小元素等内建函数。</p>
<h2 id="索引">索引</h2>
<p>通过元素的编号来访问元素(<strong>从0开始，谨记！</strong>)：</p>
<pre><code class="language-python">&gt;&gt;&gt; name = 'TechZone'
&gt;&gt;&gt; name[0]
'T'
&gt;&gt;&gt; name[5]
'o'
</code></pre>
<p>由于是从0开始，于是索引0对应的就是第一个元素，索引6就是第五个元素。</p>
<p>当然，如果你不希望把这个序列赋值给一个变量，也可以直接进行操作：</p>
<pre><code class="language-python">&gt;&gt;&gt; 'TechZone'[5]
'o'
</code></pre>
<p>亦或许，你想把序列中某一个元素赋值给一个变量，也是可以的：</p>
<pre><code class="language-python">&gt;&gt;&gt; letter = 'TechZone'[5]
&gt;&gt;&gt; letter
'o'
</code></pre>
<p>如果这个序列很长，也可以倒着数：</p>
<pre><code class="language-python">&gt;&gt;&gt; 'Hello'[-1] #代表从结尾开始数的第一个
'o'
</code></pre>
<h2 id="分片">分片</h2>
<p>和索引一样，分片是用来访问一段元素的。比如我想一次性访问序列的第3到第6个元素：</p>
<pre><code class="language-python">&gt;&gt;&gt; name = 'TechZone'
&gt;&gt;&gt; name[2:6]
'chZo'
</code></pre>
<p>需要注意的是，起始元素（冒号左边）是包含在内的，而终止元素（冒号右边）是不包含在内的。因此<code>name[2:6]</code>实际上等价于<code>name[2] + name[3] + name[4] + name[5]</code> 。</p>
<p>如果我们要访问最后的三个元素怎么办呢？</p>
<p>当然可以使用常规的方法：</p>
<pre><code class="language-python">&gt;&gt;&gt; name[5:8]
'one'
</code></pre>
<p>如果我们要从结尾开始访问呢？</p>
<pre><code class="language-python">&gt;&gt;&gt; name[-3:-1]
'on'
</code></pre>
<p>由于终止元素不包含在分片里面，于是后面我们就访问不到。</p>
<p>改改试试：</p>
<pre><code class="language-python">&gt;&gt;&gt; name[-3:0]
''
</code></pre>
<p>什么都没有返回！为什么会这样呢？</p>
<p>因为<code>[0]</code>其实比<code>[-3]</code>更先出现。那么起始元素比终止元素还大，从数学的角度来说，就是<strong>空集</strong>了。</p>
<p>难道真的没有办法这样访问吗？</p>
<p>并不是，看看这样：</p>
<pre><code class="language-python">&gt;&gt;&gt; name[-3:]
'one'
</code></pre>
<p>把终止元素的位置留空，那么Python就会自动认为你要一直访问到最后元素，于是就把这个问题巧妙解决了。</p>
<p>当然，这个方法也可以这么用：</p>
<pre><code class="language-python">&gt;&gt;&gt; name[:3]
'Tec'
&gt;&gt;&gt; name[:]
'TechZone'
</code></pre>
<p>很好理解吧。</p>
<h2 id="分片的步长">分片的步长</h2>
<p>其实分片还有一个参数，我们刚刚并没有用，就是步长。步长的默认设置为1，意思就是挨个访问。比如：</p>
<pre><code class="language-python">&gt;&gt;&gt; name[1:4]
'ech'
</code></pre>
<p>实际上等价于：</p>
<pre><code class="language-python">&gt;&gt;&gt; name[1:4:1]
'ech'
</code></pre>
<p>如果步长改成2：</p>
<pre><code class="language-python">&gt;&gt;&gt; name[1:4:2]
'eh'
</code></pre>
<p>你会发现检索的单位变成了2（也就是说，中间会跳过一个元素）</p>
<p>也许这么看，就好理解了：</p>
<pre><code class="language-python">&gt;&gt;&gt; nums = [1,2,3,4,5,6,7,8,9,10]
&gt;&gt;&gt; nums[::1]
[1, 2, 3, 4, 5, 6, 7, 8, 9, 10]
&gt;&gt;&gt; nums[::2]
[1, 3, 5, 7, 9]
&gt;&gt;&gt; nums[::3]
[1, 4, 7, 10]
&gt;&gt;&gt; nums[::4]
[1, 5, 9]
</code></pre>
<p>当然，步长不能够为0，但是可以为负数（倒过来检索）：</p>
<pre><code class="language-python">&gt;&gt;&gt; nums[::-1]
[10, 9, 8, 7, 6, 5, 4, 3, 2, 1]
&gt;&gt;&gt; nums[::-2]
[10, 8, 6, 4, 2]
&gt;&gt;&gt; nums[::-3]
[10, 7, 4, 1]
&gt;&gt;&gt; nums[::-4]
[10, 6, 2]
</code></pre>
<h2 id="序列运算">序列运算</h2>
<h3 id="相加">相加</h3>
<pre><code class="language-python">&gt;&gt;&gt; [1,2,3]+[4,5,6]
[1, 2, 3, 4, 5, 6]
&gt;&gt;&gt; 'TechZone'+'Harris'
'TechZoneHarris'
&gt;&gt;&gt; [1,2,3]+'Harris'
'''
Traceback (most recent call last):
  File &quot;&lt;pyshell#35&gt;&quot;, line 1, in &lt;module&gt;
    [1,2,3]+'Harris'
TypeError: can only concatenate list (not &quot;str&quot;) to list
'''
</code></pre>
<p>相同类型的序列相加，实际上就是拼接起来。但是不同类型的序列是不能够相加的。</p>
<h3 id="乘法">乘法</h3>
<pre><code class="language-python">&gt;&gt;&gt; 'Harris' * 5
'HarrisHarrisHarrisHarrisHarris'
&gt;&gt;&gt; [1,2] * 10
[1, 2, 1, 2, 1, 2, 1, 2, 1, 2, 1, 2, 1, 2, 1, 2, 1, 2, 1, 2]
</code></pre>
<p>也很好理解。</p>
<h2 id="初始化">初始化</h2>
<p>如果我想创建一个列表，作为占位符（暂时不用，但是以后要用的），那么可以用一对方括号<code>[]</code>来表示。如果想创建一个拥有10个元素的列表占位符，那么该怎么办呢？</p>
<p>我们可以使用一些对于你来说没有意义的字符，比如0：</p>
<pre><code class="language-python">&gt;&gt;&gt; space = [0] * 10
&gt;&gt;&gt; space
[0, 0, 0, 0, 0, 0, 0, 0, 0, 0]
</code></pre>
<p>不过这样的作法其实并不是十分稳妥，因为没准你找不出来这样的特殊的数字。那么这里介绍一个Python内建值：<code>None</code>，表示什么都没有。那么我们的占位符就可以这样创建：</p>
<pre><code class="language-python">&gt;&gt;&gt; space = [None] * 10
&gt;&gt;&gt; space
[None, None, None, None, None, None, None, None, None, None]
</code></pre>
<h2 id="成员资格">成员资格</h2>
<p>判断一个值是否在序列中，我们可以使用<code>in</code>运算符。这种运算符不同于加减乘除，它会去检查我们的条件是否为真，若是，则返回<code>True</code>，反之则返回<code>False</code>。这样的运算符我们叫做<strong>布尔运算符</strong>，返回的这个值称之为<strong>布尔值</strong>。</p>
<pre><code class="language-python">&gt;&gt;&gt; user = ['Harris', 'Mary','Scott']
&gt;&gt;&gt; 'Harris' in user
True
&gt;&gt;&gt; 'Jack' in user
False
</code></pre>
<h2 id="长度-最值">长度、最值</h2>
<pre><code class="language-python">&gt;&gt;&gt; name = 'HarrisWilde'
&gt;&gt;&gt; len(name) #序列长度
11
&gt;&gt;&gt; len([1,2,3,4])
4
&gt;&gt;&gt; max([1,3,2,13,6,5,8]) #最大值
13
&gt;&gt;&gt; min([0.01, 0.02, 0.009, 0.015]) #最小值
0.009
</code></pre>
<h1 id="列表">列表</h1>
<p>使用<code>[]</code>括起来的序列集合就是列表。</p>
<h2 id="list函数">list函数</h2>
<p>使用<code>list</code>函数来将序列转换为列表。</p>
<pre><code class="language-python">&gt;&gt;&gt; list(&quot;TechZone&quot;)
['T', 'e', 'c', 'h', 'Z', 'o', 'n', 'e']
</code></pre>
<p>你还可以使用<code>join</code>函数来把序列中所有的元素(的字符串表示)合并为一个新的字符串：</p>
<pre><code class="language-python">&gt;&gt;&gt; seq = list(&quot;TechZone&quot;)
&gt;&gt;&gt; '-'.join(seq)
'T-e-c-h-Z-o-n-e'
</code></pre>
<h2 id="基本列表操作">基本列表操作</h2>
<h3 id="元素赋值">元素赋值</h3>
<p>为单个元素赋值：</p>
<pre><code class="language-python">&gt;&gt;&gt; x = [0] * 3
&gt;&gt;&gt; x[1] = 1
&gt;&gt;&gt; x
[0, 1, 0]
</code></pre>
<h3 id="删除元素">删除元素</h3>
<p>使用<code>del</code>函数：</p>
<pre><code class="language-python">&gt;&gt;&gt; x
[0, 1, 0]
&gt;&gt;&gt; del x[2]
&gt;&gt;&gt; x
[0, 1]
</code></pre>
<h3 id="分片赋值">分片赋值</h3>
<p>分片赋值可以实现一次性的批量赋值：</p>
<pre><code class="language-python">&gt;&gt;&gt; x = list(&quot;python&quot;)
&gt;&gt;&gt; x
['p', 'y', 't', 'h', 'o', 'n']
&gt;&gt;&gt; x[4:] = '12'
&gt;&gt;&gt; x
['p', 'y', 't', 'h', '1', '2']
</code></pre>
<p>而且还可以非等长替换：</p>
<pre><code class="language-python">&gt;&gt;&gt; x
['p', 'y', 't', 'h', '1', '2']
&gt;&gt;&gt; x[4:] = 'Lang'
&gt;&gt;&gt; x
['p', 'y', 't', 'h', 'L', 'a', 'n', 'g']
</code></pre>
<p>因此，也可以间接地增加或删除元素：</p>
<pre><code class="language-python">&gt;&gt;&gt; x[8:8] = '12' #在最后的不存在的位置增加
&gt;&gt;&gt; x
['p', 'y', 't', 'h', 'L', 'a', 'n', 'g', '1', '2']
&gt;&gt;&gt; x[4:8] = []
&gt;&gt;&gt; x
['p', 'y', 't', 'h', '1', '2']
</code></pre>
<h2 id="列表方法">列表方法</h2>
<h3 id="append">append</h3>
<p>此方法用于在列表后面追加元素：</p>
<pre><code class="language-python">&gt;&gt;&gt; nums = [1,2,3]
&gt;&gt;&gt; nums.append(4)
&gt;&gt;&gt; nums
[1, 2, 3, 4]
</code></pre>
<h3 id="count">count</h3>
<p>此方法统计某个元素在列表中出现的次数：</p>
<pre><code class="language-python">&gt;&gt;&gt; name = 'TechZone'
&gt;&gt;&gt; name.count('e')
2
</code></pre>
<h3 id="extend">extend</h3>
<p>此方法可以在末尾一次性追加多个值，并且更改原来的列表：</p>
<pre><code class="language-python">&gt;&gt;&gt; a = [1,2,3]
&gt;&gt;&gt; b = [4,5,6]
&gt;&gt;&gt; a.extend(b)
&gt;&gt;&gt; a
[1, 2, 3, 4, 5, 6]
&gt;&gt;&gt; b
[4, 5, 6]
</code></pre>
<h3 id="index">index</h3>
<p>此方法用于找出列表中某个值的第一个匹配元素的索引，若找不到则会返回错误：</p>
<pre><code class="language-python">&gt;&gt;&gt; name = 'TechZone'
&gt;&gt;&gt; name.index('e')
1
&gt;&gt;&gt; name.index('a')
'''
Traceback (most recent call last):
  File &quot;&lt;pyshell#13&gt;&quot;, line 1, in &lt;module&gt;
    name.index('a')
ValueError: substring not found
'''
</code></pre>
<h3 id="insert">insert</h3>
<p>此方法用于将对象插入到列表中：</p>
<pre><code class="language-python">&gt;&gt;&gt; nums = [1,2,3,5]
&gt;&gt;&gt; nums.insert(3, 'four')
&gt;&gt;&gt; nums
[1, 2, 3, 'four', 5]
</code></pre>
<h3 id="pop">pop</h3>
<p>此方法用于移除列表中的最后一个元素，并且返回被移除元素的值：</p>
<pre><code class="language-python">&gt;&gt;&gt; nums = [1,2,3,4]
&gt;&gt;&gt; nums.pop()
4
&gt;&gt;&gt; nums
[1, 2, 3]
</code></pre>
<blockquote>
<p>pop方法是唯一一个既能修改列表又能返回元素值（除了None）的列表方法</p>
</blockquote>
<h3 id="remove">remove</h3>
<p>remove方法用于移除列表中的某个值的首个匹配项：</p>
<pre><code class="language-python">&gt;&gt;&gt; words = ['a','friend','in','need','is','a','friend','indeed']
&gt;&gt;&gt; words.remove('friend')
&gt;&gt;&gt; words
['a', 'in', 'need', 'is', 'a', 'friend', 'indeed']
</code></pre>
<blockquote>
<p>remove是一个没有返回值的原位置改变方法。和pop恰恰相反。</p>
</blockquote>
<h3 id="reverse">reverse</h3>
<p>此方法将列表中的元素反向存放。</p>
<pre><code class="language-python">&gt;&gt;&gt; x = [1,2,3]
&gt;&gt;&gt; x.reverse()
&gt;&gt;&gt; x
[3, 2, 1]
</code></pre>
<p>此方法也是不返回值，和remove一样。</p>
<blockquote>
<p>如果需要对一个序列进行反向迭代，那么可以使用<code>reversed</code>函数。这个函数返回的是迭代器对象(iterator)。当然，使用<code>list</code>函数把返回的对象转换成列表也是可行的：</p>
<pre><code class="language-python">&gt;&gt;&gt; x = [1,2,3]
&gt;&gt;&gt; list(reversed(x))
[3, 2, 1]
</code></pre>
</blockquote>
<h3 id="sort">sort</h3>
<p>此方法用于对列表进行原地排序。所谓原地排序，就是更改原来的列表，而不是返回一个已排序的副本。</p>
<pre><code class="language-python">&gt;&gt;&gt; x = [4,5,3,6,2,5,1]
&gt;&gt;&gt; x.sort()
&gt;&gt;&gt; x
[1, 2, 3, 4, 5, 5, 6]
</code></pre>
<p>如果你想得到的恰恰是一个副本，想保留原来的列表，千万不要这么做：</p>
<pre><code class="language-python">&gt;&gt;&gt; x = [4,5,3,6,2,5,1]
&gt;&gt;&gt; y = x.sort() #错误的做法
&gt;&gt;&gt; print(y)
None
</code></pre>
<p>因为<code>sort</code>函数是不返回值的（实际上返回的是空值）。如果要实现这个功能，那么只能把原先x的副本赋给y，然后对y进行排序：</p>
<pre><code class="language-python">&gt;&gt;&gt; x = [4,5,3,6,2,5,1]
&gt;&gt;&gt; y = x
&gt;&gt;&gt; y.sort()
&gt;&gt;&gt; y
[1, 2, 3, 4, 5, 5, 6]
&gt;&gt;&gt; x
[1, 2, 3, 4, 5, 5, 6]
</code></pre>
<p>你会发现，为何原来的x也被改变了呢？</p>
<p>原来，简单的等号赋值，会让x和y指向同一个对象。那么，我们使用分片的方法来赋值，就可以巧妙地躲开这个问题：</p>
<pre><code class="language-python">&gt;&gt;&gt; x = [4,5,3,6,2,5,1]
&gt;&gt;&gt; y = x[:]
&gt;&gt;&gt; y.sort()
&gt;&gt;&gt; y
[1, 2, 3, 4, 5, 5, 6]
&gt;&gt;&gt; x
[4, 5, 3, 6, 2, 5, 1]
</code></pre>
<p>另外，还可以使用<code>sorted</code>函数来获取已排序副本：</p>
<pre><code class="language-python">&gt;&gt;&gt; x = [4,5,3,6,2,5,1]
&gt;&gt;&gt; y = sorted(x)
&gt;&gt;&gt; y
[1, 2, 3, 4, 5, 5, 6]
&gt;&gt;&gt; x
[4, 5, 3, 6, 2, 5, 1]
</code></pre>
<p><code>sorted</code>函数可以用于任何序列，但是总会返回一个列表：</p>
<pre><code class="language-python">&gt;&gt;&gt; sorted(&quot;TechZone&quot;)
['T', 'Z', 'c', 'e', 'e', 'h', 'n', 'o']
</code></pre>
<p>此函数默认是升序排序，如果我想降序，怎么办呢？</p>
<p>可以先排好序之后再反转，不过，有个更简便的方法：使用reverse参数。</p>
<pre><code class="language-python">&gt;&gt;&gt; x = [4,5,3,6,2,5,1]
&gt;&gt;&gt; x.sort(reverse = False) #默认情况，就是不写参数的情况
&gt;&gt;&gt; x
[1, 2, 3, 4, 5, 5, 6]
&gt;&gt;&gt; x.sort(reverse = True) #应用reverse参数
&gt;&gt;&gt; x
[6, 5, 5, 4, 3, 2, 1]
</code></pre>
<p>当然，此函数还可以进行更高级的排序，就是使用<code>key</code>参数。所谓key，笔者认为就是<strong>排序参考关键词</strong>。默认是按照值的大小（若是字符串则比较其对应编码的大小），使用此参数，就可以实现别的参考值。</p>
<p>比如我想根据字符串长度来排序：</p>
<pre><code class="language-python">&gt;&gt;&gt; string = ['TechZone','HarrisWIlde','Python','Programing']
&gt;&gt;&gt; string.sort(key=len)
&gt;&gt;&gt; string
['Python', 'TechZone', 'Programing', 'HarrisWIlde']
</code></pre>
<p>当然，两个参数也可以一起用：</p>
<pre><code class="language-python">&gt;&gt;&gt; string = ['TechZone','HarrisWIlde','Python','Programing']
&gt;&gt;&gt; string.sort(key=len, reverse=True)
&gt;&gt;&gt; string
['HarrisWIlde', 'Programing', 'TechZone', 'Python']
</code></pre>
<p>这两个参数对于<code>sorted()</code>都有效。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[C语言之函数（下）]]></title>
        <id>https://harriswilde.github.io/post/PS9G6tbW5/</id>
        <link href="https://harriswilde.github.io/post/PS9G6tbW5/">
        </link>
        <updated>2020-02-09T12:46:54.000Z</updated>
        <content type="html"><![CDATA[<h1 id="动态内存管理">动态内存管理</h1>
<p>我们知道，我们之前定义的变量、数组，都是我们事先定义好的，变量一旦被创建，就不能够再更改了。后来，C99标准又增加了变长数组，这一特性提高了我们程序对内存分配的灵活度，可是还是感觉不太灵活。那么有没有办法让它变得更灵活呢？</p>
<p>当然有，而且只需要几个库的函数就能够搞定。而这些库全部都包含在<code>stdlib.h</code>这个头文件中：</p>
<ul>
<li>malloc ——申请动态内存空间</li>
<li>free ——释放动态内存空间</li>
<li>calloc ——申请并初始化一系列内存空间</li>
<li>realloc ——重新分配内存空间</li>
</ul>
<h2 id="malloc">malloc</h2>
<p><code>malloc</code>函数用于申请动态内存空间：</p>
<pre><code class="language-c">#include &lt;stdlib.h&gt;
void* malloc(size_t size);
</code></pre>
<p><code>malloc</code>函数向系统申请分配<code>size</code>个字节的内存空间，并返回一个指向这块空间的指针。不过，申请的这块空间并没有被初始化，因此上面的数据是随机的（和局部变量一样）。</p>
<p>如果函数调用成功，那么会返回一个指向被申请的内存空间的指针，由于返回的是void类型的指针，所以它可以被转化成任何类型的数据。如果函数调用失败，返回值就是<code>NULL</code>。另外，如果<code>size</code>参数设置成0，那么返回值也有可能是0，但这种情况下并不一定代表调用失败。</p>
<pre><code class="language-c">//Exmple 01
#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;

int main(void)
{
    int* ptr;
    ptr = (int*)malloc(sizeof(int));
    if (ptr == NULL)
    {
        printf(&quot;分配内存失败！\n&quot;);
        exit(1);//程序异常退出
    }
    printf(&quot;请输入一个整数：&quot;);
    scanf(&quot;%d&quot;, ptr);
    printf(&quot;你输入的数据是：%d\n&quot;, *ptr);
    return 0;
}
</code></pre>
<p>运行结果为：</p>
<pre><code>请输入一个整数：12
你输入的数据是：12
</code></pre>
<p>这段代码的意思是，使用<code>malloc</code>函数申请一块int类型的空间，然后使用<code>ptr</code>指针来指向它，然后将用户输入的数据存储在这块空间里面。</p>
<p>不过，<code>malloc</code>函数申请的空间是在堆上，那么这就意味这它不会自动释放，直到程序执行结束。所以在使用完变量之后务必释放内存，否则很有可能造成内存泄漏。</p>
<h2 id="free">free</h2>
<p>释放动态内存空间需要用<code>free</code>函数，函数原型：</p>
<pre><code class="language-c">#include &lt;stdlib.h&gt;
...
void free(void* ptr);
</code></pre>
<p>释放的空间必须要是<code>malloc</code> <code>calloc</code> <code>realloc</code>函数申请的，否则将会导致未定义行为。如果<code>ptr</code>的参数是<code>NULL</code>，那么就不执行任何操作。</p>
<p>这个函数实际上并不会修改<code>ptr</code>参数的值，所以调用后它仍然能够指向原来的地方，只不过变为非法空间罢了。</p>
<p>有人会说了，现代计算机内存都不小，动辄16GB甚至更多，那么这个是否就用不上了呢？</p>
<p>答案当然是否定的。不信你试试下面的这个程序：</p>
<pre><code class="language-c">//Infinity malloc
#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;

int main(void)
{
    while (1)
    {
        malloc(1024);
    }
    return 0;
}
</code></pre>
<p>你会发现内存占用会飙升。这种情况就叫做<strong>内存泄漏</strong>。我们申请的空间，在使用完后应该要立即释放，不然很有可能会造成不堪设想的后果。</p>
<pre><code class="language-c">//Exmple 01 - Edited
#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;

int main(void)
{
    int* ptr;
    ptr = (int*)malloc(sizeof(int));
    if (ptr == NULL)
    {
        printf(&quot;分配内存失败！\n&quot;);
        exit(1);//程序异常退出
    }
    printf(&quot;请输入一个整数：&quot;);
    scanf(&quot;%d&quot;, ptr);
    printf(&quot;你输入的数据是：%d\n&quot;, *ptr);
    ////释放内存////
    free(ptr);
    return 0;
}
</code></pre>
<p>因此，在使用完申请的内存之后应该要手动释放。</p>
<p>我们再来看一个例子：</p>
<pre><code class="language-c">//Example 02
#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;

int main(void)
{
    int* ptr;
    int num = 123;
    ptr = (int*)malloc(sizeof(int));
    if (ptr == NULL)
    {
        printf(&quot;分配内存失败！\n&quot;);
        exit(1);
    }
    printf(&quot;请输入一个整数：&quot;);
    scanf(&quot;%d&quot;, ptr);
    printf(&quot;你输入的整数是：%d\n&quot;, *ptr);
    ptr = &amp;num;
    printf(&quot;你输入的整数是：%d\n&quot;, *ptr);
    free(ptr);
    return 0;
}
</code></pre>
<p>结果如下：</p>
<pre><code>请输入一个整数：10
你输入的整数是：10
你输入的整数是：123
HEAP[ConsoleApplication2.exe]: Invalid address specified to RtlValidateHeap( 00D20000, 0096F8E0 )
ConsoleApplication2.exe 已触发了一个断点。
</code></pre>
<p>程序被中断了。</p>
<p>刚开始，我们使用<code>malloc</code>函数申请了一段内存，并且只有<code>ptr</code>才知道这块内存的地址。所以后面我们更改了<code>ptr</code>后，这块内存就泄露了。后面我们尝试释放<code>ptr</code>，却发现，现在<code>ptr</code>所指向的变量是一个局部变量，不允许手动释放。这种情况的泄露一定要特别注意。</p>
<h2 id="申请任意尺寸的内存空间">申请任意尺寸的内存空间</h2>
<p><code>malloc</code>还可以用于申请一块任意尺寸的内存空间。对于后者，由于申请的空间是连续的，所以经常用数组的方式来进行索引。</p>
<p>还记得在<a href="http://www.techzone.ltd/post/CArray/">《C语言之数组》</a>里我们讲过，Visual Studio和C99之前的编译器是不支持可变长数组的。如果恰好碰到这种环境，怎么办呢？刚好可以用这种方式来曲线救国：</p>
<pre><code class="language-c">//Example 03
#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
 int main(void)
 {
     int* array;
     int n;
     printf(&quot;请输入你要创建的数组元素个数：&quot;);
     scanf(&quot;%d&quot;, &amp;n);
     array = (int*)malloc(sizeof(int) * n);
     for (int i = 0; i &lt; n; i++)
     {
         array[i] = i;
         printf(&quot;%d\n&quot;, array[i]);
     }
     return 0;
 }
</code></pre>
<p>运行结果如下：</p>
<pre><code>//Consequence 03
请输入你要创建的数组元素个数：10
0
1
2
3
4
5
6
7
8
9
</code></pre>
<p>多维数组也一样可以（本质上也是线性存储）：</p>
<pre><code class="language-c">//Example 04
#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;

int main(void)
{
    int** array;
    int n, m;
    scanf(&quot;%d %d&quot;, &amp;n, &amp;m);//n为几个大的数组，m是一个小数组中有几个元素
    array = (int**)malloc(sizeof(int*) * n);//分配行数
    for (int i = 0; i &lt; n; i++)
    {
        array[i] = (int*)malloc(sizeof(int) * m);//分配各个元素
    }
    for (int i = 0; i &lt; n; i++)
    {
        for (int j = 0; j &lt; m; j++)
        {
            array[i][j] = j;
            printf(&quot;%d &quot;, array[i][j]);
        }
        printf(&quot;\n&quot;);
    }
    return 0;
}
</code></pre>
<p>运行结果为：</p>
<pre><code>//Consequence 04
3 4
0 1 2 3
0 1 2 3
0 1 2 3
</code></pre>
<p>由于<code>malloc</code>不会初始化申请的内存空间，所以需要字节进行初始化。当然可以写一个循环，像我们刚刚那样，不过还是略显繁琐。</p>
<p>好在，标准库提供了更加高效的函数，包含在<code>string.h</code>头文件中：</p>
<ul>
<li>memset: 使用一个常量字节填充内存空间</li>
<li>memcpy: 复制内存空间</li>
<li>memmove: 移动内存空间</li>
<li>memcmp: 比较内存空间</li>
<li>memchr: 在内存空间中搜索一个字符</li>
</ul>
<p>函数原型如下：</p>
<pre><code class="language-c">#include &lt;string.h&gt;
void* memset(void* s, int c, size_t n);
void* memcpy(void* dest, const void* src, size_t n);
void* memmove(void* dest, const void* src, size_t n);
int memcmp(const void* s1, const void* s2, size_t n);
void* memchr(const void* s, int c, size_t n);
</code></pre>
<p>使用<code>memset</code>函数初始化空间：</p>
<pre><code class="language-c">//Example 05
#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;string.h&gt;

#define N 10

int main(void)
{
    int* ptr = NULL;
    ptr = (int*)malloc(N * sizeof(int));
    if (ptr == NULL)
    {
        exit(1);
    }
    memset(ptr, 0, N * sizeof(int));
    for (int i = 0; i &lt; N; i++)
    {
        printf(&quot;%d &quot;, ptr[i]);
    }
    putchar('\n');
    free(ptr);
    return 0;
}
</code></pre>
<p>运行结果为：</p>
<pre><code>//Consequence 05
0 0 0 0 0 0 0 0 0 0
</code></pre>
<p>如果觉得这样太麻烦，那么我们就可以使用<code>calloc</code>来一步到位。</p>
<h2 id="calloc">calloc</h2>
<p><code>calloc</code>函数用于申请并初始化一系列内存空间：</p>
<pre><code class="language-c">#include &lt;stdlib.h&gt;
...
void* calloc(size_t nmemb, size_t size);
</code></pre>
<p><code>calloc</code>函数在内存中动态地申请nmemb个长度为size的连续内存空间（即申请的总空间尺寸为<code>nmemb*size</code>），这些内存空间全部被初始化成0。</p>
<p>如果函数调用成功，会返回一个指向申请的内存空间的指针，由于返回类型是void指针，因此可以被转换成任何类型的数据。如果函数调用失败，返回值是<code>NULL</code>。如果<code>nmemb</code>或<code>size</code>参数设置为0，返回值也可能是<code>NULL</code>，但这不一定意味着函数调用失败。</p>
<h2 id="realloc">realloc</h2>
<p>有时候可能需要对原来分配的空间进行拓展，但是没办法确保两次申请的空间是线性连续的。所以需要先申请一个足够大的空间，再把数据搬运过去。</p>
<p>当然，这样确实可以，但是手动写代码的话感觉有些太繁琐了。使用<code>realloc</code>函数就可以帮我们完成这一系列的操作：</p>
<pre><code class="language-c">#include &lt;stdlib.h&gt;
...
void* realloc(void* ptr, size_t size);
</code></pre>
<p>以下几点是需要注意的：</p>
<ul>
<li><code>realloc</code>函数将<code>ptr</code>指向的内存空间大小修改为<code>size</code>字节</li>
<li>如果重新分配的内存比原来的大，则旧数据不会发生改变；若比原来小，数据有可能会丢失，慎用！</li>
<li>该函数会移动内存空间并返回新的指针</li>
<li>如果<code>ptr</code>的参数是<code>NULL</code>，那么调用该函数就相当于调用<code>malloc(size)</code></li>
<li>如果<code>size</code>的参数为0，并且<code>ptr</code>的参数不为<code>NULL</code>，那么调用该函数就相当于调用<code>free(ptr)</code></li>
<li>除非<code>ptr</code>的参数为<code>NULL</code>，否则<code>ptr</code>的值必须由先前调用的<code>malloc</code> <code>calloc</code> <code>realloc</code>函数返回</li>
</ul>
<p>下面这个程序，不断接受用户输入整数，直到用户输入-1结束，然后将所有的数据输出：</p>
<pre><code class="language-c">//Example 06
#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;

int main(void)
{
    int num;
    int count = 0;
    int* ptr = NULL;//这里必须初始化为NULL
    do
    {
        printf(&quot;请输入一个整数（输入-1表示结束：）&quot;);
        scanf(&quot;%d&quot;, &amp;num);
        count++;
        ptr = (int*)realloc(ptr, count * sizeof(int));
        if (ptr == NULL)
        {
            exit(1);
        }
        ptr[count - 1] = num;
    } while (num != -1);
    printf(&quot;输入的整数分别是：&quot;);
    for (int i = 0; i &lt; count - 1; i++)
    {
        printf(&quot;%d &quot;, ptr[i]);
    }
    printf(&quot;\n&quot;);
    free(ptr);
    return 0;
}
</code></pre>
<p>运行结果为：</p>
<pre><code>//Consequence 06
请输入一个整数（输入-1表示结束：）5
请输入一个整数（输入-1表示结束：）23
请输入一个整数（输入-1表示结束：）4
请输入一个整数（输入-1表示结束：）51
请输入一个整数（输入-1表示结束：）22
请输入一个整数（输入-1表示结束：）31
请输入一个整数（输入-1表示结束：）1
请输入一个整数（输入-1表示结束：）9
请输入一个整数（输入-1表示结束：）-1
输入的整数分别是：5 23 4 51 22 31 1 9
</code></pre>
<h1 id="c语言的内存布局">C语言的内存布局</h1>
<img src="https://s2.ax1x.com/2020/02/09/1hG8D1.png" alt="C语言的内存布局" style="zoom:33%;" />
<p>根据内存由低到高分别做如下划分：</p>
<ul>
<li>代码段(text segment)</li>
<li>数据段(initialized data segment)</li>
<li>BSS段(BSS segment / Uninitialized data segment)</li>
<li>栈(stack)</li>
<li>堆(heap)</li>
</ul>
<h2 id="代码段">代码段</h2>
<p>代码段通常用来存放程序执行代码的一块内存区域。这部分区域的大小再程序运行前就已经确定，并且内存区域通常值属于只读。在代码段中，也有可能包含一些只读的常数变量，如字符串常量等等。</p>
<h2 id="数据段">数据段</h2>
<p>数据段通常用来存放已经初始化的全局变量和局部静态变量。</p>
<h2 id="bss段">BSS段</h2>
<p>BSS段通常用来存放程序中为初始化的全局变量的一块内存区域。BSS是英文Black Started by Symbol的简称。这个区段中的数据在程序运行前将被自动初始化为0。</p>
<h2 id="堆">堆</h2>
<p>前面学习的动态内存管理，实际上就是在这里面进行的。堆里面主要放一些动态的内存段，能够扩展和缩小。</p>
<h2 id="栈">栈</h2>
<p>大家平时所听到的<strong>堆栈</strong>这个词，实际上就是指的栈。栈是函数执行的内存区域，通常和堆共享同一片区域。堆和栈是C语言运行时的重要元素之一。而它们之间也有很大的不同；<strong>堆</strong>由程序员手动申请，而<strong>栈</strong>由系统自动分配；<strong>堆</strong>由程序员手动释放，而<strong>栈</strong>由系统自动释放；<strong>堆</strong>的生存周期由程序员来决定，并且不同函数之间<strong>可以</strong>自由访问，而<strong>栈</strong>的生存周期由函数调用开始到函数返回时结束，函数之间的局部变量<strong>不可以</strong>互相访问。</p>
<h1 id="高级宏定义">高级宏定义</h1>
<p>作为C语言的三大预处理命令之一，宏定义的作用时替换。但是，宏定义就算再复杂，也只是替换不做任何的计算或者表达式求解。</p>
<h2 id="不带参数的宏定义">不带参数的宏定义</h2>
<p>这种就是我们常见的直接替换：</p>
<pre><code class="language-c">#define PI 3.14
</code></pre>
<blockquote>
<p>注意：</p>
<ul>
<li>为了和普通变量区分，宏的名字一般约定为全大写</li>
<li>宏定义只是简单的替换，且是在编译前就处理好了，所以编译器不会对宏定义的语法进行检查</li>
<li>宏定义的作用范围是从定义开始到程序的结束</li>
<li>可以使用#undef命令中止宏定义的作用域</li>
<li>宏定义允许嵌套(在宏定义中使用已定义的宏)</li>
</ul>
</blockquote>
<h2 id="带参数的宏定义">带参数的宏定义</h2>
<p>C语言的宏定义可以带参数。和函数类似，在宏定义里出现的叫做<strong>形参</strong>，而在调用的时候实际传递的叫做 <strong>实参</strong>。</p>
<p>如：</p>
<pre><code class="language-c">#define MAX(x, y) (((x) &gt; (y)) ? (x) : (y))
</code></pre>
<p>这个就是用来比较x和y哪个更大：</p>
<pre><code class="language-c">//Example 07
#include &lt;stdio.h&gt;
#define MAX(x, y) (((x) &gt; (y)) ? (x) : (y))

int main(void)
{
    int x, y;
    printf(&quot;请输入两个整数：&quot;)；
    scanf(&quot;%d %d&quot;, &amp;x, &amp;y);
    printf(&quot;%d更大！&quot;, MAX(x, y));
    return 0;
}
</code></pre>
<p>运行结果如下：</p>
<pre><code>//Consequence 08
请输入两个整数：3 5
5更大！
</code></pre>
<p>另外，参数的最外层建议加上一个小括号来确保优先级，不然很可能会出现隐式的bug。</p>
<h1 id="内联函数">内联函数</h1>
<p>由于预编译命令在编译之前就已经处理好了。而函数每次的调用却还要申请栈空间。的确，使用含参宏定义效率确实要更高。</p>
<p>不过，有的时候却会出现一些bug，比如：</p>
<pre><code class="language-c">//Example 09
#define SQUARE(x) ((x) * (x))
#include &lt;stdio.h&gt;

int main(void)
{
    int i = 1;
    while (i &lt;= 10)
    {
        printf(&quot;%d的平方根是%d\n&quot;, i-1, SQUARE(i++));
    }
    return 0;
}
</code></pre>
<p>结果为：</p>
<pre><code>//Consequence 09
2的平方根是1
4的平方根是9
6的平方根是25
8的平方根是49
10的平方根是81
</code></pre>
<p>这是怎么回事呢？</p>
<p>我们刚刚说过，宏定义只是简单的替换。那么<code>SQUARE(i++)</code>最终会被替换为<code>((i++) * (i++))</code>，那么没调用一次宏，就要自增两次。</p>
<p>那么我又想用宏定义，却又向避开这个bug，怎么办呢？</p>
<p>就是调用内联函数：</p>
<pre><code class="language-c">inline int square(int);
</code></pre>
<p>和普通的函数定义一样，只不过在前面加上<code>inline</code>即可。指定一个函数为内联函数，那么系统就会像处理宏定义那样，将整个函数直接在<code>main</code>函数中展开。</p>
<p>不过，内联函数也不是万能的。虽然节省了运行的时间，但是每个地方都要进行替换，实际上也增加了编译的时间。再者，其实现在的编译器也很聪明，对内联函数也有一套像寄存器变量那样的优化机制，并不是所有你声明的内联函数都能够成为内联函数，而有些普通函数也有可能会成为内联函数。</p>
<h1 id="一些小技巧">一些小技巧</h1>
<h2 id="和">#和##</h2>
<p>在含参宏定义中，#运算符后面应该跟一个参数，预处理器会把这个参数转换成一个字符串：</p>
<pre><code class="language-c">//Example 10
#define STR(s) # s
#include &lt;stdio.h&gt;

int main(void)
{
    printf(&quot;%s\n&quot;, STR(TechZone));
    return 0;
}
</code></pre>
<p>结果为：</p>
<pre><code>//Consequence 10
TechZone
</code></pre>
<p>虽然笔者传入的不是字符串形式，但是<code>#</code>将其变为了字符串，因此可以直接以<code>%s</code>的形式输出。</p>
<p>并且传入字符中，所有的保留字符都会做转义处理，比如<code>\</code>会被替换为<code>\\</code>。存在多个空白字符的时候，会被替换为一个空格。</p>
<p>而##运算符被成为连接运算符，如：</p>
<pre><code class="language-c">//Example 11
#define TOGETHER(x, y) x ## y
#include &lt;stdio.h&gt;
int main(void)
{
    printf(&quot;%d\n&quot;, TOGETHER(5, 20));
    return 0;
}
</code></pre>
<p>结果为：</p>
<pre><code>//Consequence 11
520
</code></pre>
<h2 id="可变参数">可变参数</h2>
<p>之前学习了如何让函数支持可变参数，带参数的宏定义也支持使用可变参数：</p>
<pre><code class="language-c">#define SHOWLIST(...) printf(#__VA_AGES__)
</code></pre>
<p>如：</p>
<pre><code class="language-c">//Example 12
#define SHOWLIST(...) printf(#__VA_AGES__)
#include &lt;stdio.h&gt;

int main(void)
{
    SHOWLIST(TechZone, HarrisWilde, C);
    return 0;
}
</code></pre>
<p>由于在VS2019下无法支持编译，这次的结果使用Linux下的GCC来执行：</p>
<pre><code>//Consequence 12 in GCC
TechZone, HarrisWilde, C
</code></pre>
<p>可变参数是允许存在空参数的，如果是空参数，则##前面的逗号也会一起被去掉，避免导致参数数量不一致：</p>
<pre><code class="language-c">//Example 13
#define PRINT(format, ...) printf(#format, ##__VA_AGES__)

int main(void)
{
    PRINT(num = %d\n, 10);
    PRINT(Hello, world!\n);
    return 0;
}
</code></pre>
<p>结果为：</p>
<pre><code>//Consequence 13 in GCC
num = 10
Hello, world!
</code></pre>
<p>函数的基础知识到这里就结束了，希望对大家有所帮助！</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[C语言之函数（中）]]></title>
        <id>https://harriswilde.github.io/post/IKKYqSXMf/</id>
        <link href="https://harriswilde.github.io/post/IKKYqSXMf/">
        </link>
        <updated>2020-02-06T13:47:02.000Z</updated>
        <content type="html"><![CDATA[<h1 id="局部变量和全局变量">局部变量和全局变量</h1>
<h2 id="局部变量">局部变量</h2>
<p>在我们学习函数之前，我们所理解的变量，只不过是在内存中开辟一个存储数据的位置，并取了个我们好懂的名字而已。因为我们之前写的程序只有一个主函数，因此我们觉得，定义了一个变量，就应该可以随时调用。但是学习了函数之后，我们发现，不同函数之间的变量是不能够相互调用的，这又是为什么呢？</p>
<p>比如：</p>
<pre><code class="language-c">//Example 01
#include &lt;stdio.h&gt;
int main(void)
{
    int i = 100;
    printf(&quot;Before i = %d\n&quot;, i);
    for (int i = 0; i &lt;= 10; i++)//再定义一个局部变量i
    {
        printf(&quot;i = %d\n&quot;, i);
    }
    printf(&quot;After i = %d\n&quot;, i);
    return 0;
}
</code></pre>
<p>结果如下：</p>
<pre><code>//Consequence 01
Before i = 100
i = 0
i = 1
i = 2
i = 3
i = 4
i = 5
i = 6
i = 7
i = 8
i = 9
i = 10
After i = 100
</code></pre>
<p>我们可以看到，我们在<code>for</code>函数里和<code>main</code>函数里都有一个<code>i</code>变量，但是我们在<code>for</code>函数里面定义的<code>i</code>却对外层函数不构成影响。</p>
<p>一般来说，变量名应该是不能够重复的。但是，由于我们定义的位置不一样（在不同的函数中），所以变量名重复又变得合法起来。这就是局部变量的特性：<strong>只能在自己的领域里面发挥作用</strong>。</p>
<p>像我们刚刚定义的<code>for</code>一样，C语言允许随处定义变量。也就是说，变量在需要用到的时候再定义。这样也符合我们的思维方式。因为当程序很庞大的时候，没有人愿意翻到顶上去看一个变量的注释。</p>
<h2 id="全局变量">全局变量</h2>
<p>既然有局部变量，那么全局变量也照样不可少。看下面的例子：</p>
<pre><code class="language-c">//Example 02
#include &lt;stdio.h&gt;
void f1(void);
void f2(void);
void f3(void);
int a = 0;//定义一个全局变量

void f1(void)
{
    a++;
}

void f2(void)
{
    a++;
}

void f3(void)
{
    a++;
}

int main(void)
{
    f1();
    f2();
    f3();
    printf(&quot;a = %d\n&quot;, ++a);
    return 0;
}
</code></pre>
<p>运行结果如下：</p>
<pre><code>//Consequence 02
a = 4
</code></pre>
<p>我们发现，全局变量在每一个函数里面的更改都“有效”，也就是说，全局变量是贯穿整个程序始终的。</p>
<p>有的小伙伴可能会好奇，如果全局变量和局部变量重名了，会发生什么呢？</p>
<p>那我们就来试试：</p>
<pre><code class="language-c">//Example 03
#include &lt;stdio.h&gt;
void f(void);
int a, b = 100;
void f(void)
{
    int b;
    a = 50; b = 101;
    printf(&quot;func, a = %d, b = %d\n&quot;, a, b);
}

int main(void)
{
    printf(&quot;Main, a = %d, b = %d\n&quot;, a, b);
    f();
    printf(&quot;Main, a = %d, b = %d\n&quot;, a, b);
}
</code></pre>
<p>运行结果如下：</p>
<pre><code>//Consequence 03
Main, a = 0, b = 100
func, a = 50, b = 101
Main, a = 50, b = 100
</code></pre>
<p>我们发现，名字叫<code>a</code>的变量只有全局变量，那么被赋值之后就等于在函数<code>f()</code>中赋的值。但是<code>b</code>就不一样了。在函数<code>f()</code>中，也有一个变量叫做<code>b</code>，那么此时编译器的做法是，在函数<code>f()</code>里先暂时屏蔽全局变量<code>b</code>，使用自己的局部变量。等走出了函数<code>f()</code>，局部变量被释放。</p>
<p>而我们还发现一个问题，我们可以直接输出没有被初始化的<code>a</code>！这也是全局变量的一个特点，不同于局部变量，全局变量在没有手动初始化的时候，会被系统自动初始化为<code>0</code>而不是像局部变量那样的很小的一个很奇怪的数。</p>
<p>另外，如果没有需要，尽量不要大量使用全局变量。因为全局变量的内存将会伴随着这个程序，直到程序执行完毕。如果大量使用全局变量的话，可能会造成内存占用过多等问题。这在嵌入式开发这种领域，内存空间寸土寸金，不当使用全局变量会导致资源的浪费。其次，全局变量会造成程序可读性变差。最后，全局变量会使得程序牵连性变强，牵一发而动全身的情况可能会再次出现。</p>
<p>因此全局变量虽然是个好东西，但也要谨慎使用。</p>
<h1 id="作用域和链接属性">作用域和链接属性</h1>
<p>在上一节，我们简单地了解了不同的变量，它能够有不同的作用范围，那么这个范围，就是我们所说的<strong>作用域</strong>。C语言的编译器一共能够确认4种不同的作用域：<code>代码块作用域</code> <code>文件作用域</code> <code>原型作用域</code> <code>函数作用域</code></p>
<h2 id="代码块作用域">代码块作用域</h2>
<pre><code class="language-c">//Example 04
#include &lt;stdio.h&gt;
int main(void)
{
    int i = 1;
    {
        int i = 2;
        printf(&quot;i = %d\n&quot;, i);
    }
    {
        printf(&quot;i = %d\n&quot;, i);
        int i = 3;
        printf(&quot;i = %d\n&quot;, i);
    }
    printf(&quot;i = %d\n&quot;, i);
    return 0;
}
</code></pre>
<p>运行结果如下：</p>
<pre><code>//Consequence 04
i = 2
i = 1
i = 3
i = 1
</code></pre>
<p>我们通常管一个大括号里面的语句叫做代码块，那么看这个程序，一个代码块里面的变量只能作用于所在的代码块里，超出了的就无效了。若存在代码块嵌套，那么优先内层代码块的变量。这就是<strong>代码块作用域</strong>。</p>
<p>当然，有一点需要说说，就是函数的形参也是代码块作用域，只能作用于函数定义代码块里面，即便它没有写在代码块里面。</p>
<h2 id="文件作用域">文件作用域</h2>
<p>在任何代码块之外定义的变量，都具有<strong>文件作用域</strong>。它们的作用域是从变量声明开始，一直到文件尾结束。另外，函数名也是文件作用域，因为函数名本身也在代码块之外。</p>
<h2 id="原型作用域">原型作用域</h2>
<p>原型作用域只适合那些在函数原型中声明的参数名。我们知道，在声明一个函数的时候，形参的名字是可以不用写的，只需要把类型写好就行了。但是，其实不妨可以试试写上名字，即便这个名字和正式定义的时候形参的名字不一样，也是没问题的（当然这样做毫无意义），这其实就是原型作用域在起作用。</p>
<h2 id="函数作用域">函数作用域</h2>
<p>函数作用域只适用于<code>goto</code>语句的标签，作用是将<code>goto</code>语句的标签限定在一个函数的内部，避免出现重名的标签。</p>
<h2 id="链接属性">链接属性</h2>
<p>简单来说，编译器将源代码转换成机器码的时候需要有两个步骤：<strong>编译</strong>和<strong>链接</strong>。</p>
<p>所谓编译，就是将我们写的源代码转换为机器码，而链接，就是将相关的库文件添加进来。比如我们在写程序的时候加入的头文件，在最终生成的时候就是要链接进来的。</p>
<p>我们知道，大型程序是由很多源文件构成的，那么在不同的文件中的同名标识符，编译器是入场处理的呢？</p>
<p>在C语言中，链接属性一共有以下3种：</p>
<ul>
<li>external(外部的)：多个文件中声明的同名标识符表示同一个实体</li>
<li>internal(内部的)：单个文件中声明的同名标识符表示同一个实体</li>
<li>none(无)：声明的同名标识符被当作独立不同的实体。比如，函数的局部变量。</li>
</ul>
<p>默认情况下，具备文件作用域的标识符拥有<code>external</code>属性，也就是说，这种标识符允许跨文件访问。使用<code>static</code>可以使原先拥有<code>external</code>属性的标识符变为<code>internal</code>属性。但是<code>static</code>只能修改具有文件作用域的标识符，并且是不可逆修改。</p>
<h1 id="生存期和存储类型">生存期和存储类型</h1>
<h2 id="生存期">生存期</h2>
<p>上一节我们用空间的角度去解释了不同的变量，但其实，还可以从时间的角度来分析。</p>
<p>C语言的变量通常有两种生存期，静态存储期(static storage duration)和自动存储期(automatic storage duration)。</p>
<p>具有文件作用域的变量具有静态存储期（如全局变量），函数名也有静态存储期。静态存储期的变量在程序执行的期间内将一直占据存储空间。</p>
<p>具有代码块作用域的变量通常具有自动存储期（如局部变量和形参），具有自动存储期的变量将在代码块执行完毕的时候释放内存。</p>
<h2 id="存储类型">存储类型</h2>
<p>变量的存储类型实际上是指存储变量值的内存类型。C语言提供了5种存储类型：<code>auto</code> <code>register</code> <code>static</code> <code>extern</code> <code>typedef</code></p>
<h3 id="1-自动变量">1. 自动变量</h3>
<p>在代码块中声明的变量默认就是自动变量(auto)。</p>
<pre><code class="language-c">//Example 05
#include &lt;stdio.h&gt;
int main(void)
{
    auto int a, b, c;
    return 0;
}
</code></pre>
<p>但是由于是默认存储类型，所以<code>auto</code>一般不写也完全没问题。函数中的形参、局部变量以及复合语句中定义的局部变量都具有自动变量。自动变量拥有代码块作用域、自动存储期和空链接属性。</p>
<h3 id="2-寄存器变量">2. 寄存器变量</h3>
<p>如果你学过汇编语言，或者对计算机的原理比较了解的话，一定没少听说<strong>寄存器</strong>这个词。寄存及就集成在CPU内部，因此它和CPU之间的交流几乎可以说没有延迟。</p>
<p>如果你申请了寄存器变量，那么就有可能被存储到寄存器里面去。当然，编译器也有自己的优化方案，它会在程序运行的时候权衡哪些变量更应该被放到寄存器的位置，因此，你的申请只是做一个参考而已。那么那些没有被放入寄存器的变量就会成为<strong>自动变量</strong>，所以，寄存器变量和自动变量在很多地方是一样的，也拥有代码块作用域、自动存储期和空链接属性。</p>
<p>但是，如果是寄存器变量的话，那么理论上就没法通过**取地址运算符&amp;**来获取地址了，因为我们知道这个是针对内存的。</p>
<pre><code class="language-c">//Example 06
#include &lt;stdio.h&gt;
int main(void)
{
    register int i = 100;
    printf(&quot;addr of i is %p\n&quot;, &amp;i);
    return 0;
}
</code></pre>
<p>但是VS可能对这种代码有优化，将变量转换成自动变量了：</p>
<pre><code>//Consequence 06 of Visual Studio 2019
addr of i is 00CFFE90
</code></pre>
<h3 id="3-静态局部变量">3. 静态局部变量</h3>
<p><code>static</code>用于描述具有文件作用域的变量或者函数时，表示将其链接属性从<code>external</code>修改成<code>internal</code>，它的作用范围就变成了仅当前文件可访问。如果<code>static</code>用于描述局部变量，那可就不太一样了。</p>
<p>默认情况下，局部变量是自动变量，具有自动存储期。如果使用了<code>static</code>来声明，那么就可以将局部变量指定为静态局部变量(static)。这使得局部变量具有静态存储期，所以它的生存期和全局变量一样。但是作用域依旧是局部变量，在别的函数中是无法访问这个局部变量的。</p>
<h3 id="4-extern">4.  extern</h3>
<p><code>extern</code>关键字告诉编译器这个变量或函数在别的地方已经定义过了，先在别的地方找找，不要急着报错。</p>
<p>通常情况下，这个关键词可以不写，但是为了程序更加完善，更加易读。在多人协作的时候，可以避免很多重名的问题。</p>
<h3 id="5-typedef">5.  typedef</h3>
<p><code>typedef</code>与其他四个存储类型的语义不同，<code>typedef</code>与内存存储无关，用于为数据类型定义一个新名字。</p>
<h1 id="递归">递归</h1>
<p>虽然递归隶属于算法的范畴，但是几乎所有的程序语言教程，都会讲到这个知识点。因为，递归是一个非常好的编程思路，有时候一个很难解决的问题，使用递归就可以巧妙地搞定。</p>
<h2 id="什么是递归">什么是递归</h2>
<p>递归说白了，就是函数在执行的时候，调用自身的行为。其实递归在生活中有很多实例，比如：</p>
<ol>
<li>
<p>汉诺塔游戏</p>
<figure data-type="image" tabindex="1"><img src="https://ss0.bdstatic.com/70cFuHSh_Q1YnxGkpoWK1HF6hhy/it/u=2591095191,1547695417&amp;fm=26&amp;gp=0.jpg" alt="汉诺塔游戏" loading="lazy"></figure>
<p>这个游戏要求将中间的柱子的圆盘全部移动到另外一个柱子上，要求每次只能移动一个圆盘，并且较大的圆盘始终在下方。</p>
</li>
<li>
<p>谢尔宾斯基三角形</p>
<figure data-type="image" tabindex="2"><img src="https://ss1.bdstatic.com/70cFvXSh_Q1YnxGkpoWK1HF6hhy/it/u=3361120212,184359007&amp;fm=26&amp;gp=0.jpg" alt="谢尔宾斯基三角形" loading="lazy"></figure>
<p>三角形里边填充三角形，只要空间够大，它可以撑满整个宇宙。</p>
</li>
</ol>
<p>甚至还诞生了一门数学分支：分形几何。专门研究这种递归现象。</p>
<p>说了这么多，那么递归在程序里面该如何实现呢？</p>
<pre><code class="language-c">//Example 07
#include &lt;stdio.h&gt;
void r(void);
void r(void)
{
    printf(&quot;Hi!&quot;);
    r();
}
int main(void)
{
    r();
    return 0;
}
</code></pre>
<p>运行结果如下：</p>
<pre><code>//Consequence 08
...
Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Segmentation fault
</code></pre>
<p>可以看到，满屏幕的Hi！这就是初学者经常会犯的错误，程序无休止地执行下去，直到消耗掉所有的内存。这就像我们讲过的“从前有座山，山里有座庙……”这个故事一样，没有中止的条件，讲多久都讲不完。</p>
<p>修改下代码：</p>
<pre><code class="language-c">//Example 07 V2
#include &lt;stdio.h&gt;
void r(void);
void r(void)
{
    static int count = 5;//设置计数变量
    printf(&quot;Hi!\n&quot;);
    if (--count)//设置跳出条件
    {
        r();
    }
}

int main(void)
{
    r();
    return 0;
}
</code></pre>
<p>运行结果如下：</p>
<pre><code>//Consequence 07 V2
Hi!
Hi!
Hi!
Hi!
Hi!
</code></pre>
<p>这样，递归这头小猛兽，就这样被我们控制住了。</p>
<h2 id="递归求斐波那契数列">递归求斐波那契数列</h2>
<p>斐波那契数列每一项等于前两项之和，正好符合递归的思路：</p>
<pre><code class="language-c">#include &lt;stdio.h&gt;
int fibo(int n)
{
    if (n &lt;= 2)
    {
        return 1;
    }
    else
    {
        return fibo(n - 1) + fibo(n - 2);
    }
}
int main()
{
    int n;
    printf(&quot;请输入斐波那契数列长度：&quot;);
    scanf(&quot;%d&quot;, &amp;n);
    for (int i = 1; i &lt;= n; ++i)
    {
        printf(&quot;%d&quot;, fibo(i));
        if (i &lt; n)
        {
            printf(&quot;, &quot;);
        }
    }
    return 0;
}
</code></pre>
<p>程序执行如下：</p>
<pre><code>请输入斐波那契数列长度：10
1, 1, 2, 3, 5, 8, 13, 21, 34, 55
</code></pre>
<h2 id="递归求汉诺塔">递归求汉诺塔</h2>
<p>其实，不论有多少层汉诺塔，都可以使用递归一层一层往下解包。</p>
<pre><code class="language-c">//Example 08
#include &lt;stdio.h&gt;
void hanoi(int, char, char, char);
void hanoi(int n, char x, char y, char z)
{
    if (n == 1)
    {
        printf(&quot;%c --&gt; %c\n&quot;, x, z);//剩下底部的圆盘
    }
    else
    {
        hanoi(n - 1, x, z, y);//将n-1个圆盘从x移动到y
        printf(&quot;x --&gt; z\n&quot;);
        hanoi(n - 1, y, x, z);//将n-1个圆盘从y移动到z
    }
}
int main(void)
{
    int n;
    printf(&quot;请输入汉诺塔的层数：&quot;);
    scanf(&quot;%d&quot;, &amp;n);
    hanoi(n, 'X', 'Y', 'Z');
    return 0;
}
</code></pre>
<p>运行结果如下：</p>
<pre><code>//Consequence 08
请输入汉诺塔的层数：4
X --&gt; Y
x --&gt; z
Y --&gt; Z
x --&gt; z
Z --&gt; X
x --&gt; z
X --&gt; Y
x --&gt; z
Y --&gt; Z
x --&gt; z
Z --&gt; X
x --&gt; z
X --&gt; Y
x --&gt; z
Y --&gt; Z
</code></pre>
<h2 id="分治法">分治法</h2>
<p>所谓分治法，就是大事化小的思维。递归实际上就是一种分治。层层递归，然后从最简单的问题开始解决。</p>
<p>说到这里，就不得不提到一种排序算法，就是十分经典的——快速排序。</p>
<p>作为20世纪十大算法之一，快速排序的基本思想是：通过一项将待排序数据分割成独立的两部分，其中一部分元素均比另一部分小，然后分别对这两部分继续排序，重复步骤直到完成。</p>
<figure data-type="image" tabindex="3"><img src="https://www.cxyxiaowu.com/wp-content/uploads/2019/10/1571057581-e7b9d65b41e66df.gif" alt="快速排序动画演示" loading="lazy"></figure>
<p>代码如下：</p>
<pre><code class="language-c">//Example 09
#include &lt;stdio.h&gt;
void qs(int, int, int);
void qs(int array[], int left, int right)
{
    int i = left, j = right;
    int temp;
    int pivot;
    
    //基准点设置为中间元素，当然别的也可以
    pivot = array[(left + right) / 2];
    
    while (i &lt;= j)
    {
        //找到左边大于等于基准点的元素
        while (array[i] &lt; pivot)
        {
            ++i;
        }
        //找到右边小于等于基准点的元素
        while (array[j] &gt; pivot)
        {
            --j;
        }
        //如果左边下标小于右边，则交换元素
        if (i &lt;= j)
        {
            temp = array[i];
            array[i] = array[j];
            array[j] = temp;
            ++i;
            --j;
        }
    }
    
    //递归遍历左子
    if (left &lt; j)
    {
        qs(array, left, j);
    }
    //递归遍历右子
    if (i &lt; right)
    {
        qs(array, i, right);
    }
}

int main(void)
{
    int array[] = {135, 156, 120, 102, 130, 62, 410, 158, 173, 113, 124, 184, 131, 214};
    int length;
    length = sizeof(array) / sizeof(array[0]);
    qs(array, 0, length - 1);
    
    printf(&quot;排序后结果为：&quot;);
    for (int i = 0; i &lt; length; i++)
    {
        printf(&quot;%d&quot;, array[i]);
        if (i &lt; length - 1)
        {
            printf(&quot;, &quot;);
        }
    }
    putchar('\n');
    return 0;
}
</code></pre>
<p>执行结果如下：</p>
<pre><code>//Consequence 09
排序后结果为：62, 102, 113, 120, 124, 130, 131, 135, 156, 158, 173, 184, 214, 410
</code></pre>
<p>学了这么多，也该好好休息下了！下期再见！</p>
]]></content>
    </entry>
</feed>