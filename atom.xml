<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://harriswilde.github.io</id>
    <title>TechZone</title>
    <updated>2020-02-05T04:14:48.563Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://harriswilde.github.io"/>
    <link rel="self" href="https://harriswilde.github.io/atom.xml"/>
    <subtitle>HarrisWilde祝诸君元旦快乐🎉</subtitle>
    <logo>https://harriswilde.github.io/images/avatar.png</logo>
    <icon>https://harriswilde.github.io/favicon.ico</icon>
    <rights>All rights reserved 2020, TechZone</rights>
    <entry>
        <title type="html"><![CDATA[C语言之函数（上）]]></title>
        <id>https://harriswilde.github.io/post/cYwGcFKPK</id>
        <link href="https://harriswilde.github.io/post/cYwGcFKPK">
        </link>
        <updated>2020-02-03T06:49:54.000Z</updated>
        <content type="html"><![CDATA[<p>在学习了指针以后，我们的C语言学习就算真正入门了。那么，随着我们自己编写的程序规模越来越大，我们写的代码也越来越繁杂，经常会碰到大脑不够用，或者名字不会起了这类看似很搞笑的问题。再者，就是往往要更改代码的时候牵一发而动全身，稍微出差错，就只能推倒重来。</p>
<p>那么，在做开发，尤其是多人协作的大型开发的时候，程序模块化是十分重要的，你只需要预留一些供他人使用的必须的接口，然后把你定义的方法写个文档方便他人开发就行了。那么这种思维，就是<strong>结构化编程</strong>。</p>
<p>比如，我们经常使用的<code>printf</code>函数，就是C语言开发者写好在<code>stdio.h</code>里面的。有了这个函数，我们就可以很简单地输出文本，而不需要去关注底层到底是如何实现的。你会发现，有函数，我们就可以把更多的注意力放在逻辑的实现上，而不需要去关注太多的细枝末节。</p>
<h1 id="函数的定义和声明">函数的定义和声明</h1>
<h2 id="绪论">绪论</h2>
<p>虽然C语言的内置函数已经十分丰富，可以帮我们实现大部分的问题。什么字符串的处理啊，数学方面的计算啊，等等……但是，作为一门高级语言，C语言还可以让我们自己来定义函数，把我们的一些方法抽象封装出来，用于其他的对象上。</p>
<p>我们举个简单的例子，封装一个输出字符图的函数：</p>
<pre><code class="language-c">//Example 01
#include &lt;stdio.h&gt;
//------定义开始------//
void print_house(void)
{
    printf(&quot;¤╭⌒╮ ╭⌒╮:∴★∵**☆．\n&quot;);
    printf(&quot;╱◥██◣ :∴☆∵**★．\n&quot;);
    printf(&quot;|田︱田田|:∴★∵**☆．\n&quot;);
    printf(&quot;╬╬╬╬╬╬╬╬╬╬╬╬╬╬ \n&quot;);
}
//------定义结束------//
int main(void)
{
    print_house();//调用函数
    return 0;
}
</code></pre>
<p>运行结果如下：</p>
<pre><code>//Consequence 01
¤╭⌒╮ ╭⌒╮:∴★∵**☆．
╱◥██◣ :∴☆∵**★．
|田︱田田|:∴★∵**☆．
╬╬╬╬╬╬╬╬╬╬╬╬╬╬ 
</code></pre>
<h2 id="函数的定义">函数的定义</h2>
<p>定义函数的方法，和我们使用<code>main</code>函数的方法差不多：</p>
<pre><code class="language-c">类型名 函数名(参数列表)
{
    函数体
}
</code></pre>
<ul>
<li>类型名就是函数返回值的类型，如果不希望函数返回任何类型，那么就应该使用<code>void</code>（无类型，表示没有返回值）。</li>
<li><strong>函数名</strong>就是函数的名字，自己想怎么命名都可以，但是不要和保留字重复。</li>
<li><strong>参数列表</strong>指定了参数的<strong>类型</strong>和<strong>名字</strong>，如果不需要传递参数，则写上<code>void</code>即可。</li>
<li><strong>函数体</strong>是指函数的具体算法，是函数中关键部分</li>
</ul>
<h2 id="函数的声明">函数的声明</h2>
<p>所谓的声明，就是将函数先告诉编译器，但是具体算法，则在<code>main</code>函数之后开发。</p>
<p>如果不做声明，把上面的程序改成这样则会出错：</p>
<pre><code class="language-c">//Example 01
#include &lt;stdio.h&gt;
int main(void)
{
    print_house();//调用函数
    return 0;
}
//------定义开始------//
void print_house(void)
{
    printf(&quot;¤╭⌒╮ ╭⌒╮:∴★∵**☆．\n&quot;);
    printf(&quot;╱◥██◣ :∴☆∵**★．\n&quot;);
    printf(&quot;|田︱田田|:∴★∵**☆．\n&quot;);
    printf(&quot;╬╬╬╬╬╬╬╬╬╬╬╬╬╬ \n&quot;);
}
//------定义结束------//
</code></pre>
<p>因为道理上，程序是<strong>从上往下</strong>编译的，如果不提前告知，那么<code>main</code>函数里面的<code>print_house</code>，编译器便不知道这是个什么东西。</p>
<p>如果你做了函数的声明，那么这个程序就可以正常执行：</p>
<pre><code class="language-c">//Example 01
#include &lt;stdio.h&gt;
void print_house(void);//声明函数
int main(void)
{
    print_house();//调用函数
    return 0;
}
//------定义开始------//
void print_house(void)
{
    printf(&quot;¤╭⌒╮ ╭⌒╮:∴★∵**☆．\n&quot;);
    printf(&quot;╱◥██◣ :∴☆∵**★．\n&quot;);
    printf(&quot;|田︱田田|:∴★∵**☆．\n&quot;);
    printf(&quot;╬╬╬╬╬╬╬╬╬╬╬╬╬╬ \n&quot;);
}
//------定义结束------//
</code></pre>
<p>原则上来说，函数必须先定义，再使用。况且在以后的开发尤其是团队协作的情况下，先使用函数，后开发函数的情况比较多，因此养成<strong>先定义，后使用</strong>的良好习惯是最好的。</p>
<h1 id="函数的参数和返回值">函数的参数和返回值</h1>
<p>向函数传入参数，可以使函数的功能更加丰富。比如，我们刚刚定义了一个输出字符画的函数，但是这个函数无论在什么时候，它执行出来的结果都是一样的。无法实现更加个性化的功能。比如：</p>
<pre><code class="language-c">//Example 02
#include &lt;stdio.h&gt;
void print(int);

int main(void)
{
	int a;
	scanf(&quot;%d&quot;, &amp;a);
	print(a);
	return 0;
}

void print(int a)
{
	for (int i = a; i &gt; 0; i--)
	{
		printf(&quot;-&quot;);
	}
}
</code></pre>
<p>运行结果如下：</p>
<pre><code>//Consequence 02 - 01
5
-----
</code></pre>
<pre><code>//Consequence 02 - 02
7
-------
</code></pre>
<p>你看，输出的内容会随着用户输入的数字而改变，就像<strong>定制</strong>一样。</p>
<p>那么函数的<strong>返回值</strong>又是什么呢？</p>
<p>我们发现，我们刚刚写的函数，都没有返回值，因为在函数体的执行过程中，我们要得到的结果已经执行完毕了，并不需要返回什么东西。但是，有些函数就不一样了。</p>
<p>比如，我们现在要创建一个函数，能够实现阶乘，这时候，就需要返回值了。</p>
<pre><code class="language-c">//Example 03 - 迭代法
#include &lt;stdio.h&gt;
int factorial(int);

int main(void)
{
    int a;
    scanf(&quot;%d&quot;,&amp;a);
    printf(&quot;%d&quot;, factorial(a));
    return 0;
}

int factorial(int a)
{
    int sum = 1;
    for (int i = a; i &gt; 0; i--)
    {
        sum *= i;
    }
    return sum;
}
</code></pre>
<pre><code class="language-c">//Example 03 - 递归法
#include &lt;stdio.h&gt;
int factorial(int);

int main(void)
{
    int a;
    scanf(&quot;%d&quot;, &amp;a);
    printf(&quot;%d&quot;, factorial(a));
    return 0;
}

int factorial(int a)
{
    int sum;
    if (a == 1)
    {
        return 1;
    }
    else
    {
        return a * factorial(a - 1);
    }
}
</code></pre>
<p>执行结果如下：</p>
<pre><code>//Consequence 03
5
120
</code></pre>
<h2 id="形参和实参">形参和实参</h2>
<p>所谓<strong>形参</strong>，就是形式参数，如：</p>
<pre><code class="language-c">...
int f(int a, int b);
...
</code></pre>
<p>这其中的<code>a</code>和<code>b</code>就是形式参数，此时只是作占位符而已，而在函数真正使用的时候：</p>
<pre><code class="language-c">...
int main(void)
{
    f(x, y);
    ...
}
...
</code></pre>
<p>此时的<code>x</code>和<code>y</code>就是<strong>实参</strong>。因为此时传递进去的值是真正程序里面拥有的值，是实实在在的。</p>
<p>其实形参和实参的作用就是用来传递数据的，当我们自己定义的函数被调用的时候，实参会将值传递给形参（单向传递）。形参变量只有在函数被调用的时候才会分配内存，调用结束后，立即释放内存，因此形参变量只有在函数内部有效，<strong>对函数外的变量不影响</strong>。</p>
<h2 id="传值和传址">传值和传址</h2>
<pre><code class="language-c">//Example 04 - 01
#include &lt;stdio.h&gt;
void swap(int, int);
void swap(int a, int b)
{
    int temp;
    printf(&quot;swap中，交换前：a = %d, b = %d\n&quot;, a, b);
    temp = a;
    a = b;
    b = temp;
    printf(&quot;swap中，交换前：a = %d, b = %d\n&quot;, a, b);
}

int main(void)
{
    int a = 1, b = 2;
    printf(&quot;main中，交换前：a = %d, b = %d\n&quot;, a, b);
    swap(a, b);
    printf(&quot;main中，交换前：a = %d, b = %d\n&quot;, a, b);
    return 0;
}
</code></pre>
<p>运行结果为：</p>
<pre><code>//Consequence 04 - 01
main中，交换前：a = 1, b = 2
swap中，交换前：a = 1, b = 2
swap中，交换前：a = 2, b = 1
main中，交换前：a = 1, b = 2
</code></pre>
<p>可以看到，在<code>swap</code>函数内，传入的值被互换，但是在主函数内，值依旧没有被改变。因此可以得出结论：<strong>函数内部无法改变实参的值</strong></p>
<p>但是，如果换成指针会怎样呢？</p>
<pre><code class="language-c">//Example 04 - 02
#include &lt;stdio.h&gt;
void swap(int*, int*);
void swap(int* a, int* b)
{
    int temp;
    printf(&quot;swap中，交换前：a = %d, b = %d\n&quot;, *a, *b);
    temp = *a;
    *a = *b;
    *b = temp;
    printf(&quot;swap中，交换前：a = %d, b = %d\n&quot;, *a, *b);
}

int main(void)
{
    int a = 1, b = 2;
    printf(&quot;main中，交换前：a = %d, b = %d\n&quot;, a, b);
    swap(&amp;a, &amp;b);
    printf(&quot;main中，交换前：a = %d, b = %d\n&quot;, a, b);
    return 0;
}
</code></pre>
<p>运行结果为：</p>
<pre><code class="language-c">//Consequence 04 - 02
main中，交换前：a = 1, b = 2
swap中，交换前：a = 1, b = 2
swap中，交换前：a = 2, b = 1
main中，交换前：a = 2, b = 1
</code></pre>
<p>欸？怎么这会儿就能变了呢？有人可能会说，Harris你是不是刚刚骗我？</p>
<p>其实并不是，我们看这句：<code>swap(&amp;a, &amp;b);</code>，我们其实传入的实参是两个变量的地址。</p>
<p>打个比方，如果变量<code>a</code>的在内存里面住的是1号房间，变量<code>b</code>在内存中住的是2号房间。那么函数处理了之后，他俩住的地方并没有改变，也就是说，两个变量的内存地址并没有改变，只是函数把这个地址对应的值改变了而已。函数内对指针进行解引用，实际上就是间接地访问了变量的值。</p>
<h2 id="传数组">传数组</h2>
<p>既然是可以传递指针，那么数组按理来说，应该也是可以传的。</p>
<pre><code class="language-c">//Example 05
#include &lt;stdio.h&gt;
void get_array(int);
void get_array(int a[10])
{
	for (int i = 0; i &lt; 10; i++)
	{
		printf(&quot;a[%d] = %d\n&quot;, i, a[i]);
	}
}

int main(void)
{
	int a[10] = { 1,2,3,4,5,6,7,8,9,10 };
	get_array(a);
	return 0;
}
</code></pre>
<pre><code class="language-c">//Consequence 05
a[0] = 1
a[1] = 2
a[2] = 3
a[3] = 4
a[4] = 5
a[5] = 6
a[6] = 7
a[7] = 8
a[8] = 9
a[9] = 10
</code></pre>
<p>如果我们尝试着在函数内改变数组的值呢？</p>
<pre><code class="language-c">//Example 06
#include &lt;stdio.h&gt;
void get_array(int);
void get_array(int a[10])
{
	a[4] = 1;//更改一个值
	for (int i = 0; i &lt; 10; i++)
	{
		printf(&quot;a[%d] = %d\n&quot;, i, a[i]);
	}
}

int main(void)
{
	int a[10] = { 1,2,3,4,5,6,7,8,9,10 };
	get_array(a);
	return 0;
}
</code></pre>
<pre><code>//Consequence 06
a[0] = 1
a[1] = 2
a[2] = 3
a[3] = 4
a[4] = 1
a[5] = 6
a[6] = 7
a[7] = 8
a[8] = 9
a[9] = 10
</code></pre>
<p>可以看到，在主函数里面输出数组，也是被改变了的。于是可以断定，其实传入的并不是一个数组，而是这个数组的<strong>首地址</strong>而已。</p>
<h2 id="可变参数">可变参数</h2>
<p>可能有的同学会纳闷，我们定义的函数，都是给参数预留了位置的，那如果像<code>printf()</code>这种函数，它的参数是取决于占位符的数量，这种函数是怎么定义的呢？</p>
<p>这里，我们就要将一个以前没有用过的头文件<code>&lt;stdarg.h&gt;</code>。这个头文件中有一个类型和三个宏是需要用到的：</p>
<p>一个类型是<code>va_list</code>，三个宏是<code>va_start</code> <code>va_arg</code> <code>va_end</code>，其中，<code>va</code>就是指<strong>variable-argument（可变参数）</strong>。</p>
<pre><code class="language-c">//Example 07
#include &lt;stdio.h&gt;
#include &lt;stdarg.h&gt;
int sum(int n, ...);
int sum(int n, ...)//第一个参数n代表后面可变参数的数量，三个点代表不确定参数个数
{
	int sum = 0;
	va_list arg;//定义参数列表
	va_start(arg, n);//初始化参数列表，n为第一个参数的名称
	for (int i = 0; i &lt; n; i++)
	{
		sum += va_arg(arg, int);//依次获取参数值
	}
	va_end(arg);//结束参数列表
	return sum;
}

int main(void)
{
	int result;
	result = sum(5, 1, 2, 3, 4, 5);
	printf(&quot;result = %d\n&quot;, result);
	return 0;
}
</code></pre>
<p>结果如下：</p>
<pre><code>//Consequence 07
result = 15
</code></pre>
<h1 id="指针函数和函数指针">指针函数和函数指针</h1>
<h2 id="指针函数">指针函数</h2>
<p>函数的类型，实际上就是函数返回值的类型，那么顾名思义，指针函数就是返回指针的函数。</p>
<pre><code class="language-c">//Example 08
#include &lt;stdio.h&gt;
char* getWord(char);
char* getWord(char c)
{
    switch (c)
    {
    case 'A':return &quot;Apple&quot;;
    case 'B':return &quot;Boy&quot;;
    case 'C':return &quot;Cat&quot;;
    case 'D':return &quot;Dog&quot;;
    default:return &quot;None&quot;;
    }
}
int main(void)
{
    char input;
    scanf(&quot;%c&quot;, &amp;input);
    printf(&quot;%s&quot;, getWord(input));
    return 0;
}
</code></pre>
<p>运行结果：</p>
<pre><code>//Consequence 08
A
Apple
</code></pre>
<p>有的小伙伴可能会说，为啥这个<code>switch</code>语句中不用加<code>break</code>呢？</p>
<p>因为<code>return</code>实际上就代表函数执行的结束，因此不会执行到下面的<code>case</code>。</p>
<p>这个例子就是让函数返回字符串(指针)。</p>
<p>另外，不要将函数中局部变量的值作为返回值，因为局部变量的值的作用域（有效范围）只有<strong>函数内部</strong>，因此返回局部变量是不合法的（详细将在下一节中讲到）。</p>
<h2 id="函数指针">函数指针</h2>
<pre><code class="language-c">指针函数 -&gt; int* f();
函数指针 -&gt; int (*p)();
</code></pre>
<p>本质上，函数表示法就是指针表示法。因为函数的名字经过取值会变成函数的地址，所以在定义了函数指针以后，给它传递一个已经被定义的函数名，即可通过该指针进行调用。</p>
<pre><code class="language-c">//Example 09
#include &lt;stdio.h&gt;
int square(int);
int square(int a)
{
    return a * a;
}
int main(void)
{
    int num;
    int (*fp)(int);
    scanf(&quot;%d&quot;, &amp;num);
    fp = square;
    printf(&quot;%d * %d = %d\n&quot;, num, num, (*fp)(num));
    return 0;
}
</code></pre>
<p>结果如下：</p>
<pre><code>//Consequence 10
5
5 * 5 = 25
</code></pre>
<p>这里<code>fp = square</code>可以写成<code>fp = &amp;square</code>，<code>(*fp)(num)</code>可以写成<code>fp(num)</code>，可能更加符合我们之前的习惯。</p>
<h2 id="函数指针作为参数">函数指针作为参数</h2>
<p>函数指针也可以作为参数传递，这样函数就可以实现更加丰富的功能。</p>
<pre><code class="language-c">//Example 11
#include &lt;stdio.h&gt;

int add(int, int);
int sub(int, int);
int calc(int (*fp)(int, int), int, int);

int add(int a, int b)
{
    return a + b;
}
int sub(int a, int b)
{
    return a - b;
}
int calc(int (*fp)(int, int), int a, int b)
{
    return (*fp)(a, b);
}

int main(void)
{
    printf(&quot;1 + 2 = %d\n&quot;, calc(add, 1, 2));
    printf(&quot;1 - 2 = %d\n&quot;, calc(sub, 1, 2));
    return 0;
}
</code></pre>
<p>运行结果为：</p>
<pre><code>//Consequence 11
1 + 2 = 3
1 - 2 = -1
</code></pre>
<h2 id="函数指针作为返回值">函数指针作为返回值</h2>
<p>假设现在有个问题，让用户输入一个表达式，然后根据用户输入的运算符来确定应该调用哪一个函数进行运算。</p>
<pre><code class="language-c">//Example 12
#include &lt;stdio.h&gt;

int add(int, int);
int sub(int, int);
int calc(int (*fp)(int, int), int, int);
int (*select(char op))(int, int);

int add(int a, int b)
{
    return a+b;
}
int sub(int a, int b)
{
    return a-b;
}
int calc(int (*fp)(int, int), int a, int b)
{
    return (*fp)(a, b);
}
int (*select(char op))(int, int)
{
    switch(op)
    {
        case '+':return add;
        case '-':return sub;
    }
}
int main(void)
{
    int a, b;
    char op;
    int (*fp)(int, int);
    printf(&quot;请输入一个式子，如1+2：&quot;);
    scanf(&quot;%d%c%d&quot;, &amp;a, &amp;op, &amp;b);
    fp =  select(op);
    printf(&quot;%d %c %d = %d\n&quot;, a, op, b, calc(fp, a, b));
    return 0;
}
</code></pre>
<p>运行结果如下：</p>
<pre><code>//Consequence 12
请输入一个式子，如1+2：3+4
3 + 4 = 7
</code></pre>
<p>函数的知识太多太繁杂，所以Harris这次采用分节式来写博客。本期的就到这里啦！如果没有理解的，好好去消化下，理解了的就等我下一篇吧！</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[浅谈拼手气红包的算法]]></title>
        <id>https://harriswilde.github.io/post/BGqcimUfF</id>
        <link href="https://harriswilde.github.io/post/BGqcimUfF">
        </link>
        <updated>2020-01-27T08:22:30.000Z</updated>
        <content type="html"><![CDATA[<hr>
<p>首先，在这里祝各位小伙伴们鼠年大吉！！</p>
<p>今天是大年初三，Harris在这里用一个简单的话题，开启鼠年的博客之旅。</p>
<p>大家每逢佳节，最少不了的活动，就是“抢红包”。自打微信推出了电子红包之后，中国人的节日，又多了一种庆祝方式，那就是<strong>红包雨</strong>。这种将传统活动用科技的方式封装的做法，是Harris比较赞成的。把传统溶于新时代，为我们的传统春节带来了新鲜的空气。</p>
<p>但是，我们在群里发红包的时候，可能有的小伙伴会纳闷儿，这个所谓的随机金额，到底是怎么算的呢？它到底是不是公平的呢？</p>
<p>有的小伙伴和我说，这还不简单么，每一个人打开红包的时候，都按照当前剩余的余额为范围，随机生成一个数字就好了。</p>
<p>但是呢，这样的话，随着红包被打开的越来越多，金额的总数也会越来越少。那么，可以抢到的红包也就越来越小，这虽然遵循我们常规所认为的“先来后到”，但是并不公平。</p>
<p>那么要实现绝对的公平，该怎么办呢？</p>
<h1 id="1-随机分割">1. 随机分割</h1>
<p>其实，这种方法很直观就能想到。我们把一个红包想象成一个香肠，假设有<code>N</code>个人来分这个香肠，那么我们只要随机切<code>N-1</code>刀，把每一块分别分给每一个人即可。</p>
<p>红包也是一样的道理，我们可以在红包发出去的同时，就随机分配好金额。等大家来分的时候，再依次分给每一个人就好了。</p>
<p>这种算法思路并不难，而且也能够达到我们的目的，但是由于以下的两点，导致微信没有采用这种算法：</p>
<ol>
<li>算法复杂度高</li>
<li>对服务器端的要求高</li>
</ol>
<p>首先第一点，这个算法的复杂度，肯定是要比现行的微信随机红包算法的复杂度高很多。另外，由于在红包发出去的瞬间，服务器上就需要存储关于这个红包的分配信息，在春节这种红包高峰期的时候，势必会给服务器带来巨大的压力。在分布式系统没有普及之前，第二点都将是一个难以解决的问题。</p>
<p>因此，微信就退而求其次，采用第二种办法。</p>
<h1 id="2-二倍均值法">2. 二倍均值法</h1>
<p>实际上，我们每个人抢到的红包，都是在下面这个区间里面去随机一个数值：</p>
<p class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mrow><mo fence="true">(</mo><mn>0</mn><mo separator="true">,</mo><mn>2</mn><mover accent="true"><mi>M</mi><mo stretchy="true">‾</mo></mover><mo fence="true">]</mo></mrow><mspace width="1em"/><mo separator="true">;</mo><mover accent="true"><mi>M</mi><mo stretchy="true">‾</mo></mover><mo>=</mo><mfrac><mrow><mi mathvariant="normal">剩</mi><mi mathvariant="normal">余</mi><mi mathvariant="normal">金</mi><mi mathvariant="normal">额</mi></mrow><mrow><mi mathvariant="normal">剩</mi><mi mathvariant="normal">余</mi><mi mathvariant="normal">红</mi><mi mathvariant="normal">包</mi><mi mathvariant="normal">数</mi></mrow></mfrac></mrow><annotation encoding="application/x-tex">\left(0,2\overline {M}\right]\quad;\overline M=\frac{剩余金额}{剩余红包数}
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.23334em;vertical-align:-0.35001em;"></span><span class="minner"><span class="mopen delimcenter" style="top:0em;"><span class="delimsizing size1">(</span></span><span class="mord">0</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">2</span><span class="mord overline"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8833300000000001em;"><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.10903em;">M</span></span></span><span style="top:-3.80333em;"><span class="pstrut" style="height:3em;"></span><span class="overline-line" style="border-bottom-width:0.04em;"></span></span></span></span></span></span><span class="mclose delimcenter" style="top:0em;"><span class="delimsizing size1">]</span></span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mspace" style="margin-right:1em;"></span><span class="mpunct">;</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord overline"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8833300000000001em;"><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="mord mathdefault" style="margin-right:0.10903em;">M</span></span><span style="top:-3.80333em;"><span class="pstrut" style="height:3em;"></span><span class="overline-line" style="border-bottom-width:0.04em;"></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1.363em;vertical-align:-0.686em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.677em;"><span style="top:-2.314em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord cjk_fallback">剩</span><span class="mord cjk_fallback">余</span><span class="mord cjk_fallback">红</span><span class="mord cjk_fallback">包</span><span class="mord cjk_fallback">数</span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.677em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord cjk_fallback">剩</span><span class="mord cjk_fallback">余</span><span class="mord cjk_fallback">金</span><span class="mord cjk_fallback">额</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.686em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span></span></p>
<p>微信，正是采用的这种方法。</p>
<p>那么，为什么这个是公平的呢？</p>
<p>假设，发一个100元的红包，10份。那么第一个人的金额，就会在<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo fence="true">(</mo><mn>0</mn><mo separator="true">,</mo><mn>20</mn><mo fence="true">]</mo></mrow><annotation encoding="application/x-tex">\left(0,20\right]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="minner"><span class="mopen delimcenter" style="top:0em;">(</span><span class="mord">0</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">2</span><span class="mord">0</span><span class="mclose delimcenter" style="top:0em;">]</span></span></span></span></span>元里面随机。假设第一个人抢到了平均值10块钱，那么还剩90.</p>
<p>第二个人的抢到的，应该是<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mrow><mo fence="true">(</mo><mn>0</mn><mo separator="true">,</mo><mn>2</mn><mo>⋅</mo><mfrac><mn>90</mn><mn>9</mn></mfrac><mo fence="true">]</mo></mrow><mo>⇒</mo><mrow><mo fence="true">(</mo><mn>0</mn><mo separator="true">,</mo><mn>20</mn><mo fence="true">]</mo></mrow></mrow><annotation encoding="application/x-tex">\left(0,2\cdot \frac{90}{9}\right]\Rightarrow \left(0,20\right]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.20001em;vertical-align:-0.35001em;"></span><span class="minner"><span class="mopen delimcenter" style="top:0em;"><span class="delimsizing size1">(</span></span><span class="mord">0</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">2</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">⋅</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.845108em;"><span style="top:-2.6550000000000002em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">9</span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.394em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">9</span><span class="mord mtight">0</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.345em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mclose delimcenter" style="top:0em;"><span class="delimsizing size1">]</span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">⇒</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="minner"><span class="mopen delimcenter" style="top:0em;">(</span><span class="mord">0</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">2</span><span class="mord">0</span><span class="mclose delimcenter" style="top:0em;">]</span></span></span></span></span>，和之前的一样，以此类推，这个算法是公平的。</p>
<p>但是，并不是每一次都能够理想化地抢到平均值，毕竟我们是要在这个范围内取随机值。假设第一个人只抢到了1块钱，那么第二个人能够抢到的范围是<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo fence="true">(</mo><mn>0</mn><mo separator="true">,</mo><mn>22</mn><mo fence="true">]</mo></mrow><annotation encoding="application/x-tex">\left(0,22\right]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="minner"><span class="mopen delimcenter" style="top:0em;">(</span><span class="mord">0</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">2</span><span class="mord">2</span><span class="mclose delimcenter" style="top:0em;">]</span></span></span></span></span>，范围就更大了点，假设第二个人也只抢到1块钱，那么第三个人的范围就是<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo fence="true">(</mo><mn>0</mn><mo separator="true">,</mo><mn>24.5</mn><mo fence="true">]</mo></mrow><annotation encoding="application/x-tex">\left(0,24.5\right]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="minner"><span class="mopen delimcenter" style="top:0em;">(</span><span class="mord">0</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">2</span><span class="mord">4</span><span class="mord">.</span><span class="mord">5</span><span class="mclose delimcenter" style="top:0em;">]</span></span></span></span></span>，以此类推，假设前面的9个人都只抢到1块钱，那么最后一个人的范围，就是<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo fence="true">(</mo><mn>0</mn><mo separator="true">,</mo><mn>91</mn><mo fence="true">]</mo></mrow><annotation encoding="application/x-tex">\left(0,91\right]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="minner"><span class="mopen delimcenter" style="top:0em;">(</span><span class="mord">0</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">9</span><span class="mord">1</span><span class="mclose delimcenter" style="top:0em;">]</span></span></span></span></span>，实际上就是91块。所以我们可以看到，如果每个人都抢到范围内平均值以下，那么后面的人的随机范围则会越来越大。</p>
<p>那么，我们来看看另外一个极端，如果第一个人抢到20块钱，那么第二个人的范围就是<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo fence="true">(</mo><mn>0</mn><mo separator="true">,</mo><mn>17.76</mn><mo fence="true">]</mo></mrow><annotation encoding="application/x-tex">\left(0,17.76\right]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="minner"><span class="mopen delimcenter" style="top:0em;">(</span><span class="mord">0</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">1</span><span class="mord">7</span><span class="mord">.</span><span class="mord">7</span><span class="mord">6</span><span class="mclose delimcenter" style="top:0em;">]</span></span></span></span></span>，假设第二个人抢到17元，第三个人的范围就是<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo fence="true">(</mo><mn>0</mn><mo separator="true">,</mo><mn>15.75</mn><mo fence="true">]</mo></mrow><annotation encoding="application/x-tex">\left(0,15.75\right]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="minner"><span class="mopen delimcenter" style="top:0em;">(</span><span class="mord">0</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">1</span><span class="mord">5</span><span class="mord">.</span><span class="mord">7</span><span class="mord">5</span><span class="mclose delimcenter" style="top:0em;">]</span></span></span></span></span>……</p>
<p>范围会越来越小，但是每个人的红包都不大，都没有超过第一个人，因此第一个人是本次的运气王。</p>
<p>所以，其实这个算法这么看，貌似的确不那么公平，第一个人永远只能抢到二倍均值以下，也就是说，第一个人就是抢不到大红包，而越往后越<strong>有可能</strong>抢到大红包。</p>
<p>当然，运气王是有可能出现在任意的位置，运气王的位置靠前，则整体不会有很大的红包，运气王靠后的话，后面就有可能出现比前面大很多的红包。</p>
<p>那么这样的算法用代码如何实现呢？</p>
<p>Harris都给大家列出来了，如果感兴趣可以研究研究：</p>
<p>Java:</p>
<pre><code class="language-java">//代码来源于网络
//发红包算法，金额参数以分为单位
public static List&lt;Integer&gt; divideRedPackage(Integer totalAmount, Integer totalPeopleNum){
    List&lt;Integer&gt; amountList = new ArrayList&lt;Integer&gt;();
    Integer restAmount = totalAmount;
    Integer restPeopleNum = totalPeopleNum;
    Random random = new Random();
    for(int i=0; i&lt;totalPeopleNum-1; i++){
        //随机范围：[1，剩余人均金额的两倍)，左闭右开
        int amount = random.nextInt(restAmount / restPeopleNum * 2 - 1) + 1;
        restAmount -= amount;
        restPeopleNum --;
        amountList.add(amount);
    }
    amountList.add(restAmount);
    return amountList;
}
public static void main(String[] args){
    List&lt;Integer&gt; amountList = divideRedPackage(5000, 30);
    for(Integer amount : amountList){
        System.out.println(&quot;抢到金额：&quot; + new BigDecimal(amount).divide(new BigDecimal(100)));
    }
}
</code></pre>
<p>C/C++：</p>
<pre><code class="language-c">#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;

void money();
void money(double TotalAmount, int TotalPeople)
{
	double restAmount = TotalAmount;
	int restPeople = TotalPeople;
	for (int i = 0; i &lt; TotalPeople - 1; ++i)
	{
		int amount = rand() % ((int)((restAmount / restPeople) * 2) * 100);
		restAmount -= amount / 100;
		--restPeople;
		printf(&quot;抢到金额：%.2f\n&quot;, (double)amount / 100);
	}
	printf(&quot;抢到金额：%.2f\n&quot;, (double)restAmount / 100);
}

int main(void)
{
	money(50, 30);
	return 0;
}
</code></pre>
<p>Python：</p>
<pre><code class="language-python">import random
def money(TotalMoney,TotalPeople):
    restMoney = TotalMoney
    restPeople = TotalPeople
    for i in range(TotalPeople - 1):
        mount = round(random.uniform(0.01,(restMoney / restPeople) * 2 - 0.01),2)
        restMoney -= mount
        restPeople -= 1
        print(&quot;抢到金额：&quot;+str(mount))
    print(&quot;抢到金额：&quot;+str(round(restMoney,2)))

money(50,30)
</code></pre>
<p>本篇博客就到此结束了，其实生活中处处充满着知识，就看你有没有一颗爱钻研的心！</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[初识Python，多多关照]]></title>
        <id>https://harriswilde.github.io/post/PythonBasic</id>
        <link href="https://harriswilde.github.io/post/PythonBasic">
        </link>
        <updated>2020-01-14T02:27:02.000Z</updated>
        <content type="html"><![CDATA[<p>在开始之前，我们先来认识认识Python的一些基本信息。</p>
<p>在上一节里面，我们已经带大家安装好了Python的官方IDLE，并且教给大家了一个命令，那就是<code>print(&quot;新年快乐！&quot;)</code>，那么这节我们就来大致了解下Python以及利用Python进行的程序设计。</p>
<hr>
<h1 id="算法是什么">算法是什么</h1>
<p>在开始编程之前，我们先来了解下什么是<strong>计算机程序设计</strong>。简单地说，计算机虽然能够做很多事情，而且速度很快，但是它好像浑身冒着一股不太聪明的亚子，不太擅长自己思考。只有我们告诉它要干什么，它才会去给我们效力。那么，这样的话，我们设计程序的时候，就需要告诉计算机每一步该怎么做，那么这些步骤按照顺序编排起来，就称之为<code>算法</code>。因此算法没啥大不了，不过就是做事情的步骤罢了。比如我要煎牛排，但是我不知道怎么做，那么我去请一位师傅，他就会这样告诉我：</p>
<pre><code>准备好炊具，食材
把锅烧热
放入黄油
将牛排放入其中
将火候调整为适中
每30秒翻一次面
检查牛排表面，若颜色呈金黄有焦香，则盛出
若没有，则重复翻面步骤
</code></pre>
<p>这就是做牛排的一种算法。计算机就是这样，每一步的任何细节你都要告诉它，否则它就无法判断，就会罢工。比如把<code>每30秒翻一次面</code>改为<code>每隔一会儿翻一次面</code>的话，计算机就不会了。</p>
<h1 id="对象">对象</h1>
<p>正所谓，万物皆对象。在Python里面，一个数，一个字符(串)等等都属于对象。</p>
<h2 id="查看对象的地址">查看对象的地址</h2>
<p>具体的每一个常量在Python中都是一个对象。每个对象，在内存中都有一个自己的地址，这就是它的<strong>身份</strong>。我们想要知道它的地址，只需要使用<code>id()</code>函数即可。</p>
<pre><code class="language-python">&gt;&gt;&gt; id(4)
140705889218928
&gt;&gt;&gt; id(3.14)
1923954506000
&gt;&gt;&gt; id(&quot;a&quot;)
1923945858224
&gt;&gt;&gt; id(&quot;TechZone&quot;)
1923955766256
</code></pre>
<h2 id="查看对象类型">查看对象类型</h2>
<p>每一个对象也都有自己的<strong>类型</strong>，这是它们的种族。我们只需要使用函数<code>type()</code>就可以知道每一个对象的类型。</p>
<pre><code class="language-python">&gt;&gt;&gt; type(4)
&lt;class 'int'&gt;
&gt;&gt;&gt; type(3.14)
&lt;class 'float'&gt;
&gt;&gt;&gt; type(&quot;a&quot;)
&lt;class 'str'&gt;
&gt;&gt;&gt; type(&quot;TechZone&quot;)
&lt;class 'str'&gt;
</code></pre>
<h1 id="数与四则运算">数与四则运算</h1>
<p>在Python里面，支持4中类型的数，分别是<code>int(有符号整型)</code> <code>long(长整型)</code> <code>float(浮点型)</code> <code>complex(复数)</code>。</p>
<p>四则运算和我们平时使用的计算机差不多：<code>+加</code> <code>-减</code> <code>*乘</code> <code>/除</code>。</p>
<p>不过，除法还有一种，就是<code>//整除</code>。也就是<strong>取整除法</strong>。</p>
<pre><code class="language-python">&gt;&gt;&gt; 1+2
3
&gt;&gt;&gt; 33+54
87
&gt;&gt;&gt; 1-3
-2
&gt;&gt;&gt; 99*99
9801
&gt;&gt;&gt; 3/2
1.5
&gt;&gt;&gt; 3//2
1
</code></pre>
<h1 id="语句和语句块">语句和语句块</h1>
<p>Python和大部分的语言不同，就在于它的语句块是使用<strong>缩进</strong>来控制的，而<strong>不是</strong>使用大括号。并且语句的结束<strong>没有</strong>分号，不使用转行符<code>\</code>的情况下，回车就代表语句的结束。</p>
<p>比如下面的一个程序，我分别使用C++和Python来写。</p>
<p>C++：</p>
<pre><code class="language-c++">#include &lt;iostream&gt;
using namespace std;
 
int main (void)
{
   int a = 100;
 
   if( a &lt; 20 )
   {
       cout &lt;&lt; &quot;a 小于 20&quot; &lt;&lt; endl;
   }
   else
   {
       cout &lt;&lt; &quot;a 大于 20&quot; &lt;&lt; endl;
   }
   cout &lt;&lt; &quot;a 的值是 &quot; &lt;&lt; a &lt;&lt; endl;
 
   return 0;
}
</code></pre>
<p>Python：</p>
<pre><code class="language-python">a = int(100)
if a &lt; int(20):
    print(&quot;a小于20&quot;)
else:
    print(&quot;a大于20&quot;)
print(f&quot;a的值是{a}&quot;)
</code></pre>
<p>那么换行符<code>\</code>怎么用呢？看例子：</p>
<p>这是一行写完的：</p>
<pre><code class="language-python">...
total = item1 + item2 + item3
...
</code></pre>
<p>这是换行：</p>
<pre><code class="language-python">...
total = iten1 + \
iten2 + \
item3
...
</code></pre>
<h1 id="变量">变量</h1>
<p>如果你数学不好，也不用害怕。这里的变量，就是指的一个名字而已。比如：</p>
<pre><code class="language-python">score = int(100)
</code></pre>
<p>这里，我就把整数100赋值给了变量<code>score</code>，如果以后有改动，<code>score</code>还可以重新赋值，因此称之为变量。</p>
<p>变量的类型就是被赋值元素的类型，比如这里<code>score</code>的类型就是<code>int</code>。</p>
<p>变量的名称可以包含<strong>数字、字母和下划线</strong>。但是数字<strong>不能</strong>够作为变量名的开头。</p>
<h2 id="多变量赋值">多变量赋值</h2>
<p>Python里面赋值还有一种方法，就是多变量赋值，比如：</p>
<p>多个变量的值相同：</p>
<pre><code class="language-python">a = b = c = 1
</code></pre>
<p>多个变量的值不同：</p>
<pre><code class="language-python">a, b, c = 1, 2, &quot;TechZone&quot;
</code></pre>
<p>或者你还可以交换两个变量的值：</p>
<pre><code class="language-python">a, b = b, a
</code></pre>
<p>还是很方便的，对吧？</p>
<h1 id="注释">注释</h1>
<p>注释，简单来说就是写一些方便人类对代码阅读的一些提示性语言，但是解释器在运行的时候是<strong>不会</strong>去理会这些东西的。</p>
<h2 id="单行注释">单行注释</h2>
<p>单行注释用<code>#</code>号，也就是说，<code>#</code>号后面的任何文字，解释器都不会去理会。</p>
<pre><code class="language-python">...
print(&quot;Hello, world!&quot;) #输出Hello,world!
...
</code></pre>
<h2 id="多行注释">多行注释</h2>
<p>多行注释使用三引号，具体使用三个单引号或者三个双引号都可以。</p>
<pre><code class="language-python">'''
这是一个多行注释，
你可以在这里面长篇大论
写篇小说也是没有问题
'''
</code></pre>
<pre><code class="language-python">&quot;&quot;&quot;
这也是多行注释，
随便你用哪种，
喜欢就好
&quot;&quot;&quot;
</code></pre>
<p>当然，三引号的作用还有别的，我们以后再讲。</p>
<h1 id="python中的保留字">Python中的保留字</h1>
<p>这些保留字，不能够用于<strong>任何</strong>常量，变量和标识符名称。这些是Python自身语法要用的字，并且只包含<strong>小写</strong>。</p>
<blockquote>
<p>and, exec, not, assert, finally, or, break, for, pass, class, from, print, continue, global, raise, def, if, return, del, import, try, elif, in, while, else, is, with, except, lambda, yield.</p>
</blockquote>
<hr>
<p>初识Python，希望它的简洁和优雅能够给你带来舒适和快乐！</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[C语言之指针]]></title>
        <id>https://harriswilde.github.io/post/CPointer</id>
        <link href="https://harriswilde.github.io/post/CPointer">
        </link>
        <updated>2020-01-12T14:18:53.000Z</updated>
        <content type="html"><![CDATA[<p>说到指针，估计还是有很多小伙伴都还是云里雾里的，有点“知其然，而不知其所以然”。但是，不得不说，学了指针，C语言才能算是入门了。指针是C语言的<strong>精华</strong>，可以说，对对指针的掌握程度，<strong>直接决定</strong>了你C语言的编程能力。</p>
<hr>
<p>在讲指针之前，我们先来了解下变量在<strong>内存</strong>中是如何存放的。</p>
<p>在程序中定义一个变量，那么在程序编译的过程中，系统会根据你定义变量的类型来分配<strong>相应尺寸</strong>的内存空间。那么如果要使用这个变量，只需要用变量名去访问即可。</p>
<p>通过变量名来访问变量，是一种<strong>相对安全</strong>的方式。因为只有你定义了它，你才能够访问相应的变量。这就是对内存的基本认知。但是，如果光知道这一点的话，其实你还是不知道内存是如何存放变量的，因为底层是如何工作的，你依旧不清楚。</p>
<p>那么如果要继续深究的话，你就需要把变量在内存中真正的样子是什么搞清楚。内存的最小索引单元是<code>1字节</code>，那么你其实可以把内存比作一个超级大的<strong>字符型数组</strong>。在上一节我们讲过，数组是有下标的，我们是通过数组名和下标来访问数组中的元素。那么内存也是一样，只不过我们给它起了个新名字：<code>地址</code>。每个地址可以存放<strong>1字节</strong>的数据，所以如果我们需要定义一个整型变量，就需要占据4个内存单元。</p>
<p>那么，看到这里你可能就明白了：其实在程序运行的过程中，完全不需要变量名的参与。变量名只是方便我们进行代码的编写和阅读，只有程序员和编译器知道这个东西的存在。而编译器还知道具体的变量名对应的<strong>内存地址</strong>，这个是我们不知道的，因此编译器就像一个桥梁。当读取某一个变量的时候，编译器就会找到变量名所对应的地址，读取对应的值。</p>
<h1 id="初识指针和指针变量">初识指针和指针变量</h1>
<p>那么我们现在就来切入正题，指针是个什么东西呢？</p>
<p>所谓指针，就是内存地址（下文简称地址）。C语言中设立了专门的<strong>指针变量</strong>来存储指针，和<strong>普通变量</strong>不一样的是，指针变量存储的是<strong>地址</strong>。</p>
<h2 id="定义指针">定义指针</h2>
<p>指针变量也有类型，实际上取决于地址指向的值的类型。那么如何定义指针变量呢：</p>
<p>很简单：<code>类型名* 指针变量名</code></p>
<pre><code class="language-c">char* pa;//定义一个字符变量的指针，名称为pa
int* pb;//定义一个整型变量的指针，名称为pb
float* pc;//定义一个浮点型变量的指针，名称为pc
</code></pre>
<p>注意，指针变量一定要和指向的变量的类型一样，不然类型不同可能在内存中所占的位置不同，如果定义错了就可能导致出错。</p>
<h2 id="取地址运算符和取值运算符">取地址运算符和取值运算符</h2>
<p>获取某个变量的地址，使用取地址运算符<code>&amp;</code>，如：</p>
<pre><code class="language-c">char* pa = &amp;a;
int* pb = &amp;f;
</code></pre>
<p>如果反过来，你要访问指针变量指向的数据，那么你就要使用取值运算符<code>*</code>，如：</p>
<pre><code class="language-c">printf(&quot;%c, %d\n&quot;, *pa, *pb);
</code></pre>
<p>这里你可能发现，定义指针的时候也使用了<code>*</code>，这里属于符号的<strong>重用</strong>，也就是说这种符号在不同的地方就有不同的用意：在定义的时候表示<strong>定义一个指针变量</strong>，在其他的时候则用来<strong>获取指针变量指向的变量的值</strong>。</p>
<p>直接通过变量名来访问变量的值称之为<code>直接访问</code>，通过指针这样的形式访问称之为<code>间接访问</code>，因此取值运算符有时候也成为<strong>间接运算符</strong>。</p>
<p>比如：</p>
<pre><code class="language-c">//Example 01
//代码来源于网络，非个人原创
#include &lt;stdio.h&gt;
int main(void)
{
    char a = 'f';
    int f = 123;
    char* pa = &amp;a;
    int* pf = &amp;f;
    
    printf(&quot;a = %c\n&quot;, *pa);
    printf(&quot;f = %d\n&quot;, *pf);
    
    *pa = 'c';
    *pf += 1;
    
    printf(&quot;now, a = %c\n&quot;, *pa);
    printf(&quot;now, f = %d\n&quot;, *pf);
    
    printf(&quot;sizeof pa = %d\n&quot;, sizeof(pa));
    printf(&quot;sizeof pf = %d\n&quot;, sizeof(pf));
    
    printf(&quot;the addr of a is: %p\n&quot;, pa);
    printf(&quot;the addr of f is: %p\n&quot;, pf);
    
    return 0;
}
</code></pre>
<p>程序实现如下：</p>
<pre><code>//Consequence 01
a = f
f = 123
now, a = c
now, f = 124
sizeof pa = 4
sizeof pf = 4
the addr of a is: 00EFF97F
the addr of f is: 00EFF970
</code></pre>
<h2 id="避免访问未初始化的指针">避免访问未初始化的指针</h2>
<pre><code class="language-c">void f()
{
    int* a;
    *a = 10;
}
</code></pre>
<p>像这样的代码是十分危险的。因为指针a到底指向哪里，我们不知道。就和访问未初始化的普通变量一样，会返回一个<strong>随机值</strong>。但是如果是在指针里面，那么就有可能覆盖到<strong>其他的内存区域</strong>，甚至可能是系统正在使用的<strong>关键区域</strong>，十分危险。不过这种情况，系统一般会驳回程序的运行，此时程序会被<strong>中止</strong>并<strong>报错</strong>。要是万一中奖的话，覆盖到一个合法的地址，那么接下来的赋值就会导致一些有用的数据被<strong>莫名其妙地修改</strong>，这样的bug是十分不好排查的，因此使用指针的时候一定要注意初始化。</p>
<h1 id="指针和数组">指针和数组</h1>
<p>有些读者可能会有些奇怪，指针和数组又有什么关系？这俩货明明八竿子打不着井水不犯河水。别着急，接着往下看，你的观点有可能会改变。</p>
<h2 id="数组的地址">数组的地址</h2>
<p>我们刚刚说了，指针实际上就是变量在<strong>内存中的地址</strong>，那么如果有细心的小伙伴就可能会想到，像数组这样的一大摞变量的集合，它的地址是啥呢？</p>
<p>我们知道，从标准输入流中读取一个值到变量中，用的是<code>scanf</code>函数，一般貌似在后面都要加上<code>&amp;</code>，这个其实就是我们刚刚说的<strong>取地址运算符</strong>。如果你存储的位置是指针变量的话，那就不需要。</p>
<pre><code class="language-c">//Example 02
int main(void)
{
    int a;
    int* p = &amp;a;
    
    printf(&quot;请输入一个整数：&quot;);
    scanf(&quot;%d&quot;, &amp;a);//此处需要&amp;
    printf(&quot;a = %d\n&quot;, a);
    
    printf(&quot;请再输入一个整数：&quot;);
    scanf(&quot;%d&quot;, p);//此处不需要&amp;
    printf(&quot;a = %d\n&quot;, a);
    
    return 0;
}
</code></pre>
<p>程序运行如下：</p>
<pre><code>//Consequence 02
请输入一个整数：1
a = 1
请再输入一个整数：2
a = 2
</code></pre>
<p>在普通变量读取的时候，程序需要知道这个变量在内存中的地址，因此需要<code>&amp;</code>来取地址完成这个任务。而对于指针变量来说，本身就是<strong>另外一个</strong>普通变量的<strong>地址信息</strong>，因此直接给出指针的值就可以了。</p>
<p>试想一下，我们在使用<code>scanf</code>函数的时候，是不是也有不需要使用<code>&amp;</code>的时候？就是在读取<strong>字符串</strong>的时候：</p>
<pre><code class="language-c">//Example 03
#include &lt;stdio.h&gt;
int main(void)
{
    char url[100];
    url[99] = '\0';
    printf(&quot;请输入TechZone的域名：&quot;);
    scanf(&quot;%s&quot;, url);//此处也不用&amp;
    printf(&quot;你输入的域名是：%s\n&quot;, url);
    return 0;
}
</code></pre>
<p>程序执行如下：</p>
<pre><code>//Consequence 03
请输入TechZone的域名：www.techzone.ltd
你输入的域名是：www.techzone.ltd
</code></pre>
<p>因此很好推理：数组名其实就是一个<strong>地址信息</strong>，实际上就是数组<strong>第一个元素的地址</strong>。咱们试试把第一个元素的地址和数组的地址做个对比就知道了：</p>
<pre><code class="language-c">//Example 03 V2
#include &lt;stdio.h&gt;
int main(void)
{
    char url[100];
    printf(&quot;请输入TechZone的域名：&quot;);
    url[99] = '\0';
    scanf(&quot;%s&quot;, url);
    printf(&quot;你输入的域名是：%s\n&quot;, url);

    printf(&quot;url的地址为：%p\n&quot;, url);
    printf(&quot;url[0]的地址为：%p\n&quot;, &amp;url[0]);

    if (url == &amp;url[0])
    {
        printf(&quot;两者一致！&quot;);
    }
    else
    {
        printf(&quot;两者不一致！&quot;);
    }
    return 0;
}
</code></pre>
<p>程序运行结果为：</p>
<pre><code>//Comsequense 03 V2
请输入TechZone的域名：www.techzone.ltd
你输入的域名是：www.techzone.ltd
url的地址为：0063F804
url[0]的地址为：0063F804
两者一致！
</code></pre>
<p>这么看，应该是实锤了。那么数组后面的元素也就是依次往后放置，有兴趣的也可以自己写代码尝试把它们输出看看。</p>
<h2 id="指向数组的指针">指向数组的指针</h2>
<p>刚刚我们验证了数组的地址就是数组第一个元素的地址。那么指向数组的指针自然也就有两种定义的方法：</p>
<pre><code class="language-c">...
char* p;
//方法1
p = a;
//方法2
p = &amp;a[0];
</code></pre>
<h2 id="指针的运算">指针的运算</h2>
<p>当指针指向数组元素的时候，可以对指针变量进行<strong>加减</strong>运算，<code>+n</code>表示指向p指针所指向的元素的<strong>下n个元素</strong>，<code>-n</code>表示指向p指针所指向的元素的<strong>上n个元素</strong>。并不是将地址加1。</p>
<p>如：</p>
<pre><code class="language-c">//Example 04
#include &lt;stdio.h&gt;
int main(void)
{
    int a[] = { 1,2,3,4,5 };
    int* p = a;
    printf(&quot;*p = %d, *(p+1) = %d, *(p+2) = %d\n&quot;, *p, *(p + 1), *(p + 2));
    printf(&quot;*p -&gt; %p, *(p+1) -&gt; %p, *(p+2) -&gt; %p\n&quot;, p, p + 1, p + 2);
    return 0;
}
</code></pre>
<p>执行结果如下：</p>
<pre><code>//Consequence 04
*p = 1, *(p+1) = 2, *(p+2) = 3
*p -&gt; 00AFF838, *(p+1) -&gt; 00AFF83C, *(p+2) -&gt; 00AFF840
</code></pre>
<p>有的小伙伴可能会想，编译器是怎么知道访问下一个元素而不是地址直接加1呢？</p>
<p>其实就在我们定义指针变量的时候，就已经告诉编译器了。如果我们定义的是整型数组的指针，那么指针加1，实际上就是加上一个<code>sizeof(int)</code>的距离。相对于标准的下标访问，使用指针来间接访问数组元素的方法叫做<code>指针法</code>。</p>
<p>其实使用指针法来访问数组的元素，不一定需要定义一个指向数组的单独的指针变量，因为数组名自身就是指向数组<strong>第一个元素</strong>的指针，因此指针法可以直接作用于数组名：</p>
<pre><code class="language-c">...
printf(&quot;p -&gt; %p, p+1 -&gt; %p, p+2 -&gt; %p\n&quot;, a, a+1, a+2);
printf(&quot;a = %d, a+1 = %d, a+2 = %d&quot;, *a, *(a+1), *(a+2));
...
</code></pre>
<p>执行结果如下：</p>
<pre><code class="language-c">p -&gt; 00AFF838, p+1 -&gt; 00AFF83C, p+2 -&gt; 00AFF840
b = 1, b+1 = 2, b+2 = 3
</code></pre>
<p>现在你是不是感觉，数组和指针有点像了呢？不过笔者先提醒，数组和指针虽然非常像，但是绝对<strong>不是</strong>       一种东西。</p>
<p>甚至你还可以直接用指针来定义字符串，然后用下标法来读取每一个元素：</p>
<pre><code class="language-c">//Example 05
//代码来源于网络
#include &lt;stdio.h&gt;
#include &lt;string.h&gt;
int main(void)
{
    char* str = &quot;I love TechZone!&quot;;
    int i, length;
    
    length = strlen(str);
    
    for (i = 0; i &lt; length, i++)
    {
        printf(&quot;%c&quot;, str[i]);
    }
    printf(&quot;\n&quot;);
    
    return 0;
}
</code></pre>
<p>程序运行如下：</p>
<pre><code>//Consequence 05
I love TechZone!
</code></pre>
<p>在刚刚的代码里面，我们定义了一个<strong>字符指针</strong>变量，并且初始化成指向一个字符串。后来的操作，不仅在它身上可以使用<strong>字符串处理函数</strong>，还可以用<strong>下标法</strong>访问字符串中的每一个字符。</p>
<p>当然，循环部分这样写也是没毛病的：</p>
<pre><code class="language-c">...
for (i = 0, i &lt; length, i++)
{
    printf(&quot;%c&quot;, *(str + i));
}
</code></pre>
<p>这就相当于利用了指针法来读取。</p>
<h2 id="指针和数组的区别">指针和数组的区别</h2>
<p>刚刚说了许多指针和数组相互替换的例子，可能有的小伙伴又开始说：“这俩货不就是一个东西吗？”</p>
<p>随着你对指针和数组越来越了解，你会发现，C语言的创始人不会这么无聊去创建两种一样的东西，还叫上不同的名字。指针和数组终究是<strong>不一样</strong>的。</p>
<p>比如笔者之前看过的一个例子：</p>
<pre><code class="language-c">//Example 06
//代码来源于网络
#include &lt;stdio.h&gt;
int main(void)
{
    char str[] = &quot;I love TechZone!&quot;;
    int count = 0;
    
    while (*str++ != '\0')
    {
        count++;
    }
    printf(&quot;总共有%d个字符。\n&quot;, count);
    
    return 0;
}
</code></pre>
<p>当编译器报错的时候，你可能会开始怀疑你学了假的C语言语法：</p>
<pre><code>//Error in Example 06
错误(活动)	E0137	表达式必须是可修改的左值
错误	C2105	“++”需要左值
</code></pre>
<p>我们知道，<code>*str++ != ‘\0’</code>是一个复合表达式，那么就要遵循<strong>运算符优先级</strong>来看。具体可以回顾<a href="http://www.techzone.ltd/post/COperatorASCII/">《C语言运算符优先级及ASCII对照表》</a>。</p>
<p><code>str++</code>比<code>*str</code>的优先级<strong>更高</strong>，但是自增运算符要在<strong>下一条语句</strong>的时候才能生效。所以这个语句的理解就是，先取出<code>str</code>所指向的值，判断是否为<code>\0</code>，若是，则跳出循环，然后<code>str</code>指向下一个字符的位置。</p>
<p>看上去貌似没啥毛病，但是，看看编译器告诉我们的东西：<code>表达式必须是可修改的左值</code></p>
<p><code>++</code>的操作对象是<code>str</code>，那么<code>str</code>到底是不是<strong>左值</strong>呢？</p>
<p>如果是左值的话，那么就必须满足左值的条件。</p>
<blockquote>
<ol>
<li>拥有用于识别和定位一个存储位置的标识符</li>
<li>存储值可修改</li>
</ol>
</blockquote>
<p>第一点，数组名<code>str</code>是可以满足的，因为数组名实际上就是定位数组第一个元素的位置。但是第二点就不满足了，数组名实际上是一个地址，地址是<strong>不可以</strong>修改的，它是一个常量。如果非要利用上面的思路来实现的话，可以将代码改成这样：</p>
<pre><code class="language-c">//Example 06 V2
//代码来源于网络
#include &lt;stdio.h&gt;
int main(void)
{
    char str[] = &quot;I love TechZone!&quot;;
    char* target = str;
    int count = 0;
    
    while (*target++ != '\0')
    {
        count++;
    }
    printf(&quot;总共有%d个字符。\n&quot;, count);
    
    return 0;
}
</code></pre>
<p>这样就可以正常执行了：</p>
<pre><code>//Consequence 06 V2
总共有16个字符。
</code></pre>
<p>这样我们就可以得出：数组名只是一个<strong>地址</strong>，而指针是一个<strong>左值</strong>。</p>
<h2 id="指针数组数组指针">指针数组？数组指针？</h2>
<p>看下面的例子，你能分辨出哪个是指针数组，哪个是数组指针吗？</p>
<pre><code class="language-c">int* p1[5];
int(*p2)[5];
</code></pre>
<p>单个的我们都可以判断，但是组合起来就有些难度了。</p>
<p>答案：</p>
<pre><code class="language-c">int* p1[5];//指针数组
int(*p2)[5];//数组指针
</code></pre>
<p>我们挨个来分析。</p>
<h3 id="指针数组">指针数组</h3>
<p>数组下标<code>[]</code>的优先级是最高的，因此<code>p1</code>是一个有5个元素的<strong>数组</strong>。那么这个数组的类型是什么呢？答案就是<code>int*</code>，是<strong>指向整型变量的指针</strong>。因此这是一个<strong>指针数组</strong>。</p>
<p>那么这样的数组应该怎么样去初始化呢？</p>
<p>你可以定义5个变量，然后挨个取地址来初始化。</p>
<p>不过这样太繁琐了，但是，并不是说指针数组就没什么用。</p>
<p>比如：</p>
<pre><code class="language-c">//Example 07
#include &lt;stdio.h&gt;
int main(void)
{
    char* p1[5] = {
        &quot;人生苦短，我用Python。&quot;,
        &quot;PHP是世界上最好的语言！&quot;,
        &quot;One more thing...&quot;,
        &quot;一个好的程序员应该是那种过单行线都要往两边看的人。&quot;,
        &quot;C语言很容易让你犯错误；C++看起来好一些，但当你用它时，你会发现会死的更惨。&quot;
    };
    int i;
    for (i = 0; i &lt; 5; i++)
    {
        printf(&quot;%s\n&quot;, p1[i]);
    }
    return 0;
}
</code></pre>
<p>结果如下：</p>
<pre><code>//Consequence 07
人生苦短，我用Python。
PHP是世界上最好的语言！
One more thing...
一个好的程序员应该是那种过单行线都要往两边看的人。
C语言很容易让你犯错误；C++看起来好一些，但当你用它时，你会发现会死的更惨。
</code></pre>
<p>这样是不是比二维数组来的更加直接更加通俗呢？</p>
<h3 id="数组指针">数组指针</h3>
<p><code>()</code>和<code>[]</code>在优先级里面属于<strong>同级</strong>，那么就按照<strong>先后顺序</strong>进行。</p>
<p><code>int(*p2)</code>将<code>p2</code>定义为<strong>指针</strong>， 后面跟随着一个5个元素的<strong>数组</strong>，<code>p2</code>就指向这个数组。因此，数组指针是一个<strong>指针</strong>，它指向的是一个数组。</p>
<p>但是，如果想对数组指针初始化的时候，千万要小心，比如：</p>
<pre><code class="language-c">//Example 08
#include &lt;stdio.h&gt;
int main(void)
{
    int(*p2)[5] = {1, 2, 3, 4, 5};
    int i;
    for (i = 0; i &lt; 5; i++)
    {
        printf(&quot;%d\n&quot;, *(p2 + i));
    }
    return 0;
}
</code></pre>
<p>Visual Studio 2019报出以下的错误：</p>
<pre><code>//Error and Warning in Example 08
错误(活动)	E0146	初始值设定项值太多
错误	C2440	“初始化”: 无法从“initializer list”转换为“int (*)[5]”
警告	C4477	“printf”: 格式字符串“%d”需要类型“int”的参数，但可变参数 1 拥有了类型“int *”
</code></pre>
<p>这其实是一个非常典型的错误使用指针的案例，编译器提示说这里有一个<strong>整数</strong>赋值给<strong>指针变量</strong>的问题，因为<code>p2</code>归根结底还是指针，所以应该给它传递一个<strong>地址</strong>才行，更改一下：</p>
<pre><code class="language-c">//Example 08 V2
#include &lt;stdio.h&gt;
int main(void)
{
    int temp[5] = {1, 2, 3, 4, 5};
    int(*p2)[5] = temp;
    int i;
    for (i = 0; i &lt; 5; i++)
    {
        printf(&quot;%d\n&quot;, *(p2 + i));
    }
    return 0;
}
</code></pre>
<pre><code>//Error and Warning in Example 08 V2
错误(活动)	E0144	&quot;int *&quot; 类型的值不能用于初始化 &quot;int (*)[5]&quot; 类型的实体
错误	C2440	“初始化”: 无法从“int [5]”转换为“int (*)[5]”
警告	C4477	“printf”: 格式字符串“%d”需要类型“int”的参数，但可变参数 1 拥有了类型“int *”
</code></pre>
<p>可是怎么还是有问题呢？</p>
<p>我们回顾一下，指针是如何指向数组的。</p>
<pre><code class="language-c">int temp[5] = {1, 2, 3, 4, 5};
int* p = temp;
</code></pre>
<p>我们原本以为，指针<code>p</code>是指向数组的指针，但是实际上<strong>并不是</strong>。仔细想想就会发现，这个指针实际上是指向的数组的<strong>第一个元素</strong>，而不是指向数组。因为数组里面的元素在内存中都是挨着个儿存放的，因此只需要知道第一个元素的地址，就可以访问到后面的所有元素。</p>
<p>但是，这么来看的话，指针<code>p</code>指向的就是一个<strong>整型变量</strong>的指针，并不是指向<strong>数组</strong>的指针。而刚刚我们用的数组指针，才是指向数组的指针。因此，应该将<strong>数组的地址</strong>传递给数组指针，而不是将第一个元素的地址传入，尽管它们值相同，但是<strong>含义</strong>确实不一样：</p>
<pre><code class="language-c">//Example 08 V3
//Example 08 V2
#include &lt;stdio.h&gt;
int main(void)
{
    int temp[5] = {1, 2, 3, 4, 5};
    int(*p2)[5] = &amp;temp;//此处取地址
    int i;
    for (i = 0; i &lt; 5; i++)
    {
        printf(&quot;%d\n&quot;, *(*p2 + i));
    }
    return 0;
}
</code></pre>
<p>程序运行如下：</p>
<pre><code>//Consequence 08
1
2
3
4
5
</code></pre>
<h2 id="指针和二维数组">指针和二维数组</h2>
<p>在上一节<a href="http://www.techzone.ltd/post/CArray/">《C语言之数组》</a>我们讲过<strong>二维数组</strong>的概念，并且我们也知道，C语言的二维数组其实在内存中也是<strong>线性存放</strong>的。</p>
<p>假设我们定义了：<code>int array[4][5]</code></p>
<h3 id="array">array</h3>
<p>array作为数组的名称，显然应该表示的是数组的<strong>首地址</strong>。由于二维数组实际上就是一维数组的<strong>线性拓展</strong>，因此array应该就是指的<code>指向包含5个元素的数组的指针</code>。</p>
<p>如果你用<code>sizeof()</code>去测试<code>array</code>和<code>array+1</code>的话，就可以测试出来这样的结论。</p>
<h3 id="array1">*(array+1)</h3>
<p>首先从刚刚的问题我们可以得出，<code>array+1</code>同样也是指的<code>指向包含5个元素的数组的指针</code>，因此<code>*(array+1)</code>就是相当于<code>array[1]</code>，而这刚好相当于<code>array[1][0]</code>的数组名。因此<code>*(array+1)</code>就是指第二行子数组的第一个元素的地址。</p>
<h3 id="array12">*(*(array+1)+2)</h3>
<p>有了刚刚的结论，我们就不难推理出，这个实际上就是<code>array[1][2]</code>。是不是感觉非常简单呢？</p>
<p>总结一下，就是下面的这些结论，记住就好，理解那当然更好：</p>
<pre><code class="language-c">*(array + i) == array[i]
*(*(array + i) + j) == array[i][j]
*(*(*(array + i) + j) + k) == array[i][j][k]
...
</code></pre>
<h2 id="数组指针和二维数组">数组指针和二维数组</h2>
<p>我们在上一节里面讲过，在初始化二维数组的时候是可以偷懒的：</p>
<pre><code class="language-C">int array[][3] = {
    {1, 2, 3},
    {4, 5, 6}
};
</code></pre>
<p>刚刚我们又说过，定义一个数组指针是这样的：</p>
<pre><code class="language-c">int(*p)[3];
</code></pre>
<p>那么组合起来是什么意思呢？</p>
<pre><code class="language-c">int(*p)[3] = array;
</code></pre>
<p>通过刚刚的说明，我们可以知道，<code>array</code>是指向一个3个元素的数组的<strong>指针</strong>，所以这里完全可以将<code>array</code>的值赋值给<code>p</code>。</p>
<p>其实C语言的指针非常灵活，同样的代码用不同的角度去解读，就可以有不同的应用。</p>
<p>那么如何使用指针来访问二维数组呢？没错，就是使用<strong>数组指针</strong>：</p>
<pre><code class="language-c">//Example 09
#include &lt;stdio.h&gt;
int main(void)
{
    int array[3][4] = {
        {0, 1, 2, 3},
        {4, 5, 6, 7},
        {8, 9, 10, 11}
    };
    int(*p)[4];
    int i, j;
    p = array;
    for (i = 0, i &lt; 3, i++)
    {
        for (j = 0, j &lt; 4, j++)
        {
            printf(&quot;%2d &quot;, *(*(p+i) + j)); 
        }
        printf(&quot;\n&quot;);
    }
    return 0;
}
</code></pre>
<p>运行结果：</p>
<pre><code>//Consequence 09
0 1 2 3 
4 5 6 7 
8 9 10 11 
</code></pre>
<h1 id="void指针">void指针</h1>
<p><code>void</code>实际上是<code>无类型</code>的意思。如果你尝试用它来定义一个变量，编译器肯定会<strong>报错</strong>，因为不同类型所占用的内存有可能<strong>不一样</strong>。但是如果定义的是一个指针，那就没问题。<code>void</code>类型中指针可以指向<strong>任何一个类型</strong>的数据，也就是说，任何类型的指针都可以赋值给<code>void</code>指针。</p>
<p>将任何类型的指针转换为<code>void</code>是没有问题的。但是如果你要反过来，那就需要<strong>强制类型转换</strong>。此外，不要对<code>void</code>指针<strong>直接解引用</strong>，因为编译器其实并不知道<code>void</code>指针会存放什么样的类型。</p>
<pre><code class="language-c">//Example 10
#include &lt;stdio.h&gt;
int main(void)
{
    int num = 1024;
    int* pi = &amp;num;
    char* ps = &quot;TechZone&quot;;
    void* pv;
    
    pv = pi;
    printf(&quot;pi:%p,pv:%p\n&quot;, pi, pv);
    printf(&quot;*pv:%d\n&quot;, *pv);
    
    pv = ps;
    printf(&quot;ps:%p,pv:%p\n&quot;, ps, pv);
    printf(&quot;*pv:%s\n&quot;, *pv);
}
</code></pre>
<p>这样会报错：</p>
<pre><code>//Error in Example 10
错误	C2100	非法的间接寻址
错误	C2100	非法的间接寻址
</code></pre>
<p>如果一定要这么做，那么可以用<strong>强制类型转换</strong>：</p>
<pre><code class="language-c">//Example 10 V2
#include &lt;stdio.h&gt;
int main(void)
{
    int num = 1024;
    int* pi = &amp;num;
    char* ps = &quot;TechZone&quot;;
    void* pv;

    pv = pi;
    printf(&quot;pi:%p,pv:%p\n&quot;, pi, pv);
    printf(&quot;*pv:%d\n&quot;, *(int*)pv);

    pv = ps;
    printf(&quot;ps:%p,pv:%p\n&quot;, ps, pv);
    printf(&quot;*pv:%s\n&quot;, pv);
}
</code></pre>
<p>当然，使用void指针一定要小心，由于void指针几乎可以<strong>通吃</strong>所有类型，所以间接使得不同类型的指针转换变得合法，如果代码中存在不合理的转换，编译器也不会报错。</p>
<p>因此，void指针能不用则不用，后面讲函数的时候，还可以解锁更多新的玩法。</p>
<h1 id="null指针">NULL指针</h1>
<p>在C语言中，如果一个指针不指向任何数据，那么就称之为<strong>空指针</strong>，用<strong>NULL</strong>来表示。NULL其实是一个宏定义：</p>
<pre><code class="language-c">#define NULL ((void *)0)
</code></pre>
<p>在大部分的操作系统中，地址0通常是一个<strong>不被使用</strong>的地址，所以如果一个指针指向NULL，就意味着不指向任何东西。为什么一个指针要指向NULL呢？</p>
<p>其实这反而是一种比较指的推荐的<strong>编程风格</strong>——当你暂时还不知道该指向哪儿的时候，就让它指向NULL，以后不会有太多的麻烦，比如：</p>
<pre><code class="language-c">//Example 11
#include &lt;stdio.h&gt;
int main(void)
{
    int* p1;
    int* p2 = NULL;
    printf(&quot;%d\n&quot;, *p1);
    printf(&quot;%d\n&quot;, *p2);
    return 0;
}
</code></pre>
<p>第一个指针未被初始化。在有的编译器里面，这样未初始化的变量就会被赋予<strong>随机值</strong>。这样指针被称为<strong>迷途指针</strong>，<strong>野指针</strong>或者<strong>悬空指针</strong>。如果后面的代码对这类指针解引用，而这个地址又刚好是合法的话，那么就会产生莫名其妙的结果，甚至导致程序的崩溃。因此养成良好的习惯，在暂时不清楚的情况下使用NULL，可以节省大量的后期调试的时间。</p>
<h1 id="指向指针的指针">指向指针的指针</h1>
<p>开始套娃了。其实只要你理解了指针的概念，也就没什么大不了的。</p>
<pre><code class="language-c">//Example 12
#include &lt;stdio.h&gt;
int main(void)
{
    int num = 1;
    int* p = &amp;num;
    int** pp = &amp;p;
    
    printf(&quot;num: %d\n&quot;, num);
    printf(&quot;*p: %d\n&quot;, *p);
    printf(&quot;**p: %d\n&quot;, **pp);
    printf(&quot;&amp;p: %p, pp: %p\n&quot;, &amp;p, pp);
    printf(&quot;&amp;num: %p, p: %p, *pp: %p\n&quot;, &amp;num, p, *pp);
    return 0;
}
</code></pre>
<p>程序结果如下：</p>
<pre><code>//Consequence 12
num: 1
*p: 1
**p: 1
&amp;p: 004FF960, pp: 004FF960
&amp;num: 004FF96C, p: 004FF96C, *pp: 004FF96C
</code></pre>
<p>当然你也可以无限地套娃，一直指下去。不过这样会让代码可读性变得<strong>很差</strong>，过段时间可能你自己都看不懂你写的代码了。</p>
<h1 id="指针数组和指向指针的指针">指针数组和指向指针的指针</h1>
<p>那么，指向指针的指针有什么用呢？</p>
<p>它可不是为了去创造混乱代码，在一个经典的实例里面，就可以体会到它的用处：</p>
<pre><code class="language-c">char* Books[] = {
    &quot;《C专家编程》&quot;,
    &quot;《C和指针》&quot;,
    &quot;《C的陷阱与缺陷》&quot;,
    &quot;《C Primer Plus》&quot;,
    &quot;《Python基础教程（第三版）》&quot;
};
</code></pre>
<p>然后我们需要将这些书进行分类。我们发现，其中有一本是写Python的，其他都是C语言的。这时候指向指针的指针就派上用场了。首先，我们刚刚定义了一个指针数组，也就是说，里面的所有元素的类型<strong>都是指针</strong>，而数组名却又可以用指针的形式来<strong>访问</strong>，因此就可以使用<strong>指向指针的指针</strong>来指向指针数组：</p>
<pre><code class="language-c">...
char** Python;
char** CLang[4];

Python = &amp;Books[5];
CLang[0] = &amp;Books[0];
CLang[1] = &amp;Books[1];
CLang[2] = &amp;Books[2];
CLang[3] = &amp;Books[3];
...
</code></pre>
<p>因为字符串的取地址值实际上就是其<strong>首地址</strong>，也就是一个<strong>指向字符指针的指针</strong>，所以可以这样赋值。</p>
<p>这样，我们就利用指向指针的指针完成了对书籍的分类，这样既避免了浪费多余的内存，而且当其中的书名要修改，只需要改一次即可，代码的灵活性和安全性都得到了提升。</p>
<h1 id="常量和指针">常量和指针</h1>
<p>常量，在我们目前的认知里面，应该是这样的：</p>
<pre><code>520, 'a'
</code></pre>
<p>或者是这样的：</p>
<pre><code class="language-c">#define MAX 1000
#define B 'b'
</code></pre>
<p>常量和变量最大的区别，就是前者<strong>不能够被修改</strong>，后者可以。那么在C语言中，可以将变量变成像具有常量一样的特性，利用<code>const</code>即可。</p>
<pre><code class="language-c">const int max = 1000;
const char a = 'a';
</code></pre>
<p>在<code>const</code>关键字的作用下，变量就会<strong>失去</strong>本来具有的可修改的特性，变成“只读”的属性。</p>
<h1 id="指向常量的指针">指向常量的指针</h1>
<p>强大的指针当然也是可以指向被<code>const</code>修饰过的变量，但这就意味着<strong>不能通过</strong>指针来修改它所引用的值。总结一下，就是以下4点：</p>
<blockquote>
<ol>
<li>指针可以修改为指向不同的变量</li>
<li>指针可以修改为指向不同的常量</li>
<li>可以通过解引用来读取指针指向的数据</li>
<li>不可以通过解引用来修改指针指向的数据</li>
</ol>
</blockquote>
<h1 id="常量指针">常量指针</h1>
<h2 id="指向非常量的常量指针">指向非常量的常量指针</h2>
<p>指针本身作为一种<strong>变量</strong>，也是可以修改的。因此，指针也是可以被<code>const</code>修饰的，只不过位置稍稍<strong>发生了点变化</strong>：</p>
<pre><code class="language-c">...
int* const p = &amp;num;
...
</code></pre>
<p>这样的指针有如下的特性：</p>
<blockquote>
<ol>
<li>指针自身不能够被修改</li>
<li>指针指向的值可以被修改</li>
</ol>
</blockquote>
<h2 id="指向常量的常量指针">指向常量的常量指针</h2>
<p>在定义普通变量的时候也用<code>const</code>修饰，就得到了这样的指针。不过由于限制太多，一般很少用到：</p>
<pre><code class="language-c">...
int num = 100;
const int cnum = 200;
const int* const p = &amp;cnum;
...
</code></pre>
<hr>
<p>这期博客就到此结束了，没学会的反复咀嚼，学会了的自己去实战，相信你的C语言编程能力会越来越强。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[积分变限函数的求导方法]]></title>
        <id>https://harriswilde.github.io/post/P-CkgTjqZ</id>
        <link href="https://harriswilde.github.io/post/P-CkgTjqZ">
        </link>
        <updated>2020-01-01T14:24:10.000Z</updated>
        <content type="html"><![CDATA[<p>所谓<strong>积分变限函数</strong>，就是<s>能够将你所学知识变现的函数</s> 在积分的上下限中加入了一个函数。由于函数的值在自变量不同的时候也不同，因此这个上下限也是不定的，故曰此名。</p>
<p>那么，这样的积分函数是不是就没法求了呢？就这么点难度怎么可能难得住咱们勤劳有智慧的人们呢？下面就来看看，这种阴险狡诈的积分函数到底怎么求。</p>
<hr>
<p>积分变限函数一般分为3种：<strong>仅上限为函数</strong>、<strong>仅下限为函数</strong>和<strong>上下限都为函数</strong>。</p>
<p>我们挨个来看看。</p>
<h1 id="仅上限为函数">仅上限为函数</h1>
<p>这种情况下，只需要把上限函数带入到被积函数里面去即可。如：</p>
<p class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>y</mi><mo>=</mo><msubsup><mo>∫</mo><mi>a</mi><mrow><mi>f</mi><mo>(</mo><mi>x</mi><mo>)</mo></mrow></msubsup><mi>g</mi><mo>(</mo><mi>t</mi><mo>)</mo><mtext> </mtext><mi mathvariant="normal">d</mi><mi>t</mi><mo>⇒</mo><msup><mi>y</mi><mo mathvariant="normal">′</mo></msup><mo>=</mo><mi>g</mi><mo fence="false">(</mo><mi>f</mi><mo>(</mo><mi>x</mi><mo>)</mo><mo fence="false">)</mo><mtext> </mtext><mi mathvariant="normal">d</mi><msup><mi>f</mi><mo mathvariant="normal">′</mo></msup><mo>(</mo><mi>x</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">y=\int_{a}^{f(x)} g(t)\,{\rm d}t\Rightarrow y^\prime=g\big(f(x)\big)\,{\rm d}f^\prime(x)
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">y</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:2.54985em;vertical-align:-0.9119499999999999em;"></span><span class="mop"><span class="mop op-symbol large-op" style="margin-right:0.44445em;position:relative;top:-0.0011249999999999316em;">∫</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.6379000000000001em;"><span style="top:-1.7880500000000001em;margin-left:-0.44445em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">a</span></span></span></span><span style="top:-3.8129em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.10764em;">f</span><span class="mopen mtight">(</span><span class="mord mathdefault mtight">x</span><span class="mclose mtight">)</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.9119499999999999em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="mopen">(</span><span class="mord mathdefault">t</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord"><span class="mord mathrm">d</span></span></span><span class="mord mathdefault">t</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">⇒</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.996332em;vertical-align:-0.19444em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03588em;">y</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.801892em;"><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">′</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1.20001em;vertical-align:-0.35001em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="mord"><span class="delimsizing size1">(</span></span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mopen">(</span><span class="mord mathdefault">x</span><span class="mclose">)</span><span class="mord"><span class="delimsizing size1">)</span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord"><span class="mord mathrm">d</span></span></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.801892em;"><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">′</span></span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord mathdefault">x</span><span class="mclose">)</span></span></span></span></span></p>
<p>比如像下面这个函数，咱们来试试：</p>
<p class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mtable><mtr><mtd><mstyle scriptlevel="0" displaystyle="true"><mi>y</mi></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="true"><mrow><mrow></mrow><mo>=</mo><msubsup><mo>∫</mo><mn>1</mn><msup><mi>x</mi><mn>2</mn></msup></msubsup><msup><mi>e</mi><msup><mi>t</mi><mn>2</mn></msup></msup><mi mathvariant="normal">d</mi><mi>t</mi></mrow></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="true"><mrow><mo>⇒</mo><msup><mi>y</mi><mo mathvariant="normal">′</mo></msup></mrow></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="true"><mrow><mrow></mrow><mo>=</mo><msup><mi>e</mi><mrow><mo>(</mo><msup><mi>x</mi><mn>2</mn></msup><msup><mo>)</mo><mn>2</mn></msup></mrow></msup><mi mathvariant="normal">d</mi><msup><mi>x</mi><mn>2</mn></msup><mo>=</mo><mn>2</mn><mi>x</mi><mo>⋅</mo><msup><mi>e</mi><msup><mi>x</mi><mn>4</mn></msup></msup></mrow></mstyle></mtd></mtr></mtable><annotation encoding="application/x-tex">\begin{aligned}
y&amp;=\int^{x^2}_1 e^{t^2}{\rm d}t\\
\Rightarrow y^\prime&amp;=e^{(x^2)^2}{\rm d}x^2=2x\cdot e^{x^4}
\end{aligned}
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:4.64569em;vertical-align:-2.072845em;"></span><span class="mord"><span class="mtable"><span class="col-align-r"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:2.572845em;"><span style="top:-4.572845em;"><span class="pstrut" style="height:3.7368200000000003em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03588em;">y</span></span></span><span style="top:-2.3239750000000003em;"><span class="pstrut" style="height:3.7368200000000003em;"></span><span class="mord"><span class="mrel">⇒</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03588em;">y</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.801892em;"><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">′</span></span></span></span></span></span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:2.072845em;"><span></span></span></span></span></span><span class="col-align-l"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:2.572845em;"><span style="top:-4.572845em;"><span class="pstrut" style="height:3.7368200000000003em;"></span><span class="mord"><span class="mord"></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mop"><span class="mop op-symbol large-op" style="margin-right:0.44445em;position:relative;top:-0.0011249999999999316em;">∫</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.7368200000000003em;"><span style="top:-1.7880500000000001em;margin-left:-0.44445em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span><span style="top:-3.8129000000000004em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight"><span class="mord mathdefault mtight">x</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8913142857142857em;"><span style="top:-2.931em;margin-right:0.07142857142857144em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.9119499999999999em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault">e</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:1.0369199999999998em;"><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight"><span class="mord mathdefault mtight">t</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8913142857142857em;"><span style="top:-2.931em;margin-right:0.07142857142857144em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span><span class="mord"><span class="mord"><span class="mord mathrm">d</span></span></span><span class="mord mathdefault">t</span></span></span><span style="top:-2.3239750000000003em;"><span class="pstrut" style="height:3.7368200000000003em;"></span><span class="mord"><span class="mord"></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mord"><span class="mord mathdefault">e</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:1.0369199999999998em;"><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mopen mtight">(</span><span class="mord mtight"><span class="mord mathdefault mtight">x</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8913142857142857em;"><span style="top:-2.931em;margin-right:0.07142857142857144em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mclose mtight"><span class="mclose mtight">)</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8913142857142857em;"><span style="top:-2.931em;margin-right:0.07142857142857144em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span><span class="mord"><span class="mord"><span class="mord mathrm">d</span></span></span><span class="mord"><span class="mord mathdefault">x</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8641079999999999em;"><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mord">2</span><span class="mord mathdefault">x</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">⋅</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord"><span class="mord mathdefault">e</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:1.0369199999999998em;"><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight"><span class="mord mathdefault mtight">x</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8913142857142857em;"><span style="top:-2.931em;margin-right:0.07142857142857144em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight">4</span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:2.072845em;"><span></span></span></span></span></span></span></span></span></span></span></span></p>
<h1 id="仅下限为函数">仅下限为函数</h1>
<p>这种情况我们就需要通过添加负号来转换成刚刚我们学的形式，再使用刚刚的方法来解决就可以了。</p>
<p class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>y</mi><mo>=</mo><msubsup><mo>∫</mo><mrow><mi>f</mi><mo>(</mo><mi>x</mi><mo>)</mo></mrow><mi>a</mi></msubsup><mi>g</mi><mo>(</mo><mi>t</mi><mo>)</mo><mtext> </mtext><mi mathvariant="normal">d</mi><mi>t</mi><mo>⇒</mo><mi>y</mi><mo>=</mo><mo>−</mo><msubsup><mo>∫</mo><mi>a</mi><mrow><mi>f</mi><mo>(</mo><mi>x</mi><mo>)</mo></mrow></msubsup><mi>g</mi><mo>(</mo><mi>t</mi><mo>)</mo><mtext> </mtext><mi mathvariant="normal">d</mi><mi>t</mi></mrow><annotation encoding="application/x-tex">y=\int^a_{f(x)}g(t)\,{\rm d}t\Rightarrow y=-\int^{f(x)}_a g(t)\,{\rm d}t
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">y</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:2.501242em;vertical-align:-1.0869499999999999em;"></span><span class="mop"><span class="mop op-symbol large-op" style="margin-right:0.44445em;position:relative;top:-0.0011249999999999316em;">∫</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.414292em;"><span style="top:-1.7880500000000004em;margin-left:-0.44445em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.10764em;">f</span><span class="mopen mtight">(</span><span class="mord mathdefault mtight">x</span><span class="mclose mtight">)</span></span></span></span><span style="top:-3.8129000000000004em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">a</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.0869499999999999em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="mopen">(</span><span class="mord mathdefault">t</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord"><span class="mord mathrm">d</span></span></span><span class="mord mathdefault">t</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">⇒</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">y</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:2.54985em;vertical-align:-0.9119499999999999em;"></span><span class="mord">−</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mop"><span class="mop op-symbol large-op" style="margin-right:0.44445em;position:relative;top:-0.0011249999999999316em;">∫</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.6379000000000001em;"><span style="top:-1.7880500000000001em;margin-left:-0.44445em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">a</span></span></span><span style="top:-3.8129em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.10764em;">f</span><span class="mopen mtight">(</span><span class="mord mathdefault mtight">x</span><span class="mclose mtight">)</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.9119499999999999em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="mopen">(</span><span class="mord mathdefault">t</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord"><span class="mord mathrm">d</span></span></span><span class="mord mathdefault">t</span></span></span></span></span></p>
<p>然后就可以用我们刚刚介绍的方法来进行计算啦：</p>
<p class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><msup><mi>y</mi><mo mathvariant="normal">′</mo></msup><mo>=</mo><mo>−</mo><mi>g</mi><mo fence="false">(</mo><mi>f</mi><mo>(</mo><mi>x</mi><mo>)</mo><mo fence="false">)</mo><mo>⋅</mo><msup><mi>f</mi><mo mathvariant="normal">′</mo></msup><mo>(</mo><mi>x</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">y^{\prime}=-g\big(f(x)\big)\cdot f^\prime(x)
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.996332em;vertical-align:-0.19444em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03588em;">y</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.801892em;"><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">′</span></span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1.20001em;vertical-align:-0.35001em;"></span><span class="mord">−</span><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="mord"><span class="delimsizing size1">(</span></span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mopen">(</span><span class="mord mathdefault">x</span><span class="mclose">)</span><span class="mord"><span class="delimsizing size1">)</span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">⋅</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1.051892em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.801892em;"><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">′</span></span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord mathdefault">x</span><span class="mclose">)</span></span></span></span></span></p>
<p>举个栗子：</p>
<p class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mtable><mtr><mtd><mstyle scriptlevel="0" displaystyle="true"><mi>y</mi></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="true"><mrow><mrow></mrow><mo>=</mo><msubsup><mo>∫</mo><mi>x</mi><mn>0</mn></msubsup><msup><mi>e</mi><mi>t</mi></msup><mi>cos</mi><mo>⁡</mo><mn>3</mn><mi>t</mi><mtext> </mtext><mi mathvariant="normal">d</mi><mi>t</mi></mrow></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="true"><mrow><mo>⟹</mo><mi>y</mi></mrow></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="true"><mrow><mrow></mrow><mo>=</mo><mo>−</mo><msubsup><mo>∫</mo><mn>0</mn><mi>x</mi></msubsup><msup><mi>e</mi><mi>t</mi></msup><mi>cos</mi><mo>⁡</mo><mn>3</mn><mi>t</mi><mtext> </mtext><mi mathvariant="normal">d</mi><mi>t</mi></mrow></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="true"><mrow><mo>⟹</mo><msup><mi>y</mi><mo mathvariant="normal">′</mo></msup></mrow></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="true"><mrow><mrow></mrow><mo>=</mo><mo>−</mo><msup><mi>e</mi><mi>x</mi></msup><mi>cos</mi><mo>⁡</mo><mn>3</mn><mi>x</mi><mtext> </mtext><mi mathvariant="normal">d</mi><mi>x</mi></mrow></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="true"><mrow></mrow></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="true"><mrow><mrow></mrow><mo>=</mo><mo>−</mo><msup><mi>e</mi><mi>x</mi></msup><mi>cos</mi><mo>⁡</mo><mn>3</mn><mi>x</mi></mrow></mstyle></mtd></mtr></mtable><annotation encoding="application/x-tex">\begin{aligned}
 y&amp;=\int^0_x e^t\cos 3t\,{\rm d}t\\
\Longrightarrow y&amp;=-\int^x_0 e^t\cos 3t\,{\rm d}t\\
\Longrightarrow y^\prime &amp; =-e^x\cos 3x\,{\rm d}x\\
&amp;=-e^x\cos 3x\\
\end{aligned}
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:8.4022em;vertical-align:-3.9510999999999994em;"></span><span class="mord"><span class="mtable"><span class="col-align-r"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:4.4511em;"><span style="top:-6.4511em;"><span class="pstrut" style="height:3.5640080000000003em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03588em;">y</span></span></span><span style="top:-3.824858em;"><span class="pstrut" style="height:3.5640080000000003em;"></span><span class="mord"><span class="mrel">⟹</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">y</span></span></span><span style="top:-1.7729080000000006em;"><span class="pstrut" style="height:3.5640080000000003em;"></span><span class="mord"><span class="mrel">⟹</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03588em;">y</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.801892em;"><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">′</span></span></span></span></span></span></span></span></span></span><span style="top:-0.27290800000000104em;"><span class="pstrut" style="height:3.5640080000000003em;"></span><span class="mord"></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:3.9510999999999994em;"><span></span></span></span></span></span><span class="col-align-l"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:4.4511em;"><span style="top:-6.4511em;"><span class="pstrut" style="height:3.5640080000000003em;"></span><span class="mord"><span class="mord"></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mop"><span class="mop op-symbol large-op" style="margin-right:0.44445em;position:relative;top:-0.0011249999999999316em;">∫</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.5640080000000003em;"><span style="top:-1.7880500000000001em;margin-left:-0.44445em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">x</span></span></span><span style="top:-3.812900000000001em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.9119499999999999em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault">e</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.843556em;"><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">t</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mop">cos</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">3</span><span class="mord mathdefault">t</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord"><span class="mord mathrm">d</span></span></span><span class="mord mathdefault">t</span></span></span><span style="top:-3.824858em;"><span class="pstrut" style="height:3.5640080000000003em;"></span><span class="mord"><span class="mord"></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mord">−</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mop"><span class="mop op-symbol large-op" style="margin-right:0.44445em;position:relative;top:-0.0011249999999999316em;">∫</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.414292em;"><span style="top:-1.7880500000000001em;margin-left:-0.44445em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">0</span></span></span><span style="top:-3.8129000000000004em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">x</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.9119499999999999em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault">e</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.843556em;"><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">t</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mop">cos</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">3</span><span class="mord mathdefault">t</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord"><span class="mord mathrm">d</span></span></span><span class="mord mathdefault">t</span></span></span><span style="top:-1.7729080000000006em;"><span class="pstrut" style="height:3.5640080000000003em;"></span><span class="mord"><span class="mord"></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mord">−</span><span class="mord"><span class="mord mathdefault">e</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.7143919999999999em;"><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">x</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mop">cos</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">3</span><span class="mord mathdefault">x</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord"><span class="mord mathrm">d</span></span></span><span class="mord mathdefault">x</span></span></span><span style="top:-0.27290800000000104em;"><span class="pstrut" style="height:3.5640080000000003em;"></span><span class="mord"><span class="mord"></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mord">−</span><span class="mord"><span class="mord mathdefault">e</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.7143919999999999em;"><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">x</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mop">cos</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">3</span><span class="mord mathdefault">x</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:3.9510999999999994em;"><span></span></span></span></span></span></span></span></span></span></span></span></p>
<h1 id="上下限均为函数">上下限均为函数</h1>
<p>这种情况，需要将其分为两个积分来求导，像下面这样：</p>
<p class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mtable><mtr><mtd><mstyle scriptlevel="0" displaystyle="true"><mrow></mrow></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="true"><mrow><mrow></mrow><mi>y</mi><mo>=</mo><msubsup><mo>∫</mo><mrow><mi>h</mi><mo>(</mo><mi>x</mi><mo>)</mo></mrow><mrow><mi>g</mi><mo>(</mo><mi>x</mi><mo>)</mo></mrow></msubsup><mi>f</mi><mo>(</mo><mi>t</mi><mo>)</mo><mtext> </mtext><mi mathvariant="normal">d</mi><mi>t</mi></mrow></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="true"><mo>⟹</mo></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="true"><mrow><mrow></mrow><mi>y</mi><mo>=</mo><msubsup><mo>∫</mo><mn>0</mn><mrow><mi>g</mi><mo>(</mo><mi>x</mi><mo>)</mo></mrow></msubsup><mi>f</mi><mo>(</mo><mi>t</mi><mo>)</mo><mtext> </mtext><mi mathvariant="normal">d</mi><mi>t</mi><mo>+</mo><msubsup><mo>∫</mo><mrow><mi>h</mi><mo>(</mo><mi>x</mi><mo>)</mo></mrow><mn>0</mn></msubsup><mi>f</mi><mo>(</mo><mi>t</mi><mo>)</mo><mtext> </mtext><mi mathvariant="normal">d</mi><mi>t</mi></mrow></mstyle></mtd></mtr></mtable><annotation encoding="application/x-tex">\begin{aligned}
&amp; y=\int^{g(x)}_{h(x)}f(t)\,{\rm d}t \\
\Longrightarrow &amp; y=\int^{g(x)}_0f(t)\,{\rm d}t +\int^0_{h(x)}f(t)\,{\rm d}t \\
\end{aligned}
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:6.049700000000001em;vertical-align:-2.774850000000001em;"></span><span class="mord"><span class="mtable"><span class="col-align-r"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:3.2748500000000003em;"><span style="top:-5.27485em;"><span class="pstrut" style="height:3.6379em;"></span><span class="mord"></span></span><span style="top:-2.249999999999999em;"><span class="pstrut" style="height:3.6379em;"></span><span class="mord"><span class="mrel">⟹</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:2.774850000000001em;"><span></span></span></span></span></span><span class="col-align-l"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:3.2748500000000003em;"><span style="top:-5.27485em;"><span class="pstrut" style="height:3.6379em;"></span><span class="mord"><span class="mord"></span><span class="mord mathdefault" style="margin-right:0.03588em;">y</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mop"><span class="mop op-symbol large-op" style="margin-right:0.44445em;position:relative;top:-0.0011249999999999316em;">∫</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.6379000000000004em;"><span style="top:-1.7880500000000004em;margin-left:-0.44445em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">h</span><span class="mopen mtight">(</span><span class="mord mathdefault mtight">x</span><span class="mclose mtight">)</span></span></span></span><span style="top:-3.8129000000000004em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.03588em;">g</span><span class="mopen mtight">(</span><span class="mord mathdefault mtight">x</span><span class="mclose mtight">)</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.0869499999999999em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mopen">(</span><span class="mord mathdefault">t</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord"><span class="mord mathrm">d</span></span></span><span class="mord mathdefault">t</span></span></span><span style="top:-2.249999999999999em;"><span class="pstrut" style="height:3.6379em;"></span><span class="mord"><span class="mord"></span><span class="mord mathdefault" style="margin-right:0.03588em;">y</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mop"><span class="mop op-symbol large-op" style="margin-right:0.44445em;position:relative;top:-0.0011249999999999316em;">∫</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.6379000000000004em;"><span style="top:-1.7880500000000001em;margin-left:-0.44445em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">0</span></span></span><span style="top:-3.8129000000000004em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.03588em;">g</span><span class="mopen mtight">(</span><span class="mord mathdefault mtight">x</span><span class="mclose mtight">)</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.9119499999999999em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mopen">(</span><span class="mord mathdefault">t</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord"><span class="mord mathrm">d</span></span></span><span class="mord mathdefault">t</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mop"><span class="mop op-symbol large-op" style="margin-right:0.44445em;position:relative;top:-0.0011249999999999316em;">∫</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.5640080000000003em;"><span style="top:-1.7880500000000004em;margin-left:-0.44445em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">h</span><span class="mopen mtight">(</span><span class="mord mathdefault mtight">x</span><span class="mclose mtight">)</span></span></span></span><span style="top:-3.8129000000000004em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.0869499999999999em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mopen">(</span><span class="mord mathdefault">t</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord"><span class="mord mathrm">d</span></span></span><span class="mord mathdefault">t</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:2.774850000000001em;"><span></span></span></span></span></span></span></span></span></span></span></span></p>
<p>分界点视具体情况而定。接下来使用负号：</p>
<p class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mtable><mtr><mtd><mstyle scriptlevel="0" displaystyle="true"><mrow></mrow></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="true"><mrow><mrow></mrow><mi>y</mi><mo>=</mo><msubsup><mo>∫</mo><mn>0</mn><mrow><mi>g</mi><mo>(</mo><mi>x</mi><mo>)</mo></mrow></msubsup><mi>f</mi><mo>(</mo><mi>t</mi><mo>)</mo><mtext> </mtext><mi mathvariant="normal">d</mi><mi>t</mi><mo>+</mo><msubsup><mo>∫</mo><mrow><mi>h</mi><mo>(</mo><mi>x</mi><mo>)</mo></mrow><mn>0</mn></msubsup><mi>f</mi><mo>(</mo><mi>t</mi><mo>)</mo><mtext> </mtext><mi mathvariant="normal">d</mi><mi>t</mi></mrow></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="true"><mo>⟹</mo></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="true"><mrow><mrow></mrow><mi>y</mi><mo>=</mo><msubsup><mo>∫</mo><mn>0</mn><mrow><mi>g</mi><mo>(</mo><mi>x</mi><mo>)</mo></mrow></msubsup><mi>f</mi><mo>(</mo><mi>t</mi><mo>)</mo><mtext> </mtext><mi mathvariant="normal">d</mi><mi>t</mi><mo>−</mo><msubsup><mo>∫</mo><mn>0</mn><mrow><mi>h</mi><mo>(</mo><mi>x</mi><mo>)</mo></mrow></msubsup><mi>f</mi><mo>(</mo><mi>t</mi><mo>)</mo><mtext> </mtext><mi mathvariant="normal">d</mi><mi>t</mi></mrow></mstyle></mtd></mtr></mtable><annotation encoding="application/x-tex">\begin{aligned}
&amp; y=\int^{g(x)}_0f(t)\,{\rm d}t +\int^0_{h(x)}f(t)\,{\rm d}t\\
\Longrightarrow &amp; y=\int^{g(x)}_0f(t)\,{\rm d}t -\int^{h(x)}_0f(t)\,{\rm d}t\\
\end{aligned}
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:5.874700000000001em;vertical-align:-2.6873500000000003em;"></span><span class="mord"><span class="mtable"><span class="col-align-r"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:3.1873500000000003em;"><span style="top:-5.18735em;"><span class="pstrut" style="height:3.6379em;"></span><span class="mord"></span></span><span style="top:-2.1624999999999996em;"><span class="pstrut" style="height:3.6379em;"></span><span class="mord"><span class="mrel">⟹</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:2.6873500000000003em;"><span></span></span></span></span></span><span class="col-align-l"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:3.1873500000000003em;"><span style="top:-5.18735em;"><span class="pstrut" style="height:3.6379em;"></span><span class="mord"><span class="mord"></span><span class="mord mathdefault" style="margin-right:0.03588em;">y</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mop"><span class="mop op-symbol large-op" style="margin-right:0.44445em;position:relative;top:-0.0011249999999999316em;">∫</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.6379000000000004em;"><span style="top:-1.7880500000000001em;margin-left:-0.44445em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">0</span></span></span><span style="top:-3.8129000000000004em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.03588em;">g</span><span class="mopen mtight">(</span><span class="mord mathdefault mtight">x</span><span class="mclose mtight">)</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.9119499999999999em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mopen">(</span><span class="mord mathdefault">t</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord"><span class="mord mathrm">d</span></span></span><span class="mord mathdefault">t</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mop"><span class="mop op-symbol large-op" style="margin-right:0.44445em;position:relative;top:-0.0011249999999999316em;">∫</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.5640080000000003em;"><span style="top:-1.7880500000000004em;margin-left:-0.44445em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">h</span><span class="mopen mtight">(</span><span class="mord mathdefault mtight">x</span><span class="mclose mtight">)</span></span></span></span><span style="top:-3.8129000000000004em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.0869499999999999em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mopen">(</span><span class="mord mathdefault">t</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord"><span class="mord mathrm">d</span></span></span><span class="mord mathdefault">t</span></span></span><span style="top:-2.1624999999999996em;"><span class="pstrut" style="height:3.6379em;"></span><span class="mord"><span class="mord"></span><span class="mord mathdefault" style="margin-right:0.03588em;">y</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mop"><span class="mop op-symbol large-op" style="margin-right:0.44445em;position:relative;top:-0.0011249999999999316em;">∫</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.6379000000000004em;"><span style="top:-1.7880500000000001em;margin-left:-0.44445em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">0</span></span></span><span style="top:-3.8129000000000004em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.03588em;">g</span><span class="mopen mtight">(</span><span class="mord mathdefault mtight">x</span><span class="mclose mtight">)</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.9119499999999999em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mopen">(</span><span class="mord mathdefault">t</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord"><span class="mord mathrm">d</span></span></span><span class="mord mathdefault">t</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mop"><span class="mop op-symbol large-op" style="margin-right:0.44445em;position:relative;top:-0.0011249999999999316em;">∫</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.6379000000000004em;"><span style="top:-1.7880500000000001em;margin-left:-0.44445em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">0</span></span></span><span style="top:-3.8129000000000004em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">h</span><span class="mopen mtight">(</span><span class="mord mathdefault mtight">x</span><span class="mclose mtight">)</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.9119499999999999em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mopen">(</span><span class="mord mathdefault">t</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord"><span class="mord mathrm">d</span></span></span><span class="mord mathdefault">t</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:2.6873500000000003em;"><span></span></span></span></span></span></span></span></span></span></span></span></p>
<p>当然，其实这种类型，有公式可以套，也可以自己推导哦：</p>
<p class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mtable><mtr><mtd><mstyle scriptlevel="0" displaystyle="true"><msup><mi>y</mi><mo mathvariant="normal">′</mo></msup></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="true"><mrow><mrow></mrow><mo>=</mo><msup><mrow><mo fence="true">(</mo><msubsup><mo>∫</mo><mrow><mi>h</mi><mo>(</mo><mi>x</mi><mo>)</mo></mrow><mrow><mi>g</mi><mo>(</mo><mi>x</mi><mo>)</mo></mrow></msubsup><mi>f</mi><mo>(</mo><mi>t</mi><mo>)</mo><mtext> </mtext><mi mathvariant="normal">d</mi><mi>t</mi><mo fence="true">)</mo></mrow><mo mathvariant="normal">′</mo></msup></mrow></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="true"><mrow></mrow></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="true"><mrow><mrow></mrow><mo>=</mo><mi>f</mi><mo fence="false">(</mo><mi>g</mi><mo>(</mo><mi>x</mi><mo>)</mo><mo fence="false">)</mo><mo>⋅</mo><msup><mi>g</mi><mo mathvariant="normal">′</mo></msup><mo>(</mo><mi>x</mi><mo>)</mo><mo>−</mo><mi>f</mi><mo fence="false">(</mo><mi>h</mi><mo>(</mo><mi>x</mi><mo>)</mo><mo fence="false">)</mo><mo>⋅</mo><msup><mi>h</mi><mo mathvariant="normal">′</mo></msup><mo>(</mo><mi>x</mi><mo>)</mo></mrow></mstyle></mtd></mtr></mtable><annotation encoding="application/x-tex">\begin{aligned}
y^\prime
&amp;=\left(\int^{g(x)}_{h(x)}f(t)\,{\rm d}t\right)^\prime\\
&amp;=f\big(g(x)\big)\cdot g^\prime(x)-f\big(h(x)\big)\cdot h^\prime(x)\\
\end{aligned}
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:4.951822em;vertical-align:-2.225911em;"></span><span class="mord"><span class="mtable"><span class="col-align-r"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:2.725911em;"><span style="top:-4.725911em;"><span class="pstrut" style="height:3.891792em;"></span><span class="mord"><span class="mord"><span class="mord mathdefault" style="margin-right:0.03588em;">y</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.801892em;"><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">′</span></span></span></span></span></span></span></span></span></span><span style="top:-2.3258810000000003em;"><span class="pstrut" style="height:3.891792em;"></span><span class="mord"></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:2.225911em;"><span></span></span></span></span></span><span class="col-align-l"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:2.725911em;"><span style="top:-4.725911em;"><span class="pstrut" style="height:3.891792em;"></span><span class="mord"><span class="mord"></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="minner"><span class="minner"><span class="mopen delimcenter" style="top:0em;"><span class="delimsizing size4">(</span></span><span class="mop"><span class="mop op-symbol large-op" style="margin-right:0.44445em;position:relative;top:-0.0011249999999999316em;">∫</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.6379000000000004em;"><span style="top:-1.7880500000000004em;margin-left:-0.44445em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">h</span><span class="mopen mtight">(</span><span class="mord mathdefault mtight">x</span><span class="mclose mtight">)</span></span></span></span><span style="top:-3.8129000000000004em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.03588em;">g</span><span class="mopen mtight">(</span><span class="mord mathdefault mtight">x</span><span class="mclose mtight">)</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.0869499999999999em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mopen">(</span><span class="mord mathdefault">t</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord"><span class="mord mathrm">d</span></span></span><span class="mord mathdefault">t</span><span class="mclose delimcenter" style="top:0em;"><span class="delimsizing size4">)</span></span></span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:1.8917920000000001em;"><span style="top:-4.2029000000000005em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">′</span></span></span></span></span></span></span></span></span></span><span style="top:-2.3258810000000003em;"><span class="pstrut" style="height:3.891792em;"></span><span class="mord"><span class="mord"></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mord"><span class="delimsizing size1">(</span></span><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="mopen">(</span><span class="mord mathdefault">x</span><span class="mclose">)</span><span class="mord"><span class="delimsizing size1">)</span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">⋅</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.801892em;"><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">′</span></span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord mathdefault">x</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mord"><span class="delimsizing size1">(</span></span><span class="mord mathdefault">h</span><span class="mopen">(</span><span class="mord mathdefault">x</span><span class="mclose">)</span><span class="mord"><span class="delimsizing size1">)</span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">⋅</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord"><span class="mord mathdefault">h</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.801892em;"><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">′</span></span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord mathdefault">x</span><span class="mclose">)</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:2.225911em;"><span></span></span></span></span></span></span></span></span></span></span></span></p>
<hr>
<p>其实这样的题目看起来复杂，实际上只要掌握了技巧和方法，解决就是分分钟的事情了！这节的内容非常简单，相信你很快就能够掌握。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Python的安装以及环境配置]]></title>
        <id>https://harriswilde.github.io/post/PythonInstall</id>
        <link href="https://harriswilde.github.io/post/PythonInstall">
        </link>
        <updated>2019-12-31T15:54:02.000Z</updated>
        <content type="html"><![CDATA[<p>在学习Python之前，我们需要安装Python才能够进行程序的编写。在这里，笔者就拿Python的官方发行版本来进行说明。对于早期的学习来说，官方的IDLE基本可以满足，如果真的要走上Python开发，或者是想要获得更高级的体验的话，后期可以自己尝试安装PyCharm、Visual Studio之类的IDE。</p>
<p>废话不多说，咱们开始。</p>
<hr>
<h1 id="windows环境">Windows环境</h1>
<h2 id="下载安装">下载安装</h2>
<p>Windows应该是咱们小伙伴最常用的一个系统了，应该对这个比较熟悉。那么其实直接去官网：<a href="https://www.python.org/downloads/">点我直达</a></p>
<p>在里面找到你想要下载的版本（如果你不知道你想要下载什么版本，那就下载<strong>最新</strong>的版本），点进去之后，翻到页面最底部，就可以看到所有的发行版文件。找到适用于Win的，然后找到后缀是<code>executable installer</code>的文件下载。如果你是<strong>64位</strong>的系统，那就找到含有<code>X86-64</code>关键字的文件下载，如果是<strong>32位</strong>就找<code>X86</code>。</p>
<p>下载好了之后应该是一个exe文件，双击安装即可。</p>
<p>安装的时候，注意在刚开始的时候把<code>Add Python to PATH</code>勾选上，它就会自动将Python添加到环境变量里面，如图：<br>
<img src="https://s2.ax1x.com/2020/01/09/lfpvsH.png" alt="勾选红色方框内的选项" loading="lazy"></p>
<p>如果你不知道你的Python是否添加了环境变量，那么只需要打开<code>CMD</code>，输入Python回车，如果提示“Python不是系统命令”的话，那就是没有添加。如果命令正常执行，Python交互解释器启动，那就已经添加完成了。</p>
<p>如果你是安装的Visual Studio这类IDE，或者在安装官方Python的时候忘记勾选，那么请看下面的教程手动添加。</p>
<h2 id="环境配置">环境配置</h2>
<p>虽然现在你已经可以开始写程序了，但是我们还是把环境变量先配置一下，方便以后安装拓展等等。</p>
<p>这里以Windows10为例，其他的操作系统也大同小异。</p>
<ol>
<li>右键此电脑，打开<code>属性</code><br>
<img src="https://s2.ax1x.com/2019/12/31/l1mAk8.png" alt="" loading="lazy"></li>
<li>选择<code>高级系统设置</code><br>
<img src="https://s2.ax1x.com/2019/12/31/l1mw0x.png" alt="" loading="lazy"></li>
<li>点击<code>高级</code>选项卡，进入<code>环境变量</code><br>
<img src="https://s2.ax1x.com/2019/12/31/l1mbcj.png" alt="" loading="lazy"></li>
<li>点击<code>Path</code>，<code>编辑</code><br>
<img src="https://s2.ax1x.com/2019/12/31/l1nzqI.png" alt="" loading="lazy"></li>
<li>点击<code>新建</code><br>
<img src="https://s2.ax1x.com/2019/12/31/l1uii8.png" alt="" loading="lazy"></li>
<li>找到你的Python安装的路径，将它和它的<code>Scripts</code>子目录也添加进去，像下面这样<br>
<img src="https://s2.ax1x.com/2019/12/31/l1u9dP.png" alt="" loading="lazy"><br>
添加完成，确定了之后，运行<code>cmd</code>，输入<code>Python</code>，如果出来的是这样的：</li>
</ol>
<pre><code>Microsoft Windows [Version 10.0.18363.535]
(c) 2019 Microsoft Corporation. All rights reserved.

C:\Users\Harris Wilde&gt;Python
Python 3.7.5 (tags/v3.7.5:5c02a39a0b, Oct 15 2019, 00:11:34) [MSC v.1916 64 bit (AMD64)] on win32
Type &quot;help&quot;, &quot;copyright&quot;, &quot;credits&quot; or &quot;license&quot; for more information.
&gt;&gt;&gt;_
</code></pre>
<p>那么恭喜你，你已经成功了！</p>
<p>如果是这样的：</p>
<pre><code>Microsoft Windows [Version 10.0.18363.535]
(c) 2019 Microsoft Corporation. All rights reserved.

C:\Users\Harris Wilde&gt;Python
'Python' is not recognized as an internal or external command,
operable program or batch file.
</code></pre>
<p>那么你可能中间有些步骤不对，回去再好好检查下吧。</p>
<hr>
<h1 id="linux和unix">Linux和Unix</h1>
<p>绝大部分的Linux和Unix系统（包括MacOS）都是内置Python解释器的，你只需要打开终端提示符，输入以下命令：</p>
<pre><code>$ python
</code></pre>
<p>这会启动Python交互解释器，同时也应该有下面这样的输出：</p>
<pre><code>Python 2.5.1 (r251:54869, Apr 18 2007, 22:08:04)
[GCC 4.0.1 (Apple Computer, Inc . build 5367)] on darwin
Type &quot;help&quot;, &quot;copyright&quot;, &quot;credits&quot; or &quot;license&quot; for more information.
&gt;&gt;&gt;▮
</code></pre>
<p>如果没有安装的话，可能会得到下面的错误：</p>
<pre><code>bash: python: command not found
</code></pre>
<p>那么，你就要自己安装了。</p>
<h2 id="使用包管理器">使用包管理器</h2>
<p>Linux系统家族存在多种包管理系他和安装机制。如果你使用的是Linux是有某种某种形式的包管理系统，那么你可以通过它很轻松地安装Python。</p>
<blockquote>
<p>注意，在Linux中使用包管理安装器安装Python的时候可能需要具备系统管理员（root账户）权限。</p>
</blockquote>
<p>例如，如果使用的操作系统位Debian Linux，那么可以使用下面的命令来安装Python：</p>
<pre><code>$ apt-get install python
</code></pre>
<p>如果是Gentoo Linux，则可以使用：</p>
<pre><code>$ emerge python
</code></pre>
<blockquote>
<p>许多包管理器都有自动下载的功能，包括Yum、Synaptic（Unbuntu Linux专有的包管理器）以及其他Debian样式的管理器。你能够通过这些管理器获得Python的最新版本。</p>
</blockquote>
<h2 id="从源文件编译">从源文件编译</h2>
<p>如果你没有包管理器，或者不想用的话，也可以尝试自己编译Python。当然也有可能是你没有管理员权限，这个方法也适用，十分灵活。你可以在<strong>任何位置</strong>安装Python，甚至可以安装在用户的主目录都是没问题的。那么接下来就来开始：</p>
<ol>
<li>访问官网的下载页：<a href="https://www.python.org/downloads/">点我直达</a></li>
<li>按照说明下载源代码</li>
<li>下载拓展名为<code>.tgz</code>的文件，将其保存在临时的位置。假设你想将Python安装在自己的主目录，那么可以将它放置在类似于<code>~/python</code>的目录中。进入这个目录（比如使用<code>cd ~/python</code>命令）。</li>
<li>使用<code>tar -xzvf Python-3.7.tgz</code>(3.7是版本号)解压缩文件。如果使用的tar版本不支持<code>z</code>选项，那么可以先使用gunzip进行解压，然后再使用<code>tar -xvf</code>命令。如果解压缩的过程中出错，那你就试试重新下载，因为下载的时候也有可能会出错。</li>
<li>进入解压好的文件夹：<pre><code>$ cd Python-3.7
</code></pre>
执行下面的命令：<pre><code>./configue --perfix=$(pwd)
make
make install
</code></pre>
最后应该可以再当前文件夹内找到一个名为python的可执行文件（如果上面的步骤无效的话，那就看看包含在发布版中的README文件）。将当前文件夹的路径包含在环境变量PATH中，这样安装就大功告成了！<br>
如果要看看其他的配置命令，那么就使用以下的命令：<pre><code>./configue --help
</code></pre>
</li>
</ol>
<hr>
<h1 id="macos">MacOS</h1>
<p>MacOS是有自带的Python解释器的。你只需要打开终端，输入python命令就可以运行。即使打算安装更新的版本，也应该保留这个默认的安装，因为操作系统需要用到它。读者可以使用<a href="http://macports.org">MacPorts</a>或者<a href="http://finkproject.org">Fink</a>进行安装，或者按照以下的步骤从Python官网获取最新的版本。</p>
<ol>
<li>访问官网下载：<a href="https://www.python.org/downloads/">点我直达</a></li>
<li>点击MacOS Installer的链接，应该会跳转到MacPython的下载页面，上面会有更多的信息。MacPython页面也有针对旧版MacOS的Python。</li>
<li>下载了<code>.dmg</code>安装文件之后，它有可能会自动挂载。如果没有，双击该文件。已经挂载的磁盘映像中，可以找到安装包文件<code>.mpkg</code>。如果双击该文件，，就会打开安装向导，引领你完成安装的步骤。</li>
</ol>
<hr>
<p>安装完成了之后，你可以使用命令或者Win下打开IDLE，输入</p>
<pre><code class="language-python">print(&quot;Hello, world!&quot;)
</code></pre>
<p>应该解释器就会给你打招呼啦：</p>
<pre><code>Python 3.7.5 (tags/v3.7.5:5c02a39a0b, Oct 15 2019, 00:11:34) [MSC v.1916 64 bit (AMD64)] on win32
Type &quot;help&quot;, &quot;copyright&quot;, &quot;credits&quot; or &quot;license()&quot; for more information.
&gt;&gt;&gt; print(&quot;Hello, world!&quot;)
Hello, world!
&gt;&gt;&gt; _
</code></pre>
<p>那么这时候，你也可以试着输入其他的指令看看：</p>
<pre><code>&gt;&gt;&gt; 你好吗？
SyntaxError: invalid character in identifier
&gt;&gt;&gt; _
</code></pre>
<p>这是因为你还不会和解释器进行交流，自然它就听不懂你在说什么了。</p>
<p>不过要是不会交流，还是挺没意思的吧？</p>
<p>如果你已经看到了这里，那么今天的基础工作应该做的差不多了，那咱们就开始吧。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Python学习开场白]]></title>
        <id>https://harriswilde.github.io/post/PythonBeginner</id>
        <link href="https://harriswilde.github.io/post/PythonBeginner">
        </link>
        <updated>2019-12-31T15:02:06.000Z</updated>
        <content type="html"><![CDATA[<p>在2019年的最后一天，写一篇小短文来正式开启我的Python学习的版面。</p>
<p>Python语言，用我的话来说，就是通识语言。基本上只要你会一点点英语，那么这门语言对于你来说，就毫无难度。语法几乎就是英语，你甚至不需要知道那些艰深晦涩的原理，就可以快速地达到你想达到的目的。无论你是文科还是理科，无论你是否有计算机基础，你都可以学习这门语言。我甚至有一种预感，这门语言未来将不再是程序员们的专属，可能会成为一门普适性的语言，现在已经有这种趋势了。</p>
<p>当然，Python也有许多令人诟病的地方，比如版本更新兼容性差，性能低，函数语法太过冗杂等等。咱们就来避重就轻，感受一下这门语言的魅力。</p>
<p>Python和大数据、人工智能、机器学习等名词连起来出现已经见怪不怪了，还是那句话，你不需要很专业，也不需要很痛苦，静下心来学习，你会发现，编程已经成为了一种享受，就像和计算机对话一样。</p>
<p>但是，如果你是计算机类专业的学生，或者打算从事这方面的工作，就千万别局限于Python，也别听那些什么机构吹的东西，Python虽然简单，但是用Python来解决的问题往往不简单，过硬的实力是必不可少的。</p>
<p>最后，祝诸君鼠年大吉，学业有成、事业攀升！</p>
<pre><code class="language-python">print(&quot;新年快乐！&quot;)
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[C语言之数组]]></title>
        <id>https://harriswilde.github.io/post/CArray</id>
        <link href="https://harriswilde.github.io/post/CArray">
        </link>
        <updated>2019-12-07T15:29:32.000Z</updated>
        <content type="html"><![CDATA[<p>学完了前面几种基础语法之后，你可能会渐渐发现，现有的数据的记录方式，已经无法很好地解决我们接下来要解决的问题。比如有一天，老师找你计算一下全班同学的平均成绩。那么你就会开始思考如何存储全班的成绩。按照之前学习的知识，我们可以定义<code>a1</code> <code>a2</code> <code>a3</code> <code>……</code>。但是，这样未免也太麻烦了，如果要记录全省人民的身高数据呢？如果下个学期班里学生人数有变化呢？</p>
<p>你会发现，种种原因，导致了我们编写的程序很繁杂，不够灵活。那么这样，编程也就没有太大的必要了。好在，C语言提供了一种存储数据的方式，叫做<strong>数组</strong>。</p>
<hr>
<p>数组，就是存放一堆<strong>同类型</strong>的数据的容器。比如刚刚的例子，我们要存储学生的成绩，这时候数组就可以大显神威了。</p>
<h1 id="定义一维数组">定义一维数组</h1>
<p>定义一维数组的方法很简单，只需要指定元素的类型和存放的数量即可。</p>
<p><code>类型 数组名[元素个数]</code></p>
<p>比如：</p>
<pre><code class="language-c">int Score1[50];//定义一个叫Score1的整型数组，有50个元素
float Score2[30];//定义一个叫Score2的浮点型数组，有30个元素
double Score3[20];//定义一个叫Score3的双精度浮点型数组，有20个元素
char Str[10];//定义一个叫Str的字符型数组，有10个元素
</code></pre>
<p>数组一旦被定义，在其生命周期内，就<strong>不可能被改变</strong>(其实是在内存中开辟了一段连续的空间了)。</p>
<h1 id="访问数组">访问数组</h1>
<p>访问数组的方法和定义有点类似，但是如果混淆了的话，那可就不是什么好事了。</p>
<p><code>数组名[下标]</code></p>
<p>方括号里面的，实际上是指的数组的<strong>下标</strong>，也可以叫<strong>索引</strong>。需要注意的是，下标的计数是从<code>0</code>开始的，最大的下标是<code>(元素个数-1)</code>。也就是说，如果我<code>int Score[10]</code>之后，那么我想访问第一个元素，就是这样<code>Score[0]</code>，如果要访问最后一个元素，就是<code>Score[9]</code>。</p>
<p>之前看到过一个段子，大概意思是说程序员数数都喜欢从0开始数。如果你是刚刚接触编程，那么你也要开始习惯从0开始计数的这种思路。</p>
<p>其实，并不是C语言才开始有数组，FORTRAN语言就有数组了。但是下标从0开始计数这种方式，是从C语言才开始有的。当时开发C语言编译器的人们就想让编译器能够更加简单，如果从0开始，那么编译器实际上能够少做很多事情，于是就多了这么一个设定。随着计算机科学的发展，后面出现的优秀的语言也越来越多。但是我们所说的&quot;C-Like”语言，也就是参照C语言来开发的语言，也都继承了C语言这一“优良传统”，因此就有了程序员数数是从0开始的这么一种说法。</p>
<p>讲到这里，想必大家也就会明白之前为什么我们在循环的时候，初始值都是设定为0的了。像这样：</p>
<pre><code class="language-c">for (i = 0; i &lt; 10; i++)
{
    ...
}
</code></pre>
<p>而不是像这样写(当然也没错)：</p>
<pre><code class="language-c">for (i = 1; i &lt;= 10; i++)
{
    ...
}
</code></pre>
<p>这就是因为，我们在使用循环的时候，经常会配合数组一起来使用，那么我们循环设置成和数组下标的计数方法一样，有利于我们使用数组。</p>
<p>还是回到我们最初的那个问题，存储班里面学生的成绩，然后计算出平均值：</p>
<pre><code class="language-c">//Example 01
#include &lt;stdio.h&gt;
int main(void)
{
    int s[10];//假定我们班上有10个人
    int i;
    double sum = 0;
    for (i = 0; i &lt; 10; i++)
    {
        printf(&quot;请输入第 %d 位同学的成绩：&quot;, i + 1);
            scanf(&quot;%d&quot;, &amp;s[i]);
        sum += s[i];
    }
    printf(&quot;成绩录入完毕，该次考试的平均分是：%.2f\n&quot;, sum/10);
    return 0;
}
</code></pre>
<p>程序实现如下：</p>
<pre><code>//Consequence 01
请输入第 1 位同学的成绩：80
请输入第 2 位同学的成绩：90
请输入第 3 位同学的成绩：70
请输入第 4 位同学的成绩：66
请输入第 5 位同学的成绩：77
请输入第 6 位同学的成绩：54
请输入第 7 位同学的成绩：67
请输入第 8 位同学的成绩：86
请输入第 9 位同学的成绩：78
请输入第 10 位同学的成绩：65
成绩录入完毕，该次考试的平均分是：73.30
</code></pre>
<h1 id="数组的初始化">数组的初始化</h1>
<p>在定义数组的时候同时对其<strong>各个元素</strong>进行赋值，称为数组的初始化。在刚刚的代码中，我们定义了数组，但却没有在定义的时候就初始化，而是在循环中进行赋值。那么初始化数组一般有下面几种方法：</p>
<ol>
<li>
<p>将数组中所有的元素初始化为0，可以这么写：</p>
<pre><code class="language-c">int a[10] = {0};
</code></pre>
</li>
<li>
<p>如果要赋予不同的值，用逗号分开即可：</p>
<pre><code class="language-c">int a[5] = {1, 2, 3, 4, 5};
</code></pre>
</li>
<li>
<p>给部分元素赋值，剩下的自动初始化为0：</p>
<pre><code class="language-c">int a[10] = {1, 2 ,3};//剩下的全部为0
</code></pre>
</li>
<li>
<p>也可以偷懒只给出每个元素的值，让编译器自己判断数组长度：</p>
<pre><code class="language-c">int a[] = {1, 2, 3, 4, 5};
</code></pre>
</li>
<li>
<p>C99中增加了一种特性，指定元素进行赋值，剩下的自动初始化为0。也就是说，可以针对不连续的几个元素赋值：</p>
<pre><code class="language-c">int a[10] = { [3] = 3, [5] = 5, [8] = 8 };//编译的时候记得加上-std=c99选项
</code></pre>
</li>
</ol>
<p>那可能你会说了，”你刚刚提到的一个问题还没解决呢！要是班里的人数变了怎么办呢？“</p>
<p>没错，我们现在就来解决下这个问题。</p>
<h1 id="可变长数组">可变长数组</h1>
<p>在C99标准推出之前，要求定义数组的时候，数组的维度必须是<strong>常量表达式</strong>或者<strong>const常量</strong>，但是C99标准中，支持了变量定义数组，那么，我们就可以将第一次的代码改成这样：</p>
<pre><code class="language-c">//Example 02
#include &lt;stdio.h&gt;
int main(void)
{
    int Member;
    printf(&quot;请输入班级人数：&quot;);
    scanf(&quot;%d&quot;, &amp;Member);
    int s[Member];//使用用户输入的值来确定数组的大小
    int i;
    float sum = 0;
    for (i = 0; i &lt; Member; i++)
    {
        printf(&quot;请输入第 %d 位同学的成绩：&quot;, i + 1);
            scanf(&quot;%d&quot;, &amp;s[i]);
        sum += s[i];
    }
    printf(&quot;成绩录入完毕，该次考试的平均分是：%.2f\n&quot;, sum/Menber);
    return 0;
}
</code></pre>
<p>这样，在开始存储成绩之前，先让使用者告诉程序班里有多少学生，该开辟多大的数组，然后就完美解决了人数变动的问题。</p>
<p>注意，这里的”可变长数组“是指的数组在程序运行的时候才<strong>确定长度</strong>，也就是说每一次运行都不一定一样。但是数组一旦被创建，在其生命周期内就不会再改变了，这是数组的<strong>根本特性</strong>。</p>
<p>但是，如果有的同学使用的是Visual Studio的话，是不支持C99的这个特性的(我也不知道为什么巨硬不支持，明明这么好的特性)，那么就只能使用<strong>动态分配</strong>的方法来创建数组。放在这里来讲的话有些超纲，后面会讲到。</p>
<h1 id="字符型数组">字符型数组</h1>
<p>还记得之前说过，C语言是没有字符串这种类型的。那么C语言处理字符串有两种方法：<strong>字符串常量</strong>和<strong>字符型数组</strong>。字符串常量是指用<strong>双引号</strong>括起来的字符串，一旦确定下来就<strong>无法改变</strong>。一般我们会更多地倾向于使用更加灵活的<strong>字符型数组</strong>。这样，数组中的每一个元素表示一个字符，当然还要多一位来表示<code>\0</code>。</p>
<p>那么接下来就讲讲字符串的一些方法，因为字符串实在是太重要了。</p>
<h2 id="获取字符串的长度">获取字符串的长度</h2>
<p>计算字符串的长度使用<code>strlen</code>函数（这是长度，不是尺寸）,这个函数包含在<code>string.h</code>中</p>
<pre><code class="language-c">#include &lt;string.h&gt;
...
size_t strlen ( const char * str );
</code></pre>
<p>这个方法是不包含字符串末尾的<code>\0</code>的。且看下面的例子：</p>
<pre><code class="language-c">//Example 03
#include &lt;stdio.h&gt;
#include &lt;string.h&gt;
int main(void)
{
    char str[] = &quot;I love Clang!&quot;;
    printf(&quot;sizeof str = %d\n&quot;, sizeof(str));
    printf(&quot;strlen str = %u\n&quot;, strlen(str));
    return 0;
}
</code></pre>
<p>运行结果如下：</p>
<pre><code>//Consequence 03
sizeof str = 14
strlen str = 13
</code></pre>
<p>除了验证不包含<code>\0</code>以外，我们还可以看到，<code>strlen</code>函数返回的是<code>size_t</code>而不是<code>int</code>。<code>size_t</code>被定义在<code>stddef.h</code>中，实际上就是<strong>无符号整型</strong>。</p>
<h2 id="复制字符串">复制字符串</h2>
<p>估计在第一次见到这个词的时候，你的大脑浮现出来的就是使用赋值符号<code>=</code>，但是，这是<strong>错的</strong>……</p>
<p>字符串的复制应该使用<code>strcpy</code>和<code>strncpy</code>来实现。</p>
<pre><code class="language-c">#include &lt;string.h&gt;
...
char *strcpy (char *dest, const char *src);
char *strncpy (char *dest, const char *src, size_t n);
</code></pre>
<p>不多废话，且看下面的例子：</p>
<pre><code class="language-c">//Example 04
#include &lt;stdio.h&gt;
#include &lt;string.h&gt;
int main(void)
{
	char str1[] = &quot;Original String&quot;;
	char str2[] = &quot;New String&quot;;
	char str3[100];
	strcpy(str1, str2);
	strcpy(str3, &quot;Successfully Copied&quot;);
	printf(&quot;\
str1: %s\n\
str2: %s\n\
str3: %s\n&quot;, \
		str1, str2, str3);
	return 0;
}
</code></pre>
<p>运行结果如下：</p>
<pre><code>//Consequence 04
str1: New String
str2: New String
str3: Successfully Copied
</code></pre>
<p>但是其实这个程序是<strong>有缺陷</strong>的。</p>
<p>我们可以看到，两个数组的长度其实<strong>不一样</strong>，我们现在是把短的复制到长的里面，那么不会有问题。如果上面的<code>str1</code>和<code>str2</code>对调一下，那么就极有可能出问题，这就是我们等会儿要讲的<strong>数组越界</strong>问题。</p>
<p>那么如何解决复制时的这个隐式bug呢？</p>
<p><strong>使用strncpy方法来复制</strong></p>
<p>如果超出的字符不是很多，那么程序有可能能够成功地运行。但是如果两者悬殊的话，那编译运行之后，程序会报<code>Segmentation fault</code>。</p>
<p>因此在复制的时候，我们应该确保不越界，在复制之后不溢出。那么使用<code>strncpy</code>函数，由于增加了一个参数来指定<strong>复制的字符个数</strong>，我们在编写代码的时候就可以规避这样的问题。</p>
<p>举个例子：</p>
<pre><code class="language-c">//Example 05
#include &lt;stdio.h&gt;
#include &lt;string.h&gt;
int main(void)
{
    char str1[] = &quot;TechZone was made by HarrisWilde&quot;;
    char str2[40];
    strncpy(str2, str1, 8);
    str2[8] = '\0';
    printf(&quot;%s\n&quot;, str2);
    return 0;
}
</code></pre>
<p>结果如下：</p>
<pre><code>//Consequence 05
TechZone
</code></pre>
<p>有一个地方要格外小心，<code>strncpy</code>函数<strong>并不会</strong>在字符串的末尾添加<code>\0</code>，因此在使用的时候要注意加上。</p>
<h2 id="连接字符串">连接字符串</h2>
<p>如果你想把一个字符串拼接到另一个后面的话，就可以使用<code>strcat</code>和<code>strncat</code>两个函数来实现。</p>
<pre><code class="language-c">#include &lt;string.h&gt;
...
char *strcat (char *dest, const char *src);
char *strncat (char *dest, const char *src, size_t n);
</code></pre>
<p>可以看到，这个函数的用法和上面复制字符串的用法完全相同，<code>strncat</code>也就是比<code>strcat</code>多了一个指定复制长度的参数罢了。</p>
<p>需要注意的是，这个函数<strong>会</strong>自动在末尾追加一个<code>\0</code>，这和复制不一样，要特别注意区分。</p>
<h2 id="比较字符串">比较字符串</h2>
<p>比较两个字符串，也和上面的一样，有两个类似的函数，<code>strcmp</code>和<code>strncmp</code>。</p>
<pre><code class="language-c">#include &lt;string.h&gt;
...
char *strcmp (char *dest, const char *src);
char *strncmp (char *dest, const char *src, size_t n);
</code></pre>
<p>采用这套函数来比较两个字符串是否相同的时候，如果两个字符串完全一致，那么返回的值为<code>0</code>。这个函数的原理是，从第一个字符开始，依次对比两个字符串中每个字符的ASCII，如果第一个字符串的ASCII小于第二个字符串对应的字符，那么返回一个小于<code>0</code>的数值（通常是<code>-1</code>），如果大于，那就会返回一个大于<code>0</code>的值（通常是<code>1</code>）。</p>
<p><code>strncmp</code>则是增加了一个参数，可以用来仅比较前面n个元素。</p>
<pre><code class="language-c">//Example 06
#include &lt;stdio.h&gt;
#include &lt;string.h&gt;
int main(void)
{
    char str1[10] = &quot;TechZone&quot;;
    char str2[20] = &quot;TechZone&quot;;
    if (!strcmp(str1, str2))
    {
        printf(&quot;Same!\n&quot;);
    }
    else
    {
        printf(&quot;Different!\n&quot;);
    }
    return 0;
}
</code></pre>
<p>运行结果为：</p>
<pre><code>//Consequence 06
Same!
</code></pre>
<h1 id="多维数组">多维数组</h1>
<p>有时候，使用数组来存储还是不够方便，比如，老师让你做一个全班全部科目的成绩的分析。如果利用我们刚刚所学习的数组知识，你可能会这么写：</p>
<pre><code class="language-c">//Example 07
#include &lt;stdio.h&gt;
int main(void)
{
    int chinese[50];
    int math[50];
    int English[50];
    int science[50];
    ...
}
</code></pre>
<p>但是如果我们使用二维数组的话，那么只需要定义一次就行了。</p>
<p>假设我们有6科。</p>
<p>那么就这样：</p>
<pre><code class="language-c">//Example 07 V2
#include &lt;stdio.h&gt;
int main(void)
{
    int score[6][50];
    ...
}
</code></pre>
<p>这其实就像一个表格一样，二维数组通常也被称为<strong>矩阵</strong>（matrix），将二维数组写成行和列的表示形式，可以形象地帮我们解决一些问题。</p>
<p>访问二维数组也和普通的数组一样，也是从<code>0</code>开始计数的，只不过下标随着维度的变化会增加罢了（比如二维数组就有2个下标）。</p>
<h2 id="二维数组的初始化">二维数组的初始化</h2>
<ol>
<li>
<p>二维数组在内存中是<strong>线性存放</strong>的，因此可以将所有的数据写在一个大括号内：</p>
<pre><code class="language-c">int a[2][3] = {1, 2, 3, 4, 5, 6};
</code></pre>
<p>这样就是先将第一行的三个元素初始化，然后再初始化第二行的元素。</p>
</li>
<li>
<p>为了更直观地表达我们可以这么写：</p>
<pre><code class="language-c">int a[2][3] = {
    {1, 2, 3},
    {4, 5, 6}
};
</code></pre>
</li>
<li>
<p>二维数组也可以仅对<strong>部分元素</strong>赋值：</p>
<pre><code class="language-c">int a[2][3] = {{1}, {4}};
</code></pre>
<p>这样写只是对各行的第一列元素赋值，其余的全部为0.</p>
</li>
<li>
<p>如果希望全部为0，那么可以这么写：</p>
<pre><code class="language-c">int a[2][3] = {0};
</code></pre>
</li>
<li>
<p>C99中增加的指定赋值的特性，这里也可以适用。其余未被操作的元素为<code>0</code>。</p>
<pre><code class="language-c">int a[2][3] = {[0][0] = 1, [1][2] = 6};
</code></pre>
</li>
<li>
<p>二维数组也可以偷懒，但是<strong>只有第一维度</strong>的元素个数可以不写，其他的都要写上：</p>
<pre><code class="language-c">int a[][3] = {
    {1, 2, 3},
    {4, 5, 6}
};
</code></pre>
</li>
</ol>
<h1 id="数组越界">数组越界</h1>
<p>我们刚刚说过了，我们在写程序的时候，尽量要把越界的情况通过代码的努力来规避。那么，可能有的小伙伴比较感兴趣，如果越界了，会发生什么呢？</p>
<p>那好，咱们就来试试。</p>
<pre><code class="language-c">//Example 08
#include &lt;stdio.h&gt;

void f();

int main(void)
{
    f();
    return 0;
}

void f()
{
    int a[10];
    a[10] = 0;//这里我们写到了一个不存在的下标里面
}
</code></pre>
<p>我们来跑一下这个程序。</p>
<p>笔者使用的Visual Studio 2019给出了以下的错误提示：</p>
<pre><code>//Consequence 08
Run-Time Check Failure #2 - Stack around the variable 'a' was corrupted.
</code></pre>
<p>它发现了我在写入一个<strong>错误的地址</strong>。并且还给了我两个<strong>warning</strong>：</p>
<pre><code>警告	C6201	索引“10”超出了“0”至“9”的有效范围(对于可能在堆栈中分配的缓冲区“a”)。
警告	C6386	写入到“a”时缓冲区溢出: 可写大小为“40”个字节，但可能写入了“44”个字节。	
</code></pre>
<p>如果我们像普通程序员一样，不管代码warning，直接强制执行，试试会发生什么。</p>
<p>为了更直观体现，我们把代码改成这样：</p>
<pre><code class="language-c">//Example 08
#include &lt;stdio.h&gt;

void f();

int main(void)
{
    f();
    printf(&quot;Here\n&quot;);//我们加了这句，如果函数正常执行完毕了，就可以看到这个语句的输出
    return 0;
}

void f()
{
    int a[10];
    a[10] = 0;
}
</code></pre>
<p>还是出现了这句：</p>
<pre><code>Run-Time Check Failure #2 - Stack around the variable 'a' was corrupted.
</code></pre>
<p>控制台上面没有看到<code>Here</code>的输出，说明函数还没有执行完，程序就已经<strong>崩溃</strong>了，根本没办法执行到输出。</p>
<p>但是，为什么编译器没有给我<strong>error</strong>，而是给了我<strong>warning</strong>呢？</p>
<p>有的编译器可能连warning都没有。</p>
<p>实际上，我们在对<code>a[10]</code>写入的时候，其实是<strong>成功</strong>了的。只不过我们把<code>a[10]</code>写在了一个<strong>不该写的地方</strong>（实际上就是这段数组内存的后面），干扰到了其他东西的运行，程序就有可能会崩溃。如果后面的内存为空或者是没有被回收的垃圾内存，那么就没关系，但是如果是有用的内存，出问题就很正常了。</p>
<p>有时候我们写了一个程序，可能这次运行没问题，下一次运行就出错，或者是在我的电脑上可以，在你的电脑上就不行了等等，都有可能是数组越界，或者是我们后面要学的指针出错了。我们作为创造代码的人，有责任通过代码上的设计，来规避这样的问题，避免程序的崩溃。</p>
<h1 id="长度为0的数组">长度为0的数组？</h1>
<p>有的同学可能会异想天开，说，我可不可以定义一个长度为0的数组呢？</p>
<p>类似于这样：</p>
<pre><code class="language-c">int a[0];
</code></pre>
<p>答案是，完全没问题！</p>
<p>不信的话可以去试试，编译可以通过的，只不过这样的数组不存在任何意义，因为没有符合要求的下标。我们说，最大的下标就是元素个数-1，那么<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>0</mn><mo>−</mo><mn>1</mn><mo>=</mo><mo>−</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">0-1=-1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.72777em;vertical-align:-0.08333em;"></span><span class="mord">0</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.72777em;vertical-align:-0.08333em;"></span><span class="mord">−</span><span class="mord">1</span></span></span></span>，-1显然不是一个合法的下标。所以这样的操作可行，但是没有任何意义。</p>
<p>好了，本节内容就到这里了，希望你能够从中有所收获哦！</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[杂谈·一个神一般的随机算法]]></title>
        <id>https://harriswilde.github.io/post/GreatRandom</id>
        <link href="https://harriswilde.github.io/post/GreatRandom">
        </link>
        <updated>2019-11-15T02:31:28.000Z</updated>
        <content type="html"><![CDATA[<p>这篇文章，我们从一个经典的面试题开始讲起。这个题目，可能会有很多形式，但是背后的逻辑是一样的：<strong>如何写出一个公平的洗牌算法</strong>。</p>
<p>洗牌嘛，不就是个随机算法吗？直接搞一个数组，把牌全部放进去，然后对调两张牌，随机k次即可。</p>
<p>你要敢这样回答，那面试官肯定会问，k取多少呢？</p>
<p>显然不能是个常量，如果你取10,000，如果只有100张牌，显然太多了，如果有100,000张呢？又太少了。</p>
<p>那你可能会想，让k随着牌的数量变化不就行了？嗯，的确，这个想法已经比刚刚的强很多了，但是你要敢这么回答，面试官多半会坏笑然后问你，你这个算法，公平吗？<br>
再回去看看问题：如何写出一个<strong>公平</strong>的洗牌算法。</p>
<p>刚刚忙活了那么久，其实连问题的本质都没有触及。这题的关键，在于设计<strong>公平</strong>。</p>
<hr>
<p>一个面试官面试，往往看的不是你是否答对了问题，因为一道面试题，答案不只一种。如果你有对题目足够强的<strong>思维能力</strong>，你就是面试官要的人。如果你看到这道题，一开始就是从<strong>公平</strong>入手，那么你是很优秀的。因为背出一个算法很容易，但是这种探求问题根源的思维角度，绝不是一朝之功。这是一种不断面对问题，不断解决问题而逐渐锻炼出来的能力。</p>
<hr>
<p>那么我们就来看看，对于这个算法，公平的定义是什么。</p>
<p>如果有n张牌，那么排序的可能性就是<strong>n!</strong>。我们可以生成所有的可能性，然后随机选一个。这种算法是<strong>绝对公平</strong>的。但是，复杂度太高。这个复杂度达到了<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo>(</mo><mi>n</mi><mo>!</mo><mo>)</mo></mrow><annotation encoding="application/x-tex">O(n!)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mclose">!</span><span class="mclose">)</span></span></span></span>。因为我们需要计算<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>n</mi><mo>!</mo></mrow><annotation encoding="application/x-tex">n!</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault">n</span><span class="mclose">!</span></span></span></span>种排列，那么就至少需要<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>n</mi><mo>!</mo></mrow><annotation encoding="application/x-tex">n!</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault">n</span><span class="mclose">!</span></span></span></span>的时间。</p>
<p>有的同学可能对这样的复杂度不太感冒。这是一个比<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msup><mn>2</mn><mi>n</mi></msup></mrow><annotation encoding="application/x-tex">2^n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.664392em;vertical-align:0em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.664392em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">n</span></span></span></span></span></span></span></span></span></span></span>还要高的复杂度。<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msup><mn>2</mn><mi>n</mi></msup></mrow><annotation encoding="application/x-tex">2^n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.664392em;vertical-align:0em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.664392em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">n</span></span></span></span></span></span></span></span></span></span></span>是n个2相乘，而<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>n</mi><mo>!</mo></mrow><annotation encoding="application/x-tex">n!</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault">n</span><span class="mclose">!</span></span></span></span>也是n个数，而这些数<strong>除了1比2小</strong>以外，其他的数都≥2。而<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msup><mn>2</mn><mi>n</mi></msup></mrow><annotation encoding="application/x-tex">2^n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.664392em;vertical-align:0em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.664392em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">n</span></span></span></span></span></span></span></span></span></span></span>已经是指数爆炸了，在n≥4的时候，<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>n</mi><mo>!</mo></mrow><annotation encoding="application/x-tex">n!</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault">n</span><span class="mclose">!</span></span></span></span>以极快的速度超越<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msup><mn>2</mn><mi>n</mi></msup></mrow><annotation encoding="application/x-tex">2^n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.664392em;vertical-align:0em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.664392em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">n</span></span></span></span></span></span></span></span></span></span></span>。</p>
<p>这个算法的确是公平的，但是<strong>时间不能允许</strong>。</p>
<hr>
<p>我们再换一种角度去思考公平的问题。公平其实也可以理解为，我们每一张牌出现在<strong>每一个位置的概率</strong>都相等。这个定义和上面提到的暴力算法其实是等价的，学过概率论的同学可以去证明下。根据这个定义，我们就可以很快写出一个简单的算法：</p>
<pre><code class="language-c">for (int i = n-1; i &gt;= 0; i--)
    swap(arr[i], arr[rand() % (i +1)]);
</code></pre>
<p>说它简单，是因为就一层循环。</p>
<p>小伙伴们可以看看这个循环在干什么。其实就是将下标为i的元素，和一个随机下标的元素<strong>交换位置</strong>。而为了确保随机的数在[0,i]的范围内，我们用了取余运算除以(i+1)。</p>
<p><strong>这个算法就是大名鼎鼎的 Knuth-Shuffle，即 Knuth 洗牌算法。</strong></p>
<p>原理待会儿再讲，我们先来看看这个传奇般的人物。</p>
<p>中文名:高纳德。算法理论的创始人。我们现在所使用的各种算法复杂度分析的符号，就是他发明的。上世纪60-70年代计算机算法的黄金时期,近乎就是他一手主导的。他的成就实在是太多，一本书估计都写不完。</p>
<p>大家最津津乐道的，就是他所写的《The Art of Computer Programming 》，简称TAOCP 。这套书准备写七卷，然后，到今天还没有写完，但已经被《科学美国人》评为可以媲美相对论的巨著。微软还是IT界老大的时代，盖茨就说过，如果你看完了这套书的第一卷本，<strong>那你直接给我发简历</strong>。<br>
<img src="http://upload-images.jianshu.io/upload_images/19749646-76ae42612182d1bb.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1440/q/50" alt="TAOCP" loading="lazy"></p>
<p>至于这套书为什么写这么慢，因为老头子当时写这本书，写到一半觉得时下的排版工具都太烂了，<strong>于是转手就发明了现在流行的LaTeX……</strong></p>
<p>另外，他可能也觉得当时的所有编程语言都无法描述自己的思想，于是自己发明了一套抽象逻辑语言用于展示这套书的逻辑部分……</p>
<p>（感受到了和大佬的差距）</p>
<p>下面这句话，和大家共勉：</p>
<blockquote>
<p>A programmer who subconsciously views himself as an artist will enjoy what he does and will do it better.<br>
——Donald E. Knuth 1978</p>
</blockquote>
<hr>
<p>下面就来看看具体是怎么通过这样一个简单的算法来实现绝对公平的。</p>
<p>其实，可怕的地方，就在于<strong>太简单</strong>……<br>
我们用5个数字来简单模拟下这个算法：</p>
<blockquote>
<p>1 2 3 4 5</p>
</blockquote>
<p>这个算法，会在5个元素中选出一个元素和最后一个元素交换。假设我们选择3。就变成这样：</p>
<blockquote>
<p>1 2 5 4 3</p>
</blockquote>
<p>那么这个3出现在最后的概率是多少呢？从5个里面挑嘛，那肯定是<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mfrac><mn>1</mn><mn>5</mn></mfrac></mrow><annotation encoding="application/x-tex">\frac{1}{5}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.190108em;vertical-align:-0.345em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.845108em;"><span style="top:-2.6550000000000002em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">5</span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.394em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.345em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span>嘛。</p>
<p>再选一个，假设选到了1，那么就变成这样：</p>
<blockquote>
<p>4 2 5 1 3</p>
</blockquote>
<p>这个1出现在这个位置的概率又是多少呢？</p>
<p>上面那一轮，1没被挑走，而这一轮里面挑走了。</p>
<p class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mfrac><mn>4</mn><mn>5</mn></mfrac><mo>×</mo><mfrac><mn>1</mn><mn>4</mn></mfrac><mo>=</mo><mfrac><mn>1</mn><mn>5</mn></mfrac></mrow><annotation encoding="application/x-tex">\frac{4}{5}\times\frac{1}{4}=\frac{1}{5}
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:2.00744em;vertical-align:-0.686em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.32144em;"><span style="top:-2.314em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">5</span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.677em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">4</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.686em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:2.00744em;vertical-align:-0.686em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.32144em;"><span style="top:-2.314em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">4</span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.677em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.686em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:2.00744em;vertical-align:-0.686em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.32144em;"><span style="top:-2.314em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">5</span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.677em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.686em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span></span></p>
<p>还是等于<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mfrac><mn>1</mn><mn>5</mn></mfrac></mrow><annotation encoding="application/x-tex">\frac{1}{5}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.190108em;vertical-align:-0.345em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.845108em;"><span style="top:-2.6550000000000002em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">5</span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.394em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.345em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span>！</p>
<p>继续，假设这次是2。</p>
<blockquote>
<p>4 5 2 1 3</p>
</blockquote>
<p>概率依旧</p>
<p class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mfrac><mn>4</mn><mn>5</mn></mfrac><mo>×</mo><mfrac><mn>3</mn><mn>4</mn></mfrac><mo>×</mo><mfrac><mn>1</mn><mn>3</mn></mfrac><mo>=</mo><mfrac><mn>1</mn><mn>5</mn></mfrac></mrow><annotation encoding="application/x-tex">\frac{4}{5}\times\frac{3}{4}\times\frac{1}{3}=\frac{1}{5}
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:2.00744em;vertical-align:-0.686em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.32144em;"><span style="top:-2.314em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">5</span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.677em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">4</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.686em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:2.00744em;vertical-align:-0.686em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.32144em;"><span style="top:-2.314em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">4</span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.677em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">3</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.686em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:2.00744em;vertical-align:-0.686em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.32144em;"><span style="top:-2.314em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">3</span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.677em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.686em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:2.00744em;vertical-align:-0.686em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.32144em;"><span style="top:-2.314em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">5</span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.677em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.686em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span></span></p>
<p>假设下一个是4，那么</p>
<blockquote>
<p>5 4 2 1 3</p>
</blockquote>
<p>概率</p>
<p class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mfrac><mn>4</mn><mn>5</mn></mfrac><mo>×</mo><mfrac><mn>3</mn><mn>4</mn></mfrac><mo>×</mo><mfrac><mn>2</mn><mn>3</mn></mfrac><mo>×</mo><mfrac><mn>1</mn><mn>2</mn></mfrac><mo>=</mo><mfrac><mn>1</mn><mn>5</mn></mfrac></mrow><annotation encoding="application/x-tex">\frac{4}{5}\times\frac{3}{4}\times\frac{2}{3}\times\frac{1}{2}=\frac{1}{5}
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:2.00744em;vertical-align:-0.686em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.32144em;"><span style="top:-2.314em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">5</span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.677em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">4</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.686em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:2.00744em;vertical-align:-0.686em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.32144em;"><span style="top:-2.314em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">4</span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.677em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">3</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.686em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:2.00744em;vertical-align:-0.686em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.32144em;"><span style="top:-2.314em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">3</span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.677em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.686em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:2.00744em;vertical-align:-0.686em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.32144em;"><span style="top:-2.314em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">2</span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.677em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.686em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:2.00744em;vertical-align:-0.686em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.32144em;"><span style="top:-2.314em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">5</span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.677em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.686em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span></span></p>
<p>而这样5就只能在第一个位置了，概率还是</p>
<p class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mfrac><mn>4</mn><mn>5</mn></mfrac><mo>×</mo><mfrac><mn>3</mn><mn>4</mn></mfrac><mo>×</mo><mfrac><mn>2</mn><mn>3</mn></mfrac><mo>×</mo><mfrac><mn>1</mn><mn>2</mn></mfrac><mo>=</mo><mfrac><mn>1</mn><mn>5</mn></mfrac></mrow><annotation encoding="application/x-tex">\frac{4}{5}\times\frac{3}{4}\times\frac{2}{3}\times\frac{1}{2}=\frac{1}{5}
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:2.00744em;vertical-align:-0.686em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.32144em;"><span style="top:-2.314em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">5</span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.677em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">4</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.686em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:2.00744em;vertical-align:-0.686em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.32144em;"><span style="top:-2.314em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">4</span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.677em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">3</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.686em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:2.00744em;vertical-align:-0.686em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.32144em;"><span style="top:-2.314em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">3</span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.677em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.686em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:2.00744em;vertical-align:-0.686em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.32144em;"><span style="top:-2.314em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">2</span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.677em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.686em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:2.00744em;vertical-align:-0.686em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.32144em;"><span style="top:-2.314em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">5</span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.677em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.686em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span></span></p>
<p>大家看到了，自始至终，所有的位置出现的概率<strong>都是相等的</strong>，如果数组长度是n，那么每个位置的概率就是<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mfrac><mn>1</mn><mi>n</mi></mfrac></mrow><annotation encoding="application/x-tex">\frac{1}{n}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.190108em;vertical-align:-0.345em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.845108em;"><span style="top:-2.6550000000000002em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">n</span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.394em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.345em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span>，而复杂度<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo>(</mo><mi>n</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mclose">)</span></span></span></span>，比<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo>(</mo><mi>n</mi><mo>!</mo><mo>)</mo></mrow><annotation encoding="application/x-tex">O(n!)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mclose">!</span><span class="mclose">)</span></span></span></span>少了太多太多……</p>
<p>这个算法不仅仅可以用来洗牌，很多场景下的随机都可以使用。大家可以自己思考下，也可以运用于实际的解题甚至是开发之中。</p>
<p>其实大家应该有感觉了，<strong>算法绝对不是枯燥的逻辑堆砌，而是神一般的逻辑创造</strong>。这个世界也是如此，尽管极其复杂，变化万千，但又竟是如此简洁，巧妙而优雅…</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[C语言的分支与循环]]></title>
        <id>https://harriswilde.github.io/post/CBranchCycle</id>
        <link href="https://harriswilde.github.io/post/CBranchCycle">
        </link>
        <updated>2019-11-07T02:24:12.000Z</updated>
        <content type="html"><![CDATA[<p>如果说我们之前写过的代码都是“直男”，也就是说不管三七二十一，一路走到黑，那么今天我们就来见识下“多虑”型的还有“徘徊”型的代码。（你没有看错，代码不仅可以犹豫，还可以徘徊）</p>
<p>不过，在这之前，我还是来介绍两个之前就应该讲到的知识，与下文可能关系不大，但是放哪儿讲都差不多。</p>
<h1 id="字符串">字符（串）</h1>
<p>我们其实已经知道了C语言只有<strong>字符</strong>一种变量，就是<code>char</code>，而并没有像某些语言那样规定<strong>字符串</strong>这种类型。但是，是不是字符串在C语言里面就没有呢？</p>
<p>其实不然，只不过没有专属的类型而已。</p>
<p>定义一个字符的的方法，想必大家都已经掌握了，就像下面这个例子一样：</p>
<pre><code class="language-c">//Example 01
#include &lt;stdio.h&gt;
int main(void)
{
    char Letter;
    Letter = 'A';
    return 0;
}
</code></pre>
<p>这样，我们就定义了一个叫Letter的字符变量,并且赋值为字符A。</p>
<p>那么字符串该如何定义呢？</p>
<pre><code class="language-c">//Example 02
#include &lt;stdio.h&gt;
int main(void)
{
    char String[8];
    String = {'T','e','c','h','Z','o','n','e'};
    printf(&quot;%s&quot;,String);
    return 0;
}
</code></pre>
<p>这样，我们就定义了一个名字叫String的<strong>字符串</strong>，还让它输出到我们屏幕上了。如果你了解过<strong>数组</strong>，就觉得这种方式很像数组对吧，这里提前告诉大家，<strong>字符串就是一种数组</strong>。但是，如果你去执行下这段代码你就会发现问题了。输出的TechZone后面，还会跟着一些乱码……</p>
<p>咦？我明明只定义了8个字符，怎么还多出来这些鬼东西呢？</p>
<p>那么，我们来了解下C语言时如何处理字符串的。我们可以理解，字符串的长度是有限的，而且长度<strong>一旦确定</strong>，在其生命周期里就<strong>无法再次更改</strong>。那么，系统为了确保字符串是真的结束了，会在<strong>末尾</strong>加一个<code>\0</code>来表示字符串的结束。我们做如下的修改，就可以让字符串正常工作了：</p>
<pre><code class="language-c">//Example 03
#include &lt;stdio.h&gt;
int main(void)
{
    char String[9];
    String = {'T','e','c','h','Z','o','n','e','\0'};
    printf(&quot;%s&quot;,String);
    return 0;
}
</code></pre>
<p>你可能会想了，这样也太麻烦了吧，要是我要输入一句话，那得多少个引号逗号，最后还可能忘记加\0。你这是把程序员不当人看？？</p>
<p>当然不会。我们可以这样定义：</p>
<pre><code class="language-c">//Example 04
#include &lt;stdio.h&gt;
int main(void)
{
    char String[];
    String = {&quot;TechZone&quot;};
    printf(&quot;%s&quot;,String);
    return 0;
}
</code></pre>
<p>看到了吧，是不是简单很多了？而且后面还会<strong>自动补上</strong>一个<code>\0</code>，简直就是高枕无忧了。</p>
<p>有人可能有意见了，说你怎么不早点告诉我，害得我差点不学了……</p>
<p>学习当然得从学基础的开始啦，别打我，别打我……</p>
<h1 id="强制类型转换">强制类型转换</h1>
<p>在<strong>操作数不同</strong>的情况下，大部分的运算符中，都会将<strong>精度低</strong>的类型转成<strong>精度高</strong>的类型，这样做，其实也就是为了确保精度罢了。</p>
<p>但是有的时候，我们也许并不希望像系统那样的转换，那么我们可以自己进行强制转换。</p>
<p>具体方法：<code>(类型名称)变量名或值</code></p>
<p>例如：</p>
<pre><code class="language-c">//Example 05
#include &lt;stdio.h&gt;
int main(void)
{
    int num;
    num = (float)5/9;
    printf(&quot;%d&quot;,num);
    return 0;
}
</code></pre>
<p>在这个例子中，我们将5这个<strong>整型</strong>转化成了<strong>浮点型</strong>，那么为了确保精度，系统也会将后面的9也转化成浮点型。那么这样就可以输出结果，不然结果就是0（因为两个整型相除结果也会<strong>取整</strong>，然鹅，强制取整的结果就是<strong>保留整数</strong>，而<strong>不是</strong>四舍五入）。</p>
<hr>
<h1 id="分支条件语句">分支(条件语句)</h1>
<p>我们高中数学中，如果有学过程序框图的同学，应该就还依稀记得程序的几种结构，其中<strong>分支</strong>和<strong>循环</strong>就是今天要谈的两大结构。</p>
<p>首先我们来看看一些分支里面经常使用的运算符：</p>
<ol>
<li>
<p>关系运算符</p>
<table>
<thead>
<tr>
<th>运算符</th>
<th>优先级</th>
</tr>
</thead>
<tbody>
<tr>
<td>&lt;</td>
<td>高</td>
</tr>
<tr>
<td>&lt;=</td>
<td>高</td>
</tr>
<tr>
<td>&gt;</td>
<td>高</td>
</tr>
<tr>
<td>&gt;=</td>
<td>高</td>
</tr>
<tr>
<td>==</td>
<td>低</td>
</tr>
<tr>
<td>!=</td>
<td>低</td>
</tr>
</tbody>
</table>
</li>
<li>
<p>逻辑运算符</p>
<table>
<thead>
<tr>
<th>运算符</th>
<th>优先级</th>
</tr>
</thead>
<tbody>
<tr>
<td>!    (逻辑非)</td>
<td>高</td>
</tr>
<tr>
<td>&amp;&amp;(逻辑与)</td>
<td>中</td>
</tr>
<tr>
<td>||   (逻辑或)</td>
<td>低</td>
</tr>
</tbody>
</table>
</li>
</ol>
<p>此外，在编译器中，所有的字符都被看成ASCII，因此ASCII字符之间运算或者比较等等都是<strong>合法的</strong>。</p>
<h2 id="短路求值">短路求值</h2>
<p>在C语言中，如果设置两个表达式，在求出<strong>第一个式子</strong>即可判断出结果的时候，系统就<strong>不会</strong>继续求第二个式子。这看上去是编译器的一种算法的优化，但是如果写代码的时候不注意的话，很有可能造成一些隐性的漏洞，看下面的例子：</p>
<pre><code class="language-c">//Example 06
#include &lt;stdio.h&gt;
int main(void)
{
    int a = 3,b = 3;
    (a = 0) &amp;&amp; (b = 5);
    printf(&quot;a=%d, b=%d\n&quot;,a,b);
    //==========================
    (a = 1) || (b = 5);
    printf(&quot;a=%d, b=%d\n&quot;,a,b);
    return 0;
}
</code></pre>
<p>如果你愿意自己尝试的话，可以自己去环境里面试试，如果不愿意的话那直接看下面的结果：</p>
<pre><code>//Consequence 06
a=0,b=3
a=1,b=3
</code></pre>
<p>如果没有开头的那段解释，我相信很多初学者都会很懵逼，怎么会这样？</p>
<p>不着急，我们来分析下代码。</p>
<p>我们看看分割线上面的那部分，a和b都被初始化成了整型并且赋值为3。在第一句逻辑判断语句里面，是判断的<strong>逻辑与</strong>，也就是说，<strong>全真则真，一假全假</strong>。那么在判断数字的时候，则默认0为假，非0为真。那么这句<code>(a = 0) &amp;&amp; (b = 5);</code>前面，a已经被赋值为0，那么已经为假了，在逻辑与的情况下，就算后面的条件再真，整体也是假的了，这就是所谓的<strong>一假全假</strong>。那么，在判断了第一个表达式之后，就可以做出判断结果，那么后面的<code>b=5</code>就<strong>不会</strong>被执行。</p>
<p>同理，分割线下面的代码也是一个道理。只不过这里判断变成了<strong>逻辑或</strong>。逻辑或的标准就是<strong>一真则真，全假才假</strong>。那么，前面的<code>a=1</code>，系统发现，欸，已经是真了哟！那么马上罢工，后面的<code>b=5</code>也就<strong>不予理会</strong>了。那么输出的结果就是上面那样了，理解了吧？</p>
<p>我们现在单独这样讲这个特性，貌似感觉看不出什么，但是以后写代码的时候其实要留意下短路求值，因为这样子可能就会造成你的程序里面有Bug，而且还相当<strong>不好找</strong>！！</p>
<h2 id="if语句">if语句</h2>
<p>if语句实际上就是判断条件，若符合的就输出。之所以叫它分支，那是因为如果到了条件语句，那么这里面的代码就<strong>不一定都能</strong>执行了，而是看情况来。也就是说，条件语句里面的<strong>部分代码</strong>，可能你的程序跑完了都没有没用到，因此就叫分支。</p>
<p>那么if语句的通式就像下面那样</p>
<pre><code class="language-c">if (...)
{
    ...;
}
else if (...)//可选
{
    ...;
}
else if (...)//可选
{
    ...;
}
...;//else if可有多个
else //上述条件都不符合，则执行这个语句，可选
{
    ...;
}
</code></pre>
<p>我想大家看里面的注释就能够大致明白的差不多了。其中if语句是<strong>必须</strong>的，其他的是<strong>可选</strong>的。else if则表示的是当if的条件不符合的时候，就会继续判断所有的else if，若有符合条件的就执行后面的语句，若都不符合就执行else的语句。如果没有else if而有else，那么当if不符合的时候就执行else后面的语句。若有else if没有else，则无符合条件的话不执行任何语句。else if和else都没有的话，那么if不符合的时候就啥都不干。</p>
<p>看下面的例子，我们来制作一个识别星期的程序并且给出建议：</p>
<pre><code class="language-c">//Example 07
#include &lt;stdio.h&gt;
int main(void)
{
    int Weekday;
    printf(&quot;输入今天星期的数字：&quot;);
    scanf(&quot;%d&quot;,&amp;Weekday);//此处用于获取用户输入的内容并赋值给Weekday
    if (Weekday &gt;= 1 &amp;&amp; WeekDay &lt;= 5)
    {
        printf(&quot;今天是工作日！好好工作！\n&quot;);
    }
    else if (Weekday &gt;=6 &amp;&amp; Weekday &lt;=7)
    {
        printf(&quot;今天是周末！好好休息！&quot;);
    }
    else
    {
        printf(&quot;你输入有误哦！&quot;);
    }
    return 0;
}
</code></pre>
<p>看到了吧，我们成功地运用了分支。这个只是一个简单的例子，以后大家写程序的时候，大概就没有这么简单的了。很多情况下，我们需要<strong>嵌套分支</strong>来使用。那么嵌套的时候，有些地方就要注意了，下面引用一个例子：</p>
<pre><code class="language-c">//Example 08
#include &lt;stdio.h&gt;
int main(void)
{
    char isRain,isFree;
    
    printf(&quot;是否有空？（Y/N）&quot;);
    scanf(&quot;%c&quot;,&amp;isFree);
    
    printf(&quot;是否下雨？（Y/N）&quot;);
    scanf(&quot;%c&quot;,&amp;isRain);
    
    if (isFree == 'Y' || isFree == 'y')
        if (isRain == 'Y' || isRain == 'y')
            printf(&quot;记得带伞哦！\n&quot;);
    else 
        printf(&quot;女神没空！\n&quot;);
    return 0;
}
</code></pre>
<p>程序实现如下：</p>
<pre><code>//Consequence 08-1
是否有空？（Y/N）Y
是否下雨？（Y/N）Y
记得带伞哦！
</code></pre>
<p>貌似没什么问题，但是如果下面这样：</p>
<pre><code>//Consequence 08-2
是否有空？（Y/N）Y
是否下雨？（Y/N）N
女神没空！
</code></pre>
<p>我的天，女神有空而且天公作美的情况下，程序居然告诉我女神没空？？？</p>
<p>其实我们分析下代码。代码的意思，大概是先在有空的情况下，如果下雨就提醒带伞，如果没空就直接告诉你没空。可是上面的问题是怎么回事呢？</p>
<p>其实你们被上面的<strong>缩进</strong>骗了。从上面的缩进来看，else应该是与第一个if同级，而不是第二个。但是！由于你<strong>没有</strong>加大括号，C语言没法判断你的语句块从属关系，那么就<strong>默认</strong>else跟随<strong>最近</strong>的那一个if。所以，这里的else是跟随第二个if的，这么看就不难理解输出结果了。如果要更改，那么像下面这样就可以了：</p>
<pre><code class="language-c">//Example 08 V2
#include &lt;stdio.h&gt;
int main(void)
{
    char isRain,isFree;
    
    printf(&quot;是否有空？（Y/N）&quot;);
    scanf(&quot;%c&quot;,&amp;isFree);
    
    printf(&quot;是否下雨？（Y/N）&quot;);
    scanf(&quot;%c&quot;,&amp;isRain);
    
    if (isFree == 'Y' || isFree == 'y')
    {
        if (isRain == 'Y' || isRain == 'y')
        {
            printf(&quot;记得带伞哦！\n&quot;);
        }
    }
    else 
        printf(&quot;女神没空！\n&quot;);
    return 0;
}
</code></pre>
<p>建议所有的if都打上大括号，至于怎么打，是个人习惯，比如<code>{</code>是打在if之后还是下一行，这都无所谓，但是确定了就尽量使用一种，不然以后自己看自己写的代码都会感觉很奇怪了。</p>
<h2 id="switch-语句">switch 语句</h2>
<p>虽然if语句十分方便而且灵活，但是在某些情况下，使用switch还是会更直观一些。</p>
<p>switch的通式为：</p>
<pre><code class="language-c">switch(变量名)
{
    case 常量1:语句1;break;
    case 常量2:语句2;break;
    case 常量3:语句3;break;
    case 常量4:语句4;break;
    case 常量5:语句5;break;
    case 常量6:语句6;break;
        ...
    case 常量n:语句n;break;
    default 常量:语句;break;
}
</code></pre>
<p>switch语句中case后面只能跟一个<strong>确定的值</strong>，而不能是范围等等。所以在特定的条件下会很直观，但是不够灵活。</p>
<p>比如上面Example 07中的代码，用switch可以这么改写：</p>
<pre><code class="language-C">//Example 07 V2
#include &lt;stdio.h&gt;
int main(void)
{
    int (Weekday);
    printf(&quot;输入今天星期的数字：&quot;);
    scanf(&quot;%d&quot;,&amp;Weekday);//此处用于获取用户输入的内容并赋值给Weekday
    switch Weekday
    {
        case 1:printf(&quot;今天周一，一鼓作气&quot;);break;
        case 2:printf(&quot;今天周二，再接再厉&quot;);break;
        case 3:printf(&quot;今天周三，坚持到底&quot;);break;
        case 4:printf(&quot;今天周四，效率第一&quot;);break;
        case 5:printf(&quot;今天周五，最后一击&quot;);break;
        case 6:printf(&quot;今天周六，好好休息&quot;);break;
        case 7:printf(&quot;今天周日，玩的开心&quot;);break;
        default:printf(&quot;你输入的有误哦！&quot;);break;
    }
}
</code></pre>
<p>这样一来是不是很直观呢？但是虽然直观，不是所有的时候都适合用这样的语句，大家根据自身的情况来选就行啦。</p>
<p>至于为什么一定要加break，那是因为其实case在这里面只是一个<strong>标记</strong>而已，也就是说，如果我满足case3，那么程序就自动<strong>跳到</strong>case3，然后<strong>继续往下</strong>执行。假设我一共有case7，那么不加break的话，case3一直到case7的语句都会被<strong>逐个执行</strong>，明白了吧？</p>
<hr>
<h1 id="循环">循环</h1>
<p>上面分支讲了那么多，现在我们来看看循环。</p>
<p>可以说，循环的出现，大大减少了程序员的工作量。而且正因为有了循环，程序员才能够通过巧妙的算法来使用循环去解决问题。比如，我现在想输出1-100之间的所有整数，如果没学循环，你可能会这么写：</p>
<pre><code class="language-c">//Example 09
#include &lt;stdio.h&gt;
int main(void)
{
    printf(&quot;1\n&quot;);
    printf(&quot;2\n&quot;);
    printf(&quot;3\n&quot;);
    ...
    printf(&quot;100\n&quot;);
    return 0;
}
</code></pre>
<p>这样写的逻辑思路没有错，但是谁会愿意呢？这样的编程有什么意义？我还不如拿一张纸记下来还更快呢。但是，我们是可以发现其中的规律的，就是每次输出都比之前的数大1，对吧？这就是接下来要讲的循环。</p>
<h2 id="while循环">while循环</h2>
<p>while循环也就是我们所说的<strong>当型循环</strong>。它的通式是：</p>
<pre><code>while(条件表达式)
	循环体
</code></pre>
<p>当满足一定的条件的时候，程序会自动循环写在循环体中的代码。比如上面的例子09中所体现出的，输出1-100。那么我们实现思路可以先设置一个变量，让这个变量<strong>每循环一次就加个1</strong>，然后当加到101的时候停止即可。写成代码如下：</p>
<pre><code class="language-c">//Example 09 V2
#include &lt;stdio.h&gt;
int main(void)
{
    int i = 1;
    while (i &lt; 101)
    {
        printf(&quot;%d\n&quot;,i);
        i++;
    }
    return 0;
}
</code></pre>
<p>这样，程序就自动执行输出我们想要的结果了，比一个一个手动要快了太多。</p>
<h2 id="do-while循环">do-while循环</h2>
<p>如果说while循环是个君子，那么do-while就是莽夫。while是<strong>先判断再执行</strong>，而本少爷则是管他什么，<strong>先执行再说</strong>。你可能已经猜到了，这就是直到型循环。do-while的语句通式如下：</p>
<pre><code class="language-c">do
    循环体
while (条件表达式);//(注意，这里有分号)
</code></pre>
<p>比如我们要算1加到100的和，也可以通过上面的例子用do-while进行更改：</p>
<pre><code class="language-c">//Example 09 V3
#include &lt;stdio.h&gt;
int main(void)
{
    int i = 1,sum = 0;
    do
    {
        sum += i;
        i++;
    }
    while (i&lt;101);
    printf(&quot;结果是%d\n&quot;,sum);
    return 0;
}
</code></pre>
<p>这次就不是每次都输出i了，而是每次吧i的值加到sum里面去，这样就可以算出最终结果了。</p>
<h2 id="for循环">for循环</h2>
<p>通过上面的两个例子大家也应该有点感觉了，在循环之前，一般是要定义一个<strong>计数变量</strong>，以此作为循环<strong>结束</strong>的参考。那么既然这样，有没有一种东西可以一次完成呢？这就是for语句。for循环就把计数变量和条件整合到一起去了，看通式：</p>
<pre><code class="language-c">for (循环初始化;循环条件;循环调整)
    循环体;
</code></pre>
<p>具体是啥意思，我们还是看例子。我们把上面的求和代码改成使用for：</p>
<pre><code class="language-c">//Example 09 V4
#include &lt;stdio.h&gt;
int main(void)
{
	int i, sum = 0;
	for (i = 1; i &lt; 101; i++)
	{
		sum += i;
	}
	printf(&quot;结果是%d&quot;, sum);
	return 0;
}
</code></pre>
<p>其实也是非常直观的。for语句其实三个成分可以<strong>不用都写</strong>甚至可以<strong>不写</strong>，但是分号一定要<strong>保留</strong>。如果没有明确的目的，那么最好不要这样用，因为会使代码可读性下降。</p>
<h2 id="break语句">break语句</h2>
<p>这个语句用于跳出循环。如果我们遍历<code>i</code>来寻找一个值，但凡找到，那其实就不用往下继续找了，那么就可以在循环中设置一个条件语句，如果找到结果则使用<code>break</code>跳出循环，这样可以节约算力。</p>
<p>但是，<code>break</code>只能跳出<strong>当前所在</strong>的循环，使用的时候一定注意。</p>
<h2 id="continue语句">continue语句</h2>
<p>跳过本轮循环然后进入下一轮循环。这个直接说可能没什么概念，我们看看下面的例子：</p>
<pre><code class="language-c">//Example 10
#include &lt;stdio.h&gt;
int main(void)
{
    int ch;
    while ((ch = getchar()) != '\n')
    {
        if (ch == 'e')
        {
            countinue;
        }
        putchar(ch);
    }
    putchar('\n');
    return 0;
}
</code></pre>
<p>这段代码是让用户输入一些字符，然后剔除其中的e然后再输出。</p>
<pre><code>//Consequence 10
TechZone
TchZon
</code></pre>
<p>应该很好理解吧，只要遇到了e就跳出本次循环，于是<code>putchar()</code>就被跳过去了。</p>
<p>可能有很多同学都觉得<code>for</code>和<code>while</code>其实差不多，但是，在<code>continue</code>语句里面很有可能就不一样。比如：</p>
<pre><code class="language-c">//Example 11
#include &lt;stdio.h&gt;
int main(void)
{
    int i;
    for (i = 1; i &lt; 10; i++)
    {
        if (i == 5)
        {
            continue;
        }
        printf(&quot;i = %d\n&quot;, i);
    }
    return 0;
}
</code></pre>
<p>如果让你把这个改成<code>while</code>，可能有的小伙伴会这么改：</p>
<pre><code class="language-c">//Example 11 V2
#include &lt;stdio.h&gt;
int main(void)
{
    int i = 1;
    while (i &lt; 10)
    {
        if ( i == 5)
        {
            continue;
            i++;
        }
        printf(&quot;i = %d\n&quot;, i);
        i++;
    }
}
</code></pre>
<p>这么看起来好像没有问题，但是执行到<code>continue</code>的时候，程序就陷入了<strong>死循环</strong>，无法执行到<code>i++</code>。因此不要随意更改已有的循环，如果真的有需要去改，也一定要思考清楚逻辑，想当然多半是会犯错误的。</p>
<h2 id="逗号运算符">逗号运算符</h2>
<p>当某个部分需要多个表达式的时候，使用逗号运算符来拼接。逗号运算符的优先级是<strong>最低</strong>的，但是它可以<strong>使整体</strong>从左到右进行。比如：</p>
<pre><code class="language-c">//Example 12
#include &lt;stdio.h&gt;
int main(void)
{
    int a,b,c;
    a = (b = 3, (c = b + 4) + 5);
    printf(&quot;a = %d, b = %d, c = %d\n&quot;, a, b, c);
    return 0;
}
</code></pre>
<p>在第6行里面。虽然<code>c = b + 4</code>被优先级最高的小括号括了起来，但是由于逗号运算符，还是优先从<code>b = 3</code>开始执行。</p>
<h2 id="条件运算符">条件运算符</h2>
<p>在C语言中，还有一种分支表达式就是条件运算符，它的通式为<code>exp1?exp2:exp3;</code>，其中exp1是<strong>条件表达式</strong>，当这个表达式判断为<strong>真</strong>时，执行exp2，反之执行exp3。比如下面的分支：</p>
<pre><code class="language-c">//Example 13
#include &lt;stdio.h&gt;
int main(void)
{
    int a = 3,b = 2;
    if (a &gt; b)
    {
        printf(&quot;Max is a\n&quot;);
    }
    else
    {
        printf(&quot;Max is b\n&quot;);
    }
    return 0;
}
</code></pre>
<p>这个就可以改成：</p>
<pre><code class="language-c">//Example 13 V2
#include &lt;stdio.h&gt;
int main(void)
{
    int a = 3,b = 2;
    a &gt; b ? printf(&quot;Max is a\n&quot;):printf(&quot;Max is b\n&quot;);
    return 0;
}
</code></pre>
<p>在条件不复杂的情况下使用这种语句其实更加方便，具体还是看个人的习惯来使用。</p>
<h2 id="goto语句">goto语句</h2>
<p>goto语句其实是个历史遗留问题。早期的编程语言都有<strong>汇编语言</strong>留下来的痕迹，goto就是其中之一。goto的作用就是让程序直接跳转到指定的位置。比如：</p>
<pre><code class="language-c">//Example 14
#include &lt;stdio.h&gt;
int main(void)
{
    int i = 5;
    while (i++)
    {
        if (i &gt; 10)
        {
            goto Lable;
        }
    }
Lable: printf(&quot;Here, i = %d\n&quot;, i);
    return 0;
}
</code></pre>
<p>当<code>i&gt;10</code>的时候直接跳转到<code>Lable</code>处了。</p>
<p>很多初学者刚刚接触<code>goto</code>的时候可能会觉得很实用，但是提醒大家，在实际开发的过程中，<strong>最好不用</strong><code>goto</code>语句。因为在代码之间跳来跳去，会破坏程序原有的逻辑。早期的程序代码就是满篇的<code>goto</code>，没有强大的大脑，很难一次性看懂代码在讲什么。所以早期的程序员还真不是一般人能揽下的活儿。</p>
<p>但是，有一种情况可以使用，就是要<strong>一次性跳出多层循环</strong>的时候，使用<code>goto</code>会更加直观，比多个<code>break</code>好用。</p>
<h2 id="嵌套循环">嵌套循环</h2>
<p>刚刚讲过，在实际的开发中，多层嵌套循环是会经常出现的。那么，在这里我们举个简单的例子来说明下，输出九九乘法表：</p>
<pre><code class="language-c">//Example 15
#include &lt;stdio.h&gt;
int main(void)
{
    int i,j;
    for (i=1; i&lt;=9; i++)
    {
        for (j=1; j&lt;=i; j++)
        {
            printf(&quot;%d×%d=%-2d\t&quot;, i, j, i*j);
        }
        putchar('\n');
    }
    return 0;
}
</code></pre>
<p>输出结果：</p>
<pre><code>//Consequence 15
1×1=1
2×1=2   2×2=4
3×1=3   3×2=6   3×3=9
4×1=4   4×2=8   4×3=12  4×4=16
5×1=5   5×2=10  5×3=15  5×4=20  5×5=25
6×1=6   6×2=12  6×3=18  6×4=24  6×5=30  6×6=36
7×1=7   7×2=14  7×3=21  7×4=28  7×5=35  7×6=42  7×7=49
8×1=8   8×2=16  8×3=24  8×4=32  8×5=40  8×6=48  8×7=56  8×8=64
9×1=9   9×2=18  9×3=27  9×4=36  9×5=45  9×6=54  9×7=63  9×8=72  9×9=81
</code></pre>
<hr>
<p>以上就是分支与循环的基础知识了，如果觉得学会了，那就赶紧开始实践。只有通过不断的debug，才能提升自己！这期博客就到此结束啦，是目前为止最长的一篇博客了，下期见！</p>
]]></content>
    </entry>
</feed>