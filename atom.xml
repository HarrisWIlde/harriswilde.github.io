<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://harriswilde.github.io</id>
    <title>TechZone</title>
    <updated>2020-02-11T03:36:25.672Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://harriswilde.github.io"/>
    <link rel="self" href="https://harriswilde.github.io/atom.xml"/>
    <subtitle>HarrisWilde祝诸君元旦快乐🎉</subtitle>
    <logo>https://harriswilde.github.io/images/avatar.png</logo>
    <icon>https://harriswilde.github.io/favicon.ico</icon>
    <rights>All rights reserved 2020, TechZone</rights>
    <entry>
        <title type="html"><![CDATA[C语言之函数（下）]]></title>
        <id>https://harriswilde.github.io/post/PS9G6tbW5</id>
        <link href="https://harriswilde.github.io/post/PS9G6tbW5">
        </link>
        <updated>2020-02-09T12:46:54.000Z</updated>
        <content type="html"><![CDATA[<h1 id="动态内存管理">动态内存管理</h1>
<p>我们知道，我们之前定义的变量、数组，都是我们事先定义好的，变量一旦被创建，就不能够再更改了。后来，C99标准又增加了变长数组，这一特性提高了我们程序对内存分配的灵活度，可是还是感觉不太灵活。那么有没有办法让它变得更灵活呢？</p>
<p>当然有，而且只需要几个库的函数就能够搞定。而这些库全部都包含在<code>stdlib.h</code>这个头文件中：</p>
<ul>
<li>malloc ——申请动态内存空间</li>
<li>free ——释放动态内存空间</li>
<li>calloc ——申请并初始化一系列内存空间</li>
<li>realloc ——重新分配内存空间</li>
</ul>
<h2 id="malloc">malloc</h2>
<p><code>malloc</code>函数用于申请动态内存空间：</p>
<pre><code class="language-c">#include &lt;stdlib.h&gt;
void* malloc(size_t size);
</code></pre>
<p><code>malloc</code>函数向系统申请分配<code>size</code>个字节的内存空间，并返回一个指向这块空间的指针。不过，申请的这块空间并没有被初始化，因此上面的数据是随机的（和局部变量一样）。</p>
<p>如果函数调用成功，那么会返回一个指向被申请的内存空间的指针，由于返回的是void类型的指针，所以它可以被转化成任何类型的数据。如果函数调用失败，返回值就是<code>NULL</code>。另外，如果<code>size</code>参数设置成0，那么返回值也有可能是0，但这种情况下并不一定代表调用失败。</p>
<pre><code class="language-c">//Exmple 01
#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;

int main(void)
{
    int* ptr;
    ptr = (int*)malloc(sizeof(int));
    if (ptr == NULL)
    {
        printf(&quot;分配内存失败！\n&quot;);
        exit(1);//程序异常退出
    }
    printf(&quot;请输入一个整数：&quot;);
    scanf(&quot;%d&quot;, ptr);
    printf(&quot;你输入的数据是：%d\n&quot;, *ptr);
    return 0;
}
</code></pre>
<p>运行结果为：</p>
<pre><code>请输入一个整数：12
你输入的数据是：12
</code></pre>
<p>这段代码的意思是，使用<code>malloc</code>函数申请一块int类型的空间，然后使用<code>ptr</code>指针来指向它，然后将用户输入的数据存储在这块空间里面。</p>
<p>不过，<code>malloc</code>函数申请的空间是在堆上，那么这就意味这它不会自动释放，直到程序执行结束。所以在使用完变量之后务必释放内存，否则很有可能造成内存泄漏。</p>
<h2 id="free">free</h2>
<p>释放动态内存空间需要用<code>free</code>函数，函数原型：</p>
<pre><code class="language-c">#include &lt;stdlib.h&gt;
...
void free(void* ptr);
</code></pre>
<p>释放的空间必须要是<code>malloc</code> <code>calloc</code> <code>realloc</code>函数申请的，否则将会导致未定义行为。如果<code>ptr</code>的参数是<code>NULL</code>，那么就不执行任何操作。</p>
<p>这个函数实际上并不会修改<code>ptr</code>参数的值，所以调用后它仍然能够指向原来的地方，只不过变为非法空间罢了。</p>
<p>有人会说了，现代计算机内存都不小，动辄16GB甚至更多，那么这个是否就用不上了呢？</p>
<p>答案当然是否定的。不信你试试下面的这个程序：</p>
<pre><code class="language-c">//Infinity malloc
#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;

int main(void)
{
    while (1)
    {
        malloc(1024);
    }
    return 0;
}
</code></pre>
<p>你会发现内存占用会飙升。这种情况就叫做<strong>内存泄漏</strong>。我们申请的空间，在使用完后应该要立即释放，不然很有可能会造成不堪设想的后果。</p>
<pre><code class="language-c">//Exmple 01 - Edited
#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;

int main(void)
{
    int* ptr;
    ptr = (int*)malloc(sizeof(int));
    if (ptr == NULL)
    {
        printf(&quot;分配内存失败！\n&quot;);
        exit(1);//程序异常退出
    }
    printf(&quot;请输入一个整数：&quot;);
    scanf(&quot;%d&quot;, ptr);
    printf(&quot;你输入的数据是：%d\n&quot;, *ptr);
    ////释放内存////
    free(ptr);
    return 0;
}
</code></pre>
<p>因此，在使用完申请的内存之后应该要手动释放。</p>
<p>我们再来看一个例子：</p>
<pre><code class="language-c">//Example 02
#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;

int main(void)
{
    int* ptr;
    int num = 123;
    ptr = (int*)malloc(sizeof(int));
    if (ptr == NULL)
    {
        printf(&quot;分配内存失败！\n&quot;);
        exit(1);
    }
    printf(&quot;请输入一个整数：&quot;);
    scanf(&quot;%d&quot;, ptr);
    printf(&quot;你输入的整数是：%d\n&quot;, *ptr);
    ptr = &amp;num;
    printf(&quot;你输入的整数是：%d\n&quot;, *ptr);
    free(ptr);
    return 0;
}
</code></pre>
<p>结果如下：</p>
<pre><code>请输入一个整数：10
你输入的整数是：10
你输入的整数是：123
HEAP[ConsoleApplication2.exe]: Invalid address specified to RtlValidateHeap( 00D20000, 0096F8E0 )
ConsoleApplication2.exe 已触发了一个断点。
</code></pre>
<p>程序被中断了。</p>
<p>刚开始，我们使用<code>malloc</code>函数申请了一段内存，并且只有<code>ptr</code>才知道这块内存的地址。所以后面我们更改了<code>ptr</code>后，这块内存就泄露了。后面我们尝试释放<code>ptr</code>，却发现，现在<code>ptr</code>所指向的变量是一个局部变量，不允许手动释放。这种情况的泄露一定要特别注意。</p>
<h2 id="申请任意尺寸的内存空间">申请任意尺寸的内存空间</h2>
<p><code>malloc</code>还可以用于申请一块任意尺寸的内存空间。对于后者，由于申请的空间是连续的，所以经常用数组的方式来进行索引。</p>
<p>还记得在<a href="http://www.techzone.ltd/post/CArray/">《C语言之数组》</a>里我们讲过，Visual Studio和C99之前的编译器是不支持可变长数组的。如果恰好碰到这种环境，怎么办呢？刚好可以用这种方式来曲线救国：</p>
<pre><code class="language-c">//Example 03
#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
 int main(void)
 {
     int* array;
     int n;
     printf(&quot;请输入你要创建的数组元素个数：&quot;);
     scanf(&quot;%d&quot;, &amp;n);
     array = (int*)malloc(sizeof(int) * n);
     for (int i = 0; i &lt; n; i++)
     {
         array[i] = i;
         printf(&quot;%d\n&quot;, array[i]);
     }
     return 0;
 }
</code></pre>
<p>运行结果如下：</p>
<pre><code>//Consequence 03
请输入你要创建的数组元素个数：10
0
1
2
3
4
5
6
7
8
9
</code></pre>
<p>多维数组也一样可以（本质上也是线性存储）：</p>
<pre><code class="language-c">//Example 04
#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;

int main(void)
{
    int** array;
    int n, m;
    scanf(&quot;%d %d&quot;, &amp;n, &amp;m);//n为几个大的数组，m是一个小数组中有几个元素
    array = (int**)malloc(sizeof(int*) * n);//分配行数
    for (int i = 0; i &lt; n; i++)
    {
        array[i] = (int*)malloc(sizeof(int) * m);//分配各个元素
    }
    for (int i = 0; i &lt; n; i++)
    {
        for (int j = 0; j &lt; m; j++)
        {
            array[i][j] = j;
            printf(&quot;%d &quot;, array[i][j]);
        }
        printf(&quot;\n&quot;);
    }
    return 0;
}
</code></pre>
<p>运行结果为：</p>
<pre><code>//Consequence 04
3 4
0 1 2 3
0 1 2 3
0 1 2 3
</code></pre>
<p>由于<code>malloc</code>不会初始化申请的内存空间，所以需要字节进行初始化。当然可以写一个循环，像我们刚刚那样，不过还是略显繁琐。</p>
<p>好在，标准库提供了更加高效的函数，包含在<code>string.h</code>头文件中：</p>
<ul>
<li>memset: 使用一个常量字节填充内存空间</li>
<li>memcpy: 复制内存空间</li>
<li>memmove: 移动内存空间</li>
<li>memcmp: 比较内存空间</li>
<li>memchr: 在内存空间中搜索一个字符</li>
</ul>
<p>函数原型如下：</p>
<pre><code class="language-c">#include &lt;string.h&gt;
void* memset(void* s, int c, size_t n);
void* memcpy(void* dest, const void* src, size_t n);
void* memmove(void* dest, const void* src, size_t n);
int memcmp(const void* s1, const void* s2, size_t n);
void* memchr(const void* s, int c, size_t n);
</code></pre>
<p>使用<code>memset</code>函数初始化空间：</p>
<pre><code class="language-c">//Example 05
#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;string.h&gt;

#define N 10

int main(void)
{
    int* ptr = NULL;
    ptr = (int*)malloc(N * sizeof(int));
    if (ptr == NULL)
    {
        exit(1);
    }
    memset(ptr, 0, N * sizeof(int));
    for (int i = 0; i &lt; N; i++)
    {
        printf(&quot;%d &quot;, ptr[i]);
    }
    putchar('\n');
    free(ptr);
    return 0;
}
</code></pre>
<p>运行结果为：</p>
<pre><code>//Consequence 05
0 0 0 0 0 0 0 0 0 0
</code></pre>
<p>如果觉得这样太麻烦，那么我们就可以使用<code>calloc</code>来一步到位。</p>
<h2 id="calloc">calloc</h2>
<p><code>calloc</code>函数用于申请并初始化一系列内存空间：</p>
<pre><code class="language-c">#include &lt;stdlib.h&gt;
...
void* calloc(size_t nmemb, size_t size);
</code></pre>
<p><code>calloc</code>函数在内存中动态地申请nmemb个长度为size的连续内存空间（即申请的总空间尺寸为<code>nmemb*size</code>），这些内存空间全部被初始化成0。</p>
<p>如果函数调用成功，会返回一个指向申请的内存空间的指针，由于返回类型是void指针，因此可以被转换成任何类型的数据。如果函数调用失败，返回值是<code>NULL</code>。如果<code>nmemb</code>或<code>size</code>参数设置为0，返回值也可能是<code>NULL</code>，但这不一定意味着函数调用失败。</p>
<h2 id="realloc">realloc</h2>
<p>有时候可能需要对原来分配的空间进行拓展，但是没办法确保两次申请的空间是线性连续的。所以需要先申请一个足够大的空间，再把数据搬运过去。</p>
<p>当然，这样确实可以，但是手动写代码的话感觉有些太繁琐了。使用<code>realloc</code>函数就可以帮我们完成这一系列的操作：</p>
<pre><code class="language-c">#include &lt;stdlib.h&gt;
...
void* realloc(void* ptr, size_t size);
</code></pre>
<p>以下几点是需要注意的：</p>
<ul>
<li><code>realloc</code>函数将<code>ptr</code>指向的内存空间大小修改为<code>size</code>字节</li>
<li>如果重新分配的内存比原来的大，则旧数据不会发生改变；若比原来小，数据有可能会丢失，慎用！</li>
<li>该函数会移动内存空间并返回新的指针</li>
<li>如果<code>ptr</code>的参数是<code>NULL</code>，那么调用该函数就相当于调用<code>malloc(size)</code></li>
<li>如果<code>size</code>的参数为0，并且<code>ptr</code>的参数不为<code>NULL</code>，那么调用该函数就相当于调用<code>free(ptr)</code></li>
<li>除非<code>ptr</code>的参数为<code>NULL</code>，否则<code>ptr</code>的值必须由先前调用的<code>malloc</code> <code>calloc</code> <code>realloc</code>函数返回</li>
</ul>
<p>下面这个程序，不断接受用户输入整数，直到用户输入-1结束，然后将所有的数据输出：</p>
<pre><code class="language-c">//Example 06
#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;

int main(void)
{
    int num;
    int count = 0;
    int* ptr = NULL;//这里必须初始化为NULL
    do
    {
        printf(&quot;请输入一个整数（输入-1表示结束：）&quot;);
        scanf(&quot;%d&quot;, &amp;num);
        count++;
        ptr = (int*)realloc(ptr, count * sizeof(int));
        if (ptr == NULL)
        {
            exit(1);
        }
        ptr[count - 1] = num;
    } while (num != -1);
    printf(&quot;输入的整数分别是：&quot;);
    for (int i = 0; i &lt; count - 1; i++)
    {
        printf(&quot;%d &quot;, ptr[i]);
    }
    printf(&quot;\n&quot;);
    free(ptr);
    return 0;
}
</code></pre>
<p>运行结果为：</p>
<pre><code>//Consequence 06
请输入一个整数（输入-1表示结束：）5
请输入一个整数（输入-1表示结束：）23
请输入一个整数（输入-1表示结束：）4
请输入一个整数（输入-1表示结束：）51
请输入一个整数（输入-1表示结束：）22
请输入一个整数（输入-1表示结束：）31
请输入一个整数（输入-1表示结束：）1
请输入一个整数（输入-1表示结束：）9
请输入一个整数（输入-1表示结束：）-1
输入的整数分别是：5 23 4 51 22 31 1 9
</code></pre>
<h1 id="c语言的内存布局">C语言的内存布局</h1>
<img src="https://s2.ax1x.com/2020/02/09/1hG8D1.png" alt="C语言的内存布局" style="zoom:33%;" />
<p>根据内存由低到高分别做如下划分：</p>
<ul>
<li>代码段(text segment)</li>
<li>数据段(initialized data segment)</li>
<li>BSS段(BSS segment / Uninitialized data segment)</li>
<li>栈(stack)</li>
<li>堆(heap)</li>
</ul>
<h2 id="代码段">代码段</h2>
<p>代码段通常用来存放程序执行代码的一块内存区域。这部分区域的大小再程序运行前就已经确定，并且内存区域通常值属于只读。在代码段中，也有可能包含一些只读的常数变量，如字符串常量等等。</p>
<h2 id="数据段">数据段</h2>
<p>数据段通常用来存放已经初始化的全局变量和局部静态变量。</p>
<h2 id="bss段">BSS段</h2>
<p>BSS段通常用来存放程序中为初始化的全局变量的一块内存区域。BSS是英文Black Started by Symbol的简称。这个区段中的数据在程序运行前将被自动初始化为0。</p>
<h2 id="堆">堆</h2>
<p>前面学习的动态内存管理，实际上就是在这里面进行的。堆里面主要放一些动态的内存段，能够扩展和缩小。</p>
<h2 id="栈">栈</h2>
<p>大家平时所听到的<strong>堆栈</strong>这个词，实际上就是指的栈。栈是函数执行的内存区域，通常和堆共享同一片区域。堆和栈是C语言运行时的重要元素之一。而它们之间也有很大的不同；<strong>堆</strong>由程序员手动申请，而<strong>栈</strong>由系统自动分配；<strong>堆</strong>由程序员手动释放，而<strong>栈</strong>由系统自动释放；<strong>堆</strong>的生存周期由程序员来决定，并且不同函数之间<strong>可以</strong>自由访问，而<strong>栈</strong>的生存周期由函数调用开始到函数返回时结束，函数之间的局部变量<strong>不可以</strong>互相访问。</p>
<h1 id="高级宏定义">高级宏定义</h1>
<p>作为C语言的三大预处理命令之一，宏定义的作用时替换。但是，宏定义就算再复杂，也只是替换不做任何的计算或者表达式求解。</p>
<h2 id="不带参数的宏定义">不带参数的宏定义</h2>
<p>这种就是我们常见的直接替换：</p>
<pre><code class="language-c">#define PI 3.14
</code></pre>
<blockquote>
<p>注意：</p>
<ul>
<li>为了和普通变量区分，宏的名字一般约定为全大写</li>
<li>宏定义只是简单的替换，且是在编译前就处理好了，所以编译器不会对宏定义的语法进行检查</li>
<li>宏定义的作用范围是从定义开始到程序的结束</li>
<li>可以使用#undef命令中止宏定义的作用域</li>
<li>宏定义允许嵌套(在宏定义中使用已定义的宏)</li>
</ul>
</blockquote>
<h2 id="带参数的宏定义">带参数的宏定义</h2>
<p>C语言的宏定义可以带参数。和函数类似，在宏定义里出现的叫做<strong>形参</strong>，而在调用的时候实际传递的叫做 <strong>实参</strong>。</p>
<p>如：</p>
<pre><code class="language-c">#define MAX(x, y) (((x) &gt; (y)) ? (x) : (y))
</code></pre>
<p>这个就是用来比较x和y哪个更大：</p>
<pre><code class="language-c">//Example 07
#include &lt;stdio.h&gt;
#define MAX(x, y) (((x) &gt; (y)) ? (x) : (y))

int main(void)
{
    int x, y;
    printf(&quot;请输入两个整数：&quot;)；
    scanf(&quot;%d %d&quot;, &amp;x, &amp;y);
    printf(&quot;%d更大！&quot;, MAX(x, y));
    return 0;
}
</code></pre>
<p>运行结果如下：</p>
<pre><code>//Consequence 08
请输入两个整数：3 5
5更大！
</code></pre>
<p>另外，参数的最外层建议加上一个小括号来确保优先级，不然很可能会出现隐式的bug。</p>
<h1 id="内联函数">内联函数</h1>
<p>由于预编译命令在编译之前就已经处理好了。而函数每次的调用却还要申请栈空间。的确，使用含参宏定义效率确实要更高。</p>
<p>不过，有的时候却会出现一些bug，比如：</p>
<pre><code class="language-c">//Example 09
#define SQUARE(x) ((x) * (x))
#include &lt;stdio.h&gt;

int main(void)
{
    int i = 1;
    while (i &lt;= 10)
    {
        printf(&quot;%d的平方根是%d\n&quot;, i-1, SQUARE(i++));
    }
    return 0;
}
</code></pre>
<p>结果为：</p>
<pre><code>//Consequence 09
2的平方根是1
4的平方根是9
6的平方根是25
8的平方根是49
10的平方根是81
</code></pre>
<p>这是怎么回事呢？</p>
<p>我们刚刚说过，宏定义只是简单的替换。那么<code>SQUARE(i++)</code>最终会被替换为<code>((i++) * (i++))</code>，那么没调用一次宏，就要自增两次。</p>
<p>那么我又想用宏定义，却又向避开这个bug，怎么办呢？</p>
<p>就是调用内联函数：</p>
<pre><code class="language-c">inline int square(int);
</code></pre>
<p>和普通的函数定义一样，只不过在前面加上<code>inline</code>即可。指定一个函数为内联函数，那么系统就会像处理宏定义那样，将整个函数直接在<code>main</code>函数中展开。</p>
<p>不过，内联函数也不是万能的。虽然节省了运行的时间，但是每个地方都要进行替换，实际上也增加了编译的时间。再者，其实现在的编译器也很聪明，对内联函数也有一套像寄存器变量那样的优化机制，并不是所有你声明的内联函数都能够成为内联函数，而有些普通函数也有可能会成为内联函数。</p>
<h1 id="一些小技巧">一些小技巧</h1>
<h2 id="和">#和##</h2>
<p>在含参宏定义中，#运算符后面应该跟一个参数，预处理器会把这个参数转换成一个字符串：</p>
<pre><code class="language-c">//Example 10
#define STR(s) # s
#include &lt;stdio.h&gt;

int main(void)
{
    printf(&quot;%s\n&quot;, STR(TechZone));
    return 0;
}
</code></pre>
<p>结果为：</p>
<pre><code>//Consequence 10
TechZone
</code></pre>
<p>虽然笔者传入的不是字符串形式，但是<code>#</code>将其变为了字符串，因此可以直接以<code>%s</code>的形式输出。</p>
<p>并且传入字符中，所有的保留字符都会做转义处理，比如<code>\</code>会被替换为<code>\\</code>。存在多个空白字符的时候，会被替换为一个空格。</p>
<p>而##运算符被成为连接运算符，如：</p>
<pre><code class="language-c">//Example 11
#define TOGETHER(x, y) x ## y
#include &lt;stdio.h&gt;
int main(void)
{
    printf(&quot;%d\n&quot;, TOGETHER(5, 20));
    return 0;
}
</code></pre>
<p>结果为：</p>
<pre><code>//Consequence 11
520
</code></pre>
<h2 id="可变参数">可变参数</h2>
<p>之前学习了如何让函数支持可变参数，带参数的宏定义也支持使用可变参数：</p>
<pre><code class="language-c">#define SHOWLIST(...) printf(#__VA_AGES__)
</code></pre>
<p>如：</p>
<pre><code class="language-c">//Example 12
#define SHOWLIST(...) printf(#__VA_AGES__)
#include &lt;stdio.h&gt;

int main(void)
{
    SHOWLIST(TechZone, HarrisWilde, C);
    return 0;
}
</code></pre>
<p>由于在VS2019下无法支持编译，这次的结果使用Linux下的GCC来执行：</p>
<pre><code>//Consequence 12 in GCC
TechZone, HarrisWilde, C
</code></pre>
<p>可变参数是允许存在空参数的，如果是空参数，则##前面的逗号也会一起被去掉，避免导致参数数量不一致：</p>
<pre><code class="language-c">//Example 13
#define PRINT(format, ...) printf(#format, ##__VA_AGES__)

int main(void)
{
    PRINT(num = %d\n, 10);
    PRINT(Hello, world!\n);
    return 0;
}
</code></pre>
<p>结果为：</p>
<pre><code>//Consequence 13 in GCC
num = 10
Hello, world!
</code></pre>
<p>函数的基础知识到这里就结束了，希望对大家有所帮助！</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[C语言之函数（中）]]></title>
        <id>https://harriswilde.github.io/post/IKKYqSXMf</id>
        <link href="https://harriswilde.github.io/post/IKKYqSXMf">
        </link>
        <updated>2020-02-06T13:47:02.000Z</updated>
        <content type="html"><![CDATA[<h1 id="局部变量和全局变量">局部变量和全局变量</h1>
<h2 id="局部变量">局部变量</h2>
<p>在我们学习函数之前，我们所理解的变量，只不过是在内存中开辟一个存储数据的位置，并取了个我们好懂的名字而已。因为我们之前写的程序只有一个主函数，因此我们觉得，定义了一个变量，就应该可以随时调用。但是学习了函数之后，我们发现，不同函数之间的变量是不能够相互调用的，这又是为什么呢？</p>
<p>比如：</p>
<pre><code class="language-c">//Example 01
#include &lt;stdio.h&gt;
int main(void)
{
    int i = 100;
    printf(&quot;Before i = %d\n&quot;, i);
    for (int i = 0; i &lt;= 10; i++)//再定义一个局部变量i
    {
        printf(&quot;i = %d\n&quot;, i);
    }
    printf(&quot;After i = %d\n&quot;, i);
    return 0;
}
</code></pre>
<p>结果如下：</p>
<pre><code>//Consequence 01
Before i = 100
i = 0
i = 1
i = 2
i = 3
i = 4
i = 5
i = 6
i = 7
i = 8
i = 9
i = 10
After i = 100
</code></pre>
<p>我们可以看到，我们在<code>for</code>函数里和<code>main</code>函数里都有一个<code>i</code>变量，但是我们在<code>for</code>函数里面定义的<code>i</code>却对外层函数不构成影响。</p>
<p>一般来说，变量名应该是不能够重复的。但是，由于我们定义的位置不一样（在不同的函数中），所以变量名重复又变得合法起来。这就是局部变量的特性：<strong>只能在自己的领域里面发挥作用</strong>。</p>
<p>像我们刚刚定义的<code>for</code>一样，C语言允许随处定义变量。也就是说，变量在需要用到的时候再定义。这样也符合我们的思维方式。因为当程序很庞大的时候，没有人愿意翻到顶上去看一个变量的注释。</p>
<h2 id="全局变量">全局变量</h2>
<p>既然有局部变量，那么全局变量也照样不可少。看下面的例子：</p>
<pre><code class="language-c">//Example 02
#include &lt;stdio.h&gt;
void f1(void);
void f2(void);
void f3(void);
int a = 0;//定义一个全局变量

void f1(void)
{
    a++;
}

void f2(void)
{
    a++;
}

void f3(void)
{
    a++;
}

int main(void)
{
    f1();
    f2();
    f3();
    printf(&quot;a = %d\n&quot;, ++a);
    return 0;
}
</code></pre>
<p>运行结果如下：</p>
<pre><code>//Consequence 02
a = 4
</code></pre>
<p>我们发现，全局变量在每一个函数里面的更改都“有效”，也就是说，全局变量是贯穿整个程序始终的。</p>
<p>有的小伙伴可能会好奇，如果全局变量和局部变量重名了，会发生什么呢？</p>
<p>那我们就来试试：</p>
<pre><code class="language-c">//Example 03
#include &lt;stdio.h&gt;
void f(void);
int a, b = 100;
void f(void)
{
    int b;
    a = 50; b = 101;
    printf(&quot;func, a = %d, b = %d\n&quot;, a, b);
}

int main(void)
{
    printf(&quot;Main, a = %d, b = %d\n&quot;, a, b);
    f();
    printf(&quot;Main, a = %d, b = %d\n&quot;, a, b);
}
</code></pre>
<p>运行结果如下：</p>
<pre><code>//Consequence 03
Main, a = 0, b = 100
func, a = 50, b = 101
Main, a = 50, b = 100
</code></pre>
<p>我们发现，名字叫<code>a</code>的变量只有全局变量，那么被赋值之后就等于在函数<code>f()</code>中赋的值。但是<code>b</code>就不一样了。在函数<code>f()</code>中，也有一个变量叫做<code>b</code>，那么此时编译器的做法是，在函数<code>f()</code>里先暂时屏蔽全局变量<code>b</code>，使用自己的局部变量。等走出了函数<code>f()</code>，局部变量被释放。</p>
<p>而我们还发现一个问题，我们可以直接输出没有被初始化的<code>a</code>！这也是全局变量的一个特点，不同于局部变量，全局变量在没有手动初始化的时候，会被系统自动初始化为<code>0</code>而不是像局部变量那样的很小的一个很奇怪的数。</p>
<p>另外，如果没有需要，尽量不要大量使用全局变量。因为全局变量的内存将会伴随着这个程序，直到程序执行完毕。如果大量使用全局变量的话，可能会造成内存占用过多等问题。这在嵌入式开发这种领域，内存空间寸土寸金，不当使用全局变量会导致资源的浪费。其次，全局变量会造成程序可读性变差。最后，全局变量会使得程序牵连性变强，牵一发而动全身的情况可能会再次出现。</p>
<p>因此全局变量虽然是个好东西，但也要谨慎使用。</p>
<h1 id="作用域和链接属性">作用域和链接属性</h1>
<p>在上一节，我们简单地了解了不同的变量，它能够有不同的作用范围，那么这个范围，就是我们所说的<strong>作用域</strong>。C语言的编译器一共能够确认4种不同的作用域：<code>代码块作用域</code> <code>文件作用域</code> <code>原型作用域</code> <code>函数作用域</code></p>
<h2 id="代码块作用域">代码块作用域</h2>
<pre><code class="language-c">//Example 04
#include &lt;stdio.h&gt;
int main(void)
{
    int i = 1;
    {
        int i = 2;
        printf(&quot;i = %d\n&quot;, i);
    }
    {
        printf(&quot;i = %d\n&quot;, i);
        int i = 3;
        printf(&quot;i = %d\n&quot;, i);
    }
    printf(&quot;i = %d\n&quot;, i);
    return 0;
}
</code></pre>
<p>运行结果如下：</p>
<pre><code>//Consequence 04
i = 2
i = 1
i = 3
i = 1
</code></pre>
<p>我们通常管一个大括号里面的语句叫做代码块，那么看这个程序，一个代码块里面的变量只能作用于所在的代码块里，超出了的就无效了。若存在代码块嵌套，那么优先内层代码块的变量。这就是<strong>代码块作用域</strong>。</p>
<p>当然，有一点需要说说，就是函数的形参也是代码块作用域，只能作用于函数定义代码块里面，即便它没有写在代码块里面。</p>
<h2 id="文件作用域">文件作用域</h2>
<p>在任何代码块之外定义的变量，都具有<strong>文件作用域</strong>。它们的作用域是从变量声明开始，一直到文件尾结束。另外，函数名也是文件作用域，因为函数名本身也在代码块之外。</p>
<h2 id="原型作用域">原型作用域</h2>
<p>原型作用域只适合那些在函数原型中声明的参数名。我们知道，在声明一个函数的时候，形参的名字是可以不用写的，只需要把类型写好就行了。但是，其实不妨可以试试写上名字，即便这个名字和正式定义的时候形参的名字不一样，也是没问题的（当然这样做毫无意义），这其实就是原型作用域在起作用。</p>
<h2 id="函数作用域">函数作用域</h2>
<p>函数作用域只适用于<code>goto</code>语句的标签，作用是将<code>goto</code>语句的标签限定在一个函数的内部，避免出现重名的标签。</p>
<h2 id="链接属性">链接属性</h2>
<p>简单来说，编译器将源代码转换成机器码的时候需要有两个步骤：<strong>编译</strong>和<strong>链接</strong>。</p>
<p>所谓编译，就是将我们写的源代码转换为机器码，而链接，就是将相关的库文件添加进来。比如我们在写程序的时候加入的头文件，在最终生成的时候就是要链接进来的。</p>
<p>我们知道，大型程序是由很多源文件构成的，那么在不同的文件中的同名标识符，编译器是入场处理的呢？</p>
<p>在C语言中，链接属性一共有以下3种：</p>
<ul>
<li>external(外部的)：多个文件中声明的同名标识符表示同一个实体</li>
<li>internal(内部的)：单个文件中声明的同名标识符表示同一个实体</li>
<li>none(无)：声明的同名标识符被当作独立不同的实体。比如，函数的局部变量。</li>
</ul>
<p>默认情况下，具备文件作用域的标识符拥有<code>external</code>属性，也就是说，这种标识符允许跨文件访问。使用<code>static</code>可以使原先拥有<code>external</code>属性的标识符变为<code>internal</code>属性。但是<code>static</code>只能修改具有文件作用域的标识符，并且是不可逆修改。</p>
<h1 id="生存期和存储类型">生存期和存储类型</h1>
<h2 id="生存期">生存期</h2>
<p>上一节我们用空间的角度去解释了不同的变量，但其实，还可以从时间的角度来分析。</p>
<p>C语言的变量通常有两种生存期，静态存储期(static storage duration)和自动存储期(automatic storage duration)。</p>
<p>具有文件作用域的变量具有静态存储期（如全局变量），函数名也有静态存储期。静态存储期的变量在程序执行的期间内将一直占据存储空间。</p>
<p>具有代码块作用域的变量通常具有自动存储期（如局部变量和形参），具有自动存储期的变量将在代码块执行完毕的时候释放内存。</p>
<h2 id="存储类型">存储类型</h2>
<p>变量的存储类型实际上是指存储变量值的内存类型。C语言提供了5种存储类型：<code>auto</code> <code>register</code> <code>static</code> <code>extern</code> <code>typedef</code></p>
<h3 id="1-自动变量">1. 自动变量</h3>
<p>在代码块中声明的变量默认就是自动变量(auto)。</p>
<pre><code class="language-c">//Example 05
#include &lt;stdio.h&gt;
int main(void)
{
    auto int a, b, c;
    return 0;
}
</code></pre>
<p>但是由于是默认存储类型，所以<code>auto</code>一般不写也完全没问题。函数中的形参、局部变量以及复合语句中定义的局部变量都具有自动变量。自动变量拥有代码块作用域、自动存储期和空链接属性。</p>
<h3 id="2-寄存器变量">2. 寄存器变量</h3>
<p>如果你学过汇编语言，或者对计算机的原理比较了解的话，一定没少听说<strong>寄存器</strong>这个词。寄存及就集成在CPU内部，因此它和CPU之间的交流几乎可以说没有延迟。</p>
<p>如果你申请了寄存器变量，那么就有可能被存储到寄存器里面去。当然，编译器也有自己的优化方案，它会在程序运行的时候权衡哪些变量更应该被放到寄存器的位置，因此，你的申请只是做一个参考而已。那么那些没有被放入寄存器的变量就会成为<strong>自动变量</strong>，所以，寄存器变量和自动变量在很多地方是一样的，也拥有代码块作用域、自动存储期和空链接属性。</p>
<p>但是，如果是寄存器变量的话，那么理论上就没法通过**取地址运算符&amp;**来获取地址了，因为我们知道这个是针对内存的。</p>
<pre><code class="language-c">//Example 06
#include &lt;stdio.h&gt;
int main(void)
{
    register int i = 100;
    printf(&quot;addr of i is %p\n&quot;, &amp;i);
    return 0;
}
</code></pre>
<p>但是VS可能对这种代码有优化，将变量转换成自动变量了：</p>
<pre><code>//Consequence 06 of Visual Studio 2019
addr of i is 00CFFE90
</code></pre>
<h3 id="3-静态局部变量">3. 静态局部变量</h3>
<p><code>static</code>用于描述具有文件作用域的变量或者函数时，表示将其链接属性从<code>external</code>修改成<code>internal</code>，它的作用范围就变成了仅当前文件可访问。如果<code>static</code>用于描述局部变量，那可就不太一样了。</p>
<p>默认情况下，局部变量是自动变量，具有自动存储期。如果使用了<code>static</code>来声明，那么就可以将局部变量指定为静态局部变量(static)。这使得局部变量具有静态存储期，所以它的生存期和全局变量一样。但是作用域依旧是局部变量，在别的函数中是无法访问这个局部变量的。</p>
<h3 id="4-extern">4.  extern</h3>
<p><code>extern</code>关键字告诉编译器这个变量或函数在别的地方已经定义过了，先在别的地方找找，不要急着报错。</p>
<p>通常情况下，这个关键词可以不写，但是为了程序更加完善，更加易读。在多人协作的时候，可以避免很多重名的问题。</p>
<h3 id="5-typedef">5.  typedef</h3>
<p><code>typedef</code>与其他四个存储类型的语义不同，<code>typedef</code>与内存存储无关，用于为数据类型定义一个新名字。</p>
<h1 id="递归">递归</h1>
<p>虽然递归隶属于算法的范畴，但是几乎所有的程序语言教程，都会讲到这个知识点。因为，递归是一个非常好的编程思路，有时候一个很难解决的问题，使用递归就可以巧妙地搞定。</p>
<h2 id="什么是递归">什么是递归</h2>
<p>递归说白了，就是函数在执行的时候，调用自身的行为。其实递归在生活中有很多实例，比如：</p>
<ol>
<li>
<p>汉诺塔游戏</p>
<figure data-type="image" tabindex="1"><img src="https://ss0.bdstatic.com/70cFuHSh_Q1YnxGkpoWK1HF6hhy/it/u=2591095191,1547695417&amp;fm=26&amp;gp=0.jpg" alt="汉诺塔游戏" loading="lazy"></figure>
<p>这个游戏要求将中间的柱子的圆盘全部移动到另外一个柱子上，要求每次只能移动一个圆盘，并且较大的圆盘始终在下方。</p>
</li>
<li>
<p>谢尔宾斯基三角形</p>
<figure data-type="image" tabindex="2"><img src="https://ss1.bdstatic.com/70cFvXSh_Q1YnxGkpoWK1HF6hhy/it/u=3361120212,184359007&amp;fm=26&amp;gp=0.jpg" alt="谢尔宾斯基三角形" loading="lazy"></figure>
<p>三角形里边填充三角形，只要空间够大，它可以撑满整个宇宙。</p>
</li>
</ol>
<p>甚至还诞生了一门数学分支：分形几何。专门研究这种递归现象。</p>
<p>说了这么多，那么递归在程序里面该如何实现呢？</p>
<pre><code class="language-c">//Example 07
#include &lt;stdio.h&gt;
void r(void);
void r(void)
{
    printf(&quot;Hi!&quot;);
    r();
}
int main(void)
{
    r();
    return 0;
}
</code></pre>
<p>运行结果如下：</p>
<pre><code>//Consequence 08
...
Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Segmentation fault
</code></pre>
<p>可以看到，满屏幕的Hi！这就是初学者经常会犯的错误，程序无休止地执行下去，直到消耗掉所有的内存。这就像我们讲过的“从前有座山，山里有座庙……”这个故事一样，没有中止的条件，讲多久都讲不完。</p>
<p>修改下代码：</p>
<pre><code class="language-c">//Example 07 V2
#include &lt;stdio.h&gt;
void r(void);
void r(void)
{
    static int count = 5;//设置计数变量
    printf(&quot;Hi!\n&quot;);
    if (--count)//设置跳出条件
    {
        r();
    }
}

int main(void)
{
    r();
    return 0;
}
</code></pre>
<p>运行结果如下：</p>
<pre><code>//Consequence 07 V2
Hi!
Hi!
Hi!
Hi!
Hi!
</code></pre>
<p>这样，递归这头小猛兽，就这样被我们控制住了。</p>
<h2 id="递归求斐波那契数列">递归求斐波那契数列</h2>
<p>斐波那契数列每一项等于前两项之和，正好符合递归的思路：</p>
<pre><code class="language-c">#include &lt;stdio.h&gt;
int fibo(int n)
{
    if (n &lt;= 2)
    {
        return 1;
    }
    else
    {
        return fibo(n - 1) + fibo(n - 2);
    }
}
int main()
{
    int n;
    printf(&quot;请输入斐波那契数列长度：&quot;);
    scanf(&quot;%d&quot;, &amp;n);
    for (int i = 1; i &lt;= n; ++i)
    {
        printf(&quot;%d&quot;, fibo(i));
        if (i &lt; n)
        {
            printf(&quot;, &quot;);
        }
    }
    return 0;
}
</code></pre>
<p>程序执行如下：</p>
<pre><code>请输入斐波那契数列长度：10
1, 1, 2, 3, 5, 8, 13, 21, 34, 55
</code></pre>
<h2 id="递归求汉诺塔">递归求汉诺塔</h2>
<p>其实，不论有多少层汉诺塔，都可以使用递归一层一层往下解包。</p>
<pre><code class="language-c">//Example 08
#include &lt;stdio.h&gt;
void hanoi(int, char, char, char);
void hanoi(int n, char x, char y, char z)
{
    if (n == 1)
    {
        printf(&quot;%c --&gt; %c\n&quot;, x, z);//剩下底部的圆盘
    }
    else
    {
        hanoi(n - 1, x, z, y);//将n-1个圆盘从x移动到y
        printf(&quot;x --&gt; z\n&quot;);
        hanoi(n - 1, y, x, z);//将n-1个圆盘从y移动到z
    }
}
int main(void)
{
    int n;
    printf(&quot;请输入汉诺塔的层数：&quot;);
    scanf(&quot;%d&quot;, &amp;n);
    hanoi(n, 'X', 'Y', 'Z');
    return 0;
}
</code></pre>
<p>运行结果如下：</p>
<pre><code>//Consequence 08
请输入汉诺塔的层数：4
X --&gt; Y
x --&gt; z
Y --&gt; Z
x --&gt; z
Z --&gt; X
x --&gt; z
X --&gt; Y
x --&gt; z
Y --&gt; Z
x --&gt; z
Z --&gt; X
x --&gt; z
X --&gt; Y
x --&gt; z
Y --&gt; Z
</code></pre>
<h2 id="分治法">分治法</h2>
<p>所谓分治法，就是大事化小的思维。递归实际上就是一种分治。层层递归，然后从最简单的问题开始解决。</p>
<p>说到这里，就不得不提到一种排序算法，就是十分经典的——快速排序。</p>
<p>作为20世纪十大算法之一，快速排序的基本思想是：通过一项将待排序数据分割成独立的两部分，其中一部分元素均比另一部分小，然后分别对这两部分继续排序，重复步骤直到完成。</p>
<figure data-type="image" tabindex="3"><img src="https://www.cxyxiaowu.com/wp-content/uploads/2019/10/1571057581-e7b9d65b41e66df.gif" alt="快速排序动画演示" loading="lazy"></figure>
<p>代码如下：</p>
<pre><code class="language-c">//Example 09
#include &lt;stdio.h&gt;
void qs(int, int, int);
void qs(int array[], int left, int right)
{
    int i = left, j = right;
    int temp;
    int pivot;
    
    //基准点设置为中间元素，当然别的也可以
    pivot = array[(left + right) / 2];
    
    while (i &lt;= j)
    {
        //找到左边大于等于基准点的元素
        while (array[i] &lt; pivot)
        {
            ++i;
        }
        //找到右边小于等于基准点的元素
        while (array[j] &gt; pivot)
        {
            --j;
        }
        //如果左边下标小于右边，则交换元素
        if (i &lt;= j)
        {
            temp = array[i];
            array[i] = array[j];
            array[j] = temp;
            ++i;
            --j;
        }
    }
    
    //递归遍历左子
    if (left &lt; j)
    {
        qs(array, left, j);
    }
    //递归遍历右子
    if (i &lt; right)
    {
        qs(array, i, right);
    }
}

int main(void)
{
    int array[] = {135, 156, 120, 102, 130, 62, 410, 158, 173, 113, 124, 184, 131, 214};
    int length;
    length = sizeof(array) / sizeof(array[0]);
    qs(array, 0, length - 1);
    
    printf(&quot;排序后结果为：&quot;);
    for (int i = 0; i &lt; length; i++)
    {
        printf(&quot;%d&quot;, array[i]);
        if (i &lt; length - 1)
        {
            printf(&quot;, &quot;);
        }
    }
    putchar('\n');
    return 0;
}
</code></pre>
<p>执行结果如下：</p>
<pre><code>//Consequence 09
排序后结果为：62, 102, 113, 120, 124, 130, 131, 135, 156, 158, 173, 184, 214, 410
</code></pre>
<p>学了这么多，也该好好休息下了！下期再见！</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[C语言之函数（上）]]></title>
        <id>https://harriswilde.github.io/post/cYwGcFKPK</id>
        <link href="https://harriswilde.github.io/post/cYwGcFKPK">
        </link>
        <updated>2020-02-03T06:49:54.000Z</updated>
        <content type="html"><![CDATA[<p>在学习了指针以后，我们的C语言学习就算真正入门了。那么，随着我们自己编写的程序规模越来越大，我们写的代码也越来越繁杂，经常会碰到大脑不够用，或者名字不会起了这类看似很搞笑的问题。再者，就是往往要更改代码的时候牵一发而动全身，稍微出差错，就只能推倒重来。</p>
<p>那么，在做开发，尤其是多人协作的大型开发的时候，程序模块化是十分重要的，你只需要预留一些供他人使用的必须的接口，然后把你定义的方法写个文档方便他人开发就行了。那么这种思维，就是<strong>结构化编程</strong>。</p>
<p>比如，我们经常使用的<code>printf</code>函数，就是C语言开发者写好在<code>stdio.h</code>里面的。有了这个函数，我们就可以很简单地输出文本，而不需要去关注底层到底是如何实现的。你会发现，有函数，我们就可以把更多的注意力放在逻辑的实现上，而不需要去关注太多的细枝末节。</p>
<h1 id="函数的定义和声明">函数的定义和声明</h1>
<h2 id="绪论">绪论</h2>
<p>虽然C语言的内置函数已经十分丰富，可以帮我们实现大部分的问题。什么字符串的处理啊，数学方面的计算啊，等等……但是，作为一门高级语言，C语言还可以让我们自己来定义函数，把我们的一些方法抽象封装出来，用于其他的对象上。</p>
<p>我们举个简单的例子，封装一个输出字符图的函数：</p>
<pre><code class="language-c">//Example 01
#include &lt;stdio.h&gt;
//------定义开始------//
void print_house(void)
{
    printf(&quot;¤╭⌒╮ ╭⌒╮:∴★∵**☆．\n&quot;);
    printf(&quot;╱◥██◣ :∴☆∵**★．\n&quot;);
    printf(&quot;|田︱田田|:∴★∵**☆．\n&quot;);
    printf(&quot;╬╬╬╬╬╬╬╬╬╬╬╬╬╬ \n&quot;);
}
//------定义结束------//
int main(void)
{
    print_house();//调用函数
    return 0;
}
</code></pre>
<p>运行结果如下：</p>
<pre><code>//Consequence 01
¤╭⌒╮ ╭⌒╮:∴★∵**☆．
╱◥██◣ :∴☆∵**★．
|田︱田田|:∴★∵**☆．
╬╬╬╬╬╬╬╬╬╬╬╬╬╬ 
</code></pre>
<h2 id="函数的定义">函数的定义</h2>
<p>定义函数的方法，和我们使用<code>main</code>函数的方法差不多：</p>
<pre><code class="language-c">类型名 函数名(参数列表)
{
    函数体
}
</code></pre>
<ul>
<li>类型名就是函数返回值的类型，如果不希望函数返回任何类型，那么就应该使用<code>void</code>（无类型，表示没有返回值）。</li>
<li><strong>函数名</strong>就是函数的名字，自己想怎么命名都可以，但是不要和保留字重复。</li>
<li><strong>参数列表</strong>指定了参数的<strong>类型</strong>和<strong>名字</strong>，如果不需要传递参数，则写上<code>void</code>即可。</li>
<li><strong>函数体</strong>是指函数的具体算法，是函数中关键部分</li>
</ul>
<h2 id="函数的声明">函数的声明</h2>
<p>所谓的声明，就是将函数先告诉编译器，但是具体算法，则在<code>main</code>函数之后开发。</p>
<p>如果不做声明，把上面的程序改成这样则会出错：</p>
<pre><code class="language-c">//Example 01
#include &lt;stdio.h&gt;
int main(void)
{
    print_house();//调用函数
    return 0;
}
//------定义开始------//
void print_house(void)
{
    printf(&quot;¤╭⌒╮ ╭⌒╮:∴★∵**☆．\n&quot;);
    printf(&quot;╱◥██◣ :∴☆∵**★．\n&quot;);
    printf(&quot;|田︱田田|:∴★∵**☆．\n&quot;);
    printf(&quot;╬╬╬╬╬╬╬╬╬╬╬╬╬╬ \n&quot;);
}
//------定义结束------//
</code></pre>
<p>因为道理上，程序是<strong>从上往下</strong>编译的，如果不提前告知，那么<code>main</code>函数里面的<code>print_house</code>，编译器便不知道这是个什么东西。</p>
<p>如果你做了函数的声明，那么这个程序就可以正常执行：</p>
<pre><code class="language-c">//Example 01
#include &lt;stdio.h&gt;
void print_house(void);//声明函数
int main(void)
{
    print_house();//调用函数
    return 0;
}
//------定义开始------//
void print_house(void)
{
    printf(&quot;¤╭⌒╮ ╭⌒╮:∴★∵**☆．\n&quot;);
    printf(&quot;╱◥██◣ :∴☆∵**★．\n&quot;);
    printf(&quot;|田︱田田|:∴★∵**☆．\n&quot;);
    printf(&quot;╬╬╬╬╬╬╬╬╬╬╬╬╬╬ \n&quot;);
}
//------定义结束------//
</code></pre>
<p>原则上来说，函数必须先定义，再使用。况且在以后的开发尤其是团队协作的情况下，先使用函数，后开发函数的情况比较多，因此养成<strong>先定义，后使用</strong>的良好习惯是最好的。</p>
<h1 id="函数的参数和返回值">函数的参数和返回值</h1>
<p>向函数传入参数，可以使函数的功能更加丰富。比如，我们刚刚定义了一个输出字符画的函数，但是这个函数无论在什么时候，它执行出来的结果都是一样的。无法实现更加个性化的功能。比如：</p>
<pre><code class="language-c">//Example 02
#include &lt;stdio.h&gt;
void print(int);

int main(void)
{
	int a;
	scanf(&quot;%d&quot;, &amp;a);
	print(a);
	return 0;
}

void print(int a)
{
	for (int i = a; i &gt; 0; i--)
	{
		printf(&quot;-&quot;);
	}
}
</code></pre>
<p>运行结果如下：</p>
<pre><code>//Consequence 02 - 01
5
-----
</code></pre>
<pre><code>//Consequence 02 - 02
7
-------
</code></pre>
<p>你看，输出的内容会随着用户输入的数字而改变，就像<strong>定制</strong>一样。</p>
<p>那么函数的<strong>返回值</strong>又是什么呢？</p>
<p>我们发现，我们刚刚写的函数，都没有返回值，因为在函数体的执行过程中，我们要得到的结果已经执行完毕了，并不需要返回什么东西。但是，有些函数就不一样了。</p>
<p>比如，我们现在要创建一个函数，能够实现阶乘，这时候，就需要返回值了。</p>
<pre><code class="language-c">//Example 03 - 迭代法
#include &lt;stdio.h&gt;
int factorial(int);

int main(void)
{
    int a;
    scanf(&quot;%d&quot;,&amp;a);
    printf(&quot;%d&quot;, factorial(a));
    return 0;
}

int factorial(int a)
{
    int sum = 1;
    for (int i = a; i &gt; 0; i--)
    {
        sum *= i;
    }
    return sum;
}
</code></pre>
<pre><code class="language-c">//Example 03 - 递归法
#include &lt;stdio.h&gt;
int factorial(int);

int main(void)
{
    int a;
    scanf(&quot;%d&quot;, &amp;a);
    printf(&quot;%d&quot;, factorial(a));
    return 0;
}

int factorial(int a)
{
    int sum;
    if (a == 1)
    {
        return 1;
    }
    else
    {
        return a * factorial(a - 1);
    }
}
</code></pre>
<p>执行结果如下：</p>
<pre><code>//Consequence 03
5
120
</code></pre>
<h2 id="形参和实参">形参和实参</h2>
<p>所谓<strong>形参</strong>，就是形式参数，如：</p>
<pre><code class="language-c">...
int f(int a, int b);
...
</code></pre>
<p>这其中的<code>a</code>和<code>b</code>就是形式参数，此时只是作占位符而已，而在函数真正使用的时候：</p>
<pre><code class="language-c">...
int main(void)
{
    f(x, y);
    ...
}
...
</code></pre>
<p>此时的<code>x</code>和<code>y</code>就是<strong>实参</strong>。因为此时传递进去的值是真正程序里面拥有的值，是实实在在的。</p>
<p>其实形参和实参的作用就是用来传递数据的，当我们自己定义的函数被调用的时候，实参会将值传递给形参（单向传递）。形参变量只有在函数被调用的时候才会分配内存，调用结束后，立即释放内存，因此形参变量只有在函数内部有效，<strong>对函数外的变量不影响</strong>。</p>
<h2 id="传值和传址">传值和传址</h2>
<pre><code class="language-c">//Example 04 - 01
#include &lt;stdio.h&gt;
void swap(int, int);
void swap(int a, int b)
{
    int temp;
    printf(&quot;swap中，交换前：a = %d, b = %d\n&quot;, a, b);
    temp = a;
    a = b;
    b = temp;
    printf(&quot;swap中，交换前：a = %d, b = %d\n&quot;, a, b);
}

int main(void)
{
    int a = 1, b = 2;
    printf(&quot;main中，交换前：a = %d, b = %d\n&quot;, a, b);
    swap(a, b);
    printf(&quot;main中，交换前：a = %d, b = %d\n&quot;, a, b);
    return 0;
}
</code></pre>
<p>运行结果为：</p>
<pre><code>//Consequence 04 - 01
main中，交换前：a = 1, b = 2
swap中，交换前：a = 1, b = 2
swap中，交换前：a = 2, b = 1
main中，交换前：a = 1, b = 2
</code></pre>
<p>可以看到，在<code>swap</code>函数内，传入的值被互换，但是在主函数内，值依旧没有被改变。因此可以得出结论：<strong>函数内部无法改变实参的值</strong></p>
<p>但是，如果换成指针会怎样呢？</p>
<pre><code class="language-c">//Example 04 - 02
#include &lt;stdio.h&gt;
void swap(int*, int*);
void swap(int* a, int* b)
{
    int temp;
    printf(&quot;swap中，交换前：a = %d, b = %d\n&quot;, *a, *b);
    temp = *a;
    *a = *b;
    *b = temp;
    printf(&quot;swap中，交换前：a = %d, b = %d\n&quot;, *a, *b);
}

int main(void)
{
    int a = 1, b = 2;
    printf(&quot;main中，交换前：a = %d, b = %d\n&quot;, a, b);
    swap(&amp;a, &amp;b);
    printf(&quot;main中，交换前：a = %d, b = %d\n&quot;, a, b);
    return 0;
}
</code></pre>
<p>运行结果为：</p>
<pre><code class="language-c">//Consequence 04 - 02
main中，交换前：a = 1, b = 2
swap中，交换前：a = 1, b = 2
swap中，交换前：a = 2, b = 1
main中，交换前：a = 2, b = 1
</code></pre>
<p>欸？怎么这会儿就能变了呢？有人可能会说，Harris你是不是刚刚骗我？</p>
<p>其实并不是，我们看这句：<code>swap(&amp;a, &amp;b);</code>，我们其实传入的实参是两个变量的地址。</p>
<p>打个比方，如果变量<code>a</code>的在内存里面住的是1号房间，变量<code>b</code>在内存中住的是2号房间。那么函数处理了之后，他俩住的地方并没有改变，也就是说，两个变量的内存地址并没有改变，只是函数把这个地址对应的值改变了而已。函数内对指针进行解引用，实际上就是间接地访问了变量的值。</p>
<h2 id="传数组">传数组</h2>
<p>既然是可以传递指针，那么数组按理来说，应该也是可以传的。</p>
<pre><code class="language-c">//Example 05
#include &lt;stdio.h&gt;
void get_array(int);
void get_array(int a[10])
{
	for (int i = 0; i &lt; 10; i++)
	{
		printf(&quot;a[%d] = %d\n&quot;, i, a[i]);
	}
}

int main(void)
{
	int a[10] = { 1,2,3,4,5,6,7,8,9,10 };
	get_array(a);
	return 0;
}
</code></pre>
<pre><code class="language-c">//Consequence 05
a[0] = 1
a[1] = 2
a[2] = 3
a[3] = 4
a[4] = 5
a[5] = 6
a[6] = 7
a[7] = 8
a[8] = 9
a[9] = 10
</code></pre>
<p>如果我们尝试着在函数内改变数组的值呢？</p>
<pre><code class="language-c">//Example 06
#include &lt;stdio.h&gt;
void get_array(int);
void get_array(int a[10])
{
	a[4] = 1;//更改一个值
	for (int i = 0; i &lt; 10; i++)
	{
		printf(&quot;a[%d] = %d\n&quot;, i, a[i]);
	}
}

int main(void)
{
	int a[10] = { 1,2,3,4,5,6,7,8,9,10 };
	get_array(a);
	return 0;
}
</code></pre>
<pre><code>//Consequence 06
a[0] = 1
a[1] = 2
a[2] = 3
a[3] = 4
a[4] = 1
a[5] = 6
a[6] = 7
a[7] = 8
a[8] = 9
a[9] = 10
</code></pre>
<p>可以看到，在主函数里面输出数组，也是被改变了的。于是可以断定，其实传入的并不是一个数组，而是这个数组的<strong>首地址</strong>而已。</p>
<h2 id="可变参数">可变参数</h2>
<p>可能有的同学会纳闷，我们定义的函数，都是给参数预留了位置的，那如果像<code>printf()</code>这种函数，它的参数是取决于占位符的数量，这种函数是怎么定义的呢？</p>
<p>这里，我们就要将一个以前没有用过的头文件<code>&lt;stdarg.h&gt;</code>。这个头文件中有一个类型和三个宏是需要用到的：</p>
<p>一个类型是<code>va_list</code>，三个宏是<code>va_start</code> <code>va_arg</code> <code>va_end</code>，其中，<code>va</code>就是指<strong>variable-argument（可变参数）</strong>。</p>
<pre><code class="language-c">//Example 07
#include &lt;stdio.h&gt;
#include &lt;stdarg.h&gt;
int sum(int n, ...);
int sum(int n, ...)//第一个参数n代表后面可变参数的数量，三个点代表不确定参数个数
{
	int sum = 0;
	va_list arg;//定义参数列表
	va_start(arg, n);//初始化参数列表，n为第一个参数的名称
	for (int i = 0; i &lt; n; i++)
	{
		sum += va_arg(arg, int);//依次获取参数值
	}
	va_end(arg);//结束参数列表
	return sum;
}

int main(void)
{
	int result;
	result = sum(5, 1, 2, 3, 4, 5);
	printf(&quot;result = %d\n&quot;, result);
	return 0;
}
</code></pre>
<p>结果如下：</p>
<pre><code>//Consequence 07
result = 15
</code></pre>
<h1 id="指针函数和函数指针">指针函数和函数指针</h1>
<h2 id="指针函数">指针函数</h2>
<p>函数的类型，实际上就是函数返回值的类型，那么顾名思义，指针函数就是返回指针的函数。</p>
<pre><code class="language-c">//Example 08
#include &lt;stdio.h&gt;
char* getWord(char);
char* getWord(char c)
{
    switch (c)
    {
    case 'A':return &quot;Apple&quot;;
    case 'B':return &quot;Boy&quot;;
    case 'C':return &quot;Cat&quot;;
    case 'D':return &quot;Dog&quot;;
    default:return &quot;None&quot;;
    }
}
int main(void)
{
    char input;
    scanf(&quot;%c&quot;, &amp;input);
    printf(&quot;%s&quot;, getWord(input));
    return 0;
}
</code></pre>
<p>运行结果：</p>
<pre><code>//Consequence 08
A
Apple
</code></pre>
<p>有的小伙伴可能会说，为啥这个<code>switch</code>语句中不用加<code>break</code>呢？</p>
<p>因为<code>return</code>实际上就代表函数执行的结束，因此不会执行到下面的<code>case</code>。</p>
<p>这个例子就是让函数返回字符串(指针)。</p>
<p>另外，不要将函数中局部变量的值作为返回值，因为局部变量的值的作用域（有效范围）只有<strong>函数内部</strong>，因此返回局部变量是不合法的（详细将在下一节中讲到）。</p>
<h2 id="函数指针">函数指针</h2>
<pre><code class="language-c">指针函数 -&gt; int* f();
函数指针 -&gt; int (*p)();
</code></pre>
<p>本质上，函数表示法就是指针表示法。因为函数的名字经过取值会变成函数的地址，所以在定义了函数指针以后，给它传递一个已经被定义的函数名，即可通过该指针进行调用。</p>
<pre><code class="language-c">//Example 09
#include &lt;stdio.h&gt;
int square(int);
int square(int a)
{
    return a * a;
}
int main(void)
{
    int num;
    int (*fp)(int);
    scanf(&quot;%d&quot;, &amp;num);
    fp = square;
    printf(&quot;%d * %d = %d\n&quot;, num, num, (*fp)(num));
    return 0;
}
</code></pre>
<p>结果如下：</p>
<pre><code>//Consequence 10
5
5 * 5 = 25
</code></pre>
<p>这里<code>fp = square</code>可以写成<code>fp = &amp;square</code>，<code>(*fp)(num)</code>可以写成<code>fp(num)</code>，可能更加符合我们之前的习惯。</p>
<h2 id="函数指针作为参数">函数指针作为参数</h2>
<p>函数指针也可以作为参数传递，这样函数就可以实现更加丰富的功能。</p>
<pre><code class="language-c">//Example 11
#include &lt;stdio.h&gt;

int add(int, int);
int sub(int, int);
int calc(int (*fp)(int, int), int, int);

int add(int a, int b)
{
    return a + b;
}
int sub(int a, int b)
{
    return a - b;
}
int calc(int (*fp)(int, int), int a, int b)
{
    return (*fp)(a, b);
}

int main(void)
{
    printf(&quot;1 + 2 = %d\n&quot;, calc(add, 1, 2));
    printf(&quot;1 - 2 = %d\n&quot;, calc(sub, 1, 2));
    return 0;
}
</code></pre>
<p>运行结果为：</p>
<pre><code>//Consequence 11
1 + 2 = 3
1 - 2 = -1
</code></pre>
<h2 id="函数指针作为返回值">函数指针作为返回值</h2>
<p>假设现在有个问题，让用户输入一个表达式，然后根据用户输入的运算符来确定应该调用哪一个函数进行运算。</p>
<pre><code class="language-c">//Example 12
#include &lt;stdio.h&gt;

int add(int, int);
int sub(int, int);
int calc(int (*fp)(int, int), int, int);
int (*select(char op))(int, int);

int add(int a, int b)
{
    return a+b;
}
int sub(int a, int b)
{
    return a-b;
}
int calc(int (*fp)(int, int), int a, int b)
{
    return (*fp)(a, b);
}
int (*select(char op))(int, int)
{
    switch(op)
    {
        case '+':return add;
        case '-':return sub;
    }
}
int main(void)
{
    int a, b;
    char op;
    int (*fp)(int, int);
    printf(&quot;请输入一个式子，如1+2：&quot;);
    scanf(&quot;%d%c%d&quot;, &amp;a, &amp;op, &amp;b);
    fp =  select(op);
    printf(&quot;%d %c %d = %d\n&quot;, a, op, b, calc(fp, a, b));
    return 0;
}
</code></pre>
<p>运行结果如下：</p>
<pre><code>//Consequence 12
请输入一个式子，如1+2：3+4
3 + 4 = 7
</code></pre>
<p>函数的知识太多太繁杂，所以Harris这次采用分节式来写博客。本期的就到这里啦！如果没有理解的，好好去消化下，理解了的就等我下一篇吧！</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[浅谈拼手气红包的算法]]></title>
        <id>https://harriswilde.github.io/post/BGqcimUfF</id>
        <link href="https://harriswilde.github.io/post/BGqcimUfF">
        </link>
        <updated>2020-01-27T08:22:30.000Z</updated>
        <content type="html"><![CDATA[<hr>
<p>首先，在这里祝各位小伙伴们鼠年大吉！！</p>
<p>今天是大年初三，Harris在这里用一个简单的话题，开启鼠年的博客之旅。</p>
<p>大家每逢佳节，最少不了的活动，就是“抢红包”。自打微信推出了电子红包之后，中国人的节日，又多了一种庆祝方式，那就是<strong>红包雨</strong>。这种将传统活动用科技的方式封装的做法，是Harris比较赞成的。把传统溶于新时代，为我们的传统春节带来了新鲜的空气。</p>
<p>但是，我们在群里发红包的时候，可能有的小伙伴会纳闷儿，这个所谓的随机金额，到底是怎么算的呢？它到底是不是公平的呢？</p>
<p>有的小伙伴和我说，这还不简单么，每一个人打开红包的时候，都按照当前剩余的余额为范围，随机生成一个数字就好了。</p>
<p>但是呢，这样的话，随着红包被打开的越来越多，金额的总数也会越来越少。那么，可以抢到的红包也就越来越小，这虽然遵循我们常规所认为的“先来后到”，但是并不公平。</p>
<p>那么要实现绝对的公平，该怎么办呢？</p>
<h1 id="1-随机分割">1. 随机分割</h1>
<p>其实，这种方法很直观就能想到。我们把一个红包想象成一个香肠，假设有<code>N</code>个人来分这个香肠，那么我们只要随机切<code>N-1</code>刀，把每一块分别分给每一个人即可。</p>
<p>红包也是一样的道理，我们可以在红包发出去的同时，就随机分配好金额。等大家来分的时候，再依次分给每一个人就好了。</p>
<p>这种算法思路并不难，而且也能够达到我们的目的，但是由于以下的两点，导致微信没有采用这种算法：</p>
<ol>
<li>算法复杂度高</li>
<li>对服务器端的要求高</li>
</ol>
<p>首先第一点，这个算法的复杂度，肯定是要比现行的微信随机红包算法的复杂度高很多。另外，由于在红包发出去的瞬间，服务器上就需要存储关于这个红包的分配信息，在春节这种红包高峰期的时候，势必会给服务器带来巨大的压力。在分布式系统没有普及之前，第二点都将是一个难以解决的问题。</p>
<p>因此，微信就退而求其次，采用第二种办法。</p>
<h1 id="2-二倍均值法">2. 二倍均值法</h1>
<p>实际上，我们每个人抢到的红包，都是在下面这个区间里面去随机一个数值：</p>
<p class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mrow><mo fence="true">(</mo><mn>0</mn><mo separator="true">,</mo><mn>2</mn><mover accent="true"><mi>M</mi><mo stretchy="true">‾</mo></mover><mo fence="true">]</mo></mrow><mspace width="1em"/><mo separator="true">;</mo><mover accent="true"><mi>M</mi><mo stretchy="true">‾</mo></mover><mo>=</mo><mfrac><mrow><mi mathvariant="normal">剩</mi><mi mathvariant="normal">余</mi><mi mathvariant="normal">金</mi><mi mathvariant="normal">额</mi></mrow><mrow><mi mathvariant="normal">剩</mi><mi mathvariant="normal">余</mi><mi mathvariant="normal">红</mi><mi mathvariant="normal">包</mi><mi mathvariant="normal">数</mi></mrow></mfrac></mrow><annotation encoding="application/x-tex">\left(0,2\overline {M}\right]\quad;\overline M=\frac{剩余金额}{剩余红包数}
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.23334em;vertical-align:-0.35001em;"></span><span class="minner"><span class="mopen delimcenter" style="top:0em;"><span class="delimsizing size1">(</span></span><span class="mord">0</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">2</span><span class="mord overline"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8833300000000001em;"><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.10903em;">M</span></span></span><span style="top:-3.80333em;"><span class="pstrut" style="height:3em;"></span><span class="overline-line" style="border-bottom-width:0.04em;"></span></span></span></span></span></span><span class="mclose delimcenter" style="top:0em;"><span class="delimsizing size1">]</span></span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mspace" style="margin-right:1em;"></span><span class="mpunct">;</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord overline"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8833300000000001em;"><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="mord mathdefault" style="margin-right:0.10903em;">M</span></span><span style="top:-3.80333em;"><span class="pstrut" style="height:3em;"></span><span class="overline-line" style="border-bottom-width:0.04em;"></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1.363em;vertical-align:-0.686em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.677em;"><span style="top:-2.314em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord cjk_fallback">剩</span><span class="mord cjk_fallback">余</span><span class="mord cjk_fallback">红</span><span class="mord cjk_fallback">包</span><span class="mord cjk_fallback">数</span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.677em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord cjk_fallback">剩</span><span class="mord cjk_fallback">余</span><span class="mord cjk_fallback">金</span><span class="mord cjk_fallback">额</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.686em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span></span></p>
<p>微信，正是采用的这种方法。</p>
<p>那么，为什么这个是公平的呢？</p>
<p>假设，发一个100元的红包，10份。那么第一个人的金额，就会在<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo fence="true">(</mo><mn>0</mn><mo separator="true">,</mo><mn>20</mn><mo fence="true">]</mo></mrow><annotation encoding="application/x-tex">\left(0,20\right]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="minner"><span class="mopen delimcenter" style="top:0em;">(</span><span class="mord">0</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">2</span><span class="mord">0</span><span class="mclose delimcenter" style="top:0em;">]</span></span></span></span></span>元里面随机。假设第一个人抢到了平均值10块钱，那么还剩90.</p>
<p>第二个人的抢到的，应该是<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mrow><mo fence="true">(</mo><mn>0</mn><mo separator="true">,</mo><mn>2</mn><mo>⋅</mo><mfrac><mn>90</mn><mn>9</mn></mfrac><mo fence="true">]</mo></mrow><mo>⇒</mo><mrow><mo fence="true">(</mo><mn>0</mn><mo separator="true">,</mo><mn>20</mn><mo fence="true">]</mo></mrow></mrow><annotation encoding="application/x-tex">\left(0,2\cdot \frac{90}{9}\right]\Rightarrow \left(0,20\right]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.20001em;vertical-align:-0.35001em;"></span><span class="minner"><span class="mopen delimcenter" style="top:0em;"><span class="delimsizing size1">(</span></span><span class="mord">0</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">2</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">⋅</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.845108em;"><span style="top:-2.6550000000000002em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">9</span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.394em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">9</span><span class="mord mtight">0</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.345em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mclose delimcenter" style="top:0em;"><span class="delimsizing size1">]</span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">⇒</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="minner"><span class="mopen delimcenter" style="top:0em;">(</span><span class="mord">0</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">2</span><span class="mord">0</span><span class="mclose delimcenter" style="top:0em;">]</span></span></span></span></span>，和之前的一样，以此类推，这个算法是公平的。</p>
<p>但是，并不是每一次都能够理想化地抢到平均值，毕竟我们是要在这个范围内取随机值。假设第一个人只抢到了1块钱，那么第二个人能够抢到的范围是<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo fence="true">(</mo><mn>0</mn><mo separator="true">,</mo><mn>22</mn><mo fence="true">]</mo></mrow><annotation encoding="application/x-tex">\left(0,22\right]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="minner"><span class="mopen delimcenter" style="top:0em;">(</span><span class="mord">0</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">2</span><span class="mord">2</span><span class="mclose delimcenter" style="top:0em;">]</span></span></span></span></span>，范围就更大了点，假设第二个人也只抢到1块钱，那么第三个人的范围就是<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo fence="true">(</mo><mn>0</mn><mo separator="true">,</mo><mn>24.5</mn><mo fence="true">]</mo></mrow><annotation encoding="application/x-tex">\left(0,24.5\right]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="minner"><span class="mopen delimcenter" style="top:0em;">(</span><span class="mord">0</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">2</span><span class="mord">4</span><span class="mord">.</span><span class="mord">5</span><span class="mclose delimcenter" style="top:0em;">]</span></span></span></span></span>，以此类推，假设前面的9个人都只抢到1块钱，那么最后一个人的范围，就是<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo fence="true">(</mo><mn>0</mn><mo separator="true">,</mo><mn>91</mn><mo fence="true">]</mo></mrow><annotation encoding="application/x-tex">\left(0,91\right]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="minner"><span class="mopen delimcenter" style="top:0em;">(</span><span class="mord">0</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">9</span><span class="mord">1</span><span class="mclose delimcenter" style="top:0em;">]</span></span></span></span></span>，实际上就是91块。所以我们可以看到，如果每个人都抢到范围内平均值以下，那么后面的人的随机范围则会越来越大。</p>
<p>那么，我们来看看另外一个极端，如果第一个人抢到20块钱，那么第二个人的范围就是<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo fence="true">(</mo><mn>0</mn><mo separator="true">,</mo><mn>17.76</mn><mo fence="true">]</mo></mrow><annotation encoding="application/x-tex">\left(0,17.76\right]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="minner"><span class="mopen delimcenter" style="top:0em;">(</span><span class="mord">0</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">1</span><span class="mord">7</span><span class="mord">.</span><span class="mord">7</span><span class="mord">6</span><span class="mclose delimcenter" style="top:0em;">]</span></span></span></span></span>，假设第二个人抢到17元，第三个人的范围就是<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo fence="true">(</mo><mn>0</mn><mo separator="true">,</mo><mn>15.75</mn><mo fence="true">]</mo></mrow><annotation encoding="application/x-tex">\left(0,15.75\right]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="minner"><span class="mopen delimcenter" style="top:0em;">(</span><span class="mord">0</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">1</span><span class="mord">5</span><span class="mord">.</span><span class="mord">7</span><span class="mord">5</span><span class="mclose delimcenter" style="top:0em;">]</span></span></span></span></span>……</p>
<p>范围会越来越小，但是每个人的红包都不大，都没有超过第一个人，因此第一个人是本次的运气王。</p>
<p>所以，其实这个算法这么看，貌似的确不那么公平，第一个人永远只能抢到二倍均值以下，也就是说，第一个人就是抢不到大红包，而越往后越<strong>有可能</strong>抢到大红包。</p>
<p>当然，运气王是有可能出现在任意的位置，运气王的位置靠前，则整体不会有很大的红包，运气王靠后的话，后面就有可能出现比前面大很多的红包。</p>
<p>那么这样的算法用代码如何实现呢？</p>
<p>Harris都给大家列出来了，如果感兴趣可以研究研究：</p>
<p>Java:</p>
<pre><code class="language-java">//代码来源于网络
//发红包算法，金额参数以分为单位
public static List&lt;Integer&gt; divideRedPackage(Integer totalAmount, Integer totalPeopleNum){
    List&lt;Integer&gt; amountList = new ArrayList&lt;Integer&gt;();
    Integer restAmount = totalAmount;
    Integer restPeopleNum = totalPeopleNum;
    Random random = new Random();
    for(int i=0; i&lt;totalPeopleNum-1; i++){
        //随机范围：[1，剩余人均金额的两倍)，左闭右开
        int amount = random.nextInt(restAmount / restPeopleNum * 2 - 1) + 1;
        restAmount -= amount;
        restPeopleNum --;
        amountList.add(amount);
    }
    amountList.add(restAmount);
    return amountList;
}
public static void main(String[] args){
    List&lt;Integer&gt; amountList = divideRedPackage(5000, 30);
    for(Integer amount : amountList){
        System.out.println(&quot;抢到金额：&quot; + new BigDecimal(amount).divide(new BigDecimal(100)));
    }
}
</code></pre>
<p>C/C++：</p>
<pre><code class="language-c">#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;

void money();
void money(double TotalAmount, int TotalPeople)
{
	double restAmount = TotalAmount;
	int restPeople = TotalPeople;
	for (int i = 0; i &lt; TotalPeople - 1; ++i)
	{
		int amount = rand() % ((int)((restAmount / restPeople) * 2) * 100);
		restAmount -= amount / 100;
		--restPeople;
		printf(&quot;抢到金额：%.2f\n&quot;, (double)amount / 100);
	}
	printf(&quot;抢到金额：%.2f\n&quot;, (double)restAmount / 100);
}

int main(void)
{
	money(50, 30);
	return 0;
}
</code></pre>
<p>Python：</p>
<pre><code class="language-python">import random
def money(TotalMoney,TotalPeople):
    restMoney = TotalMoney
    restPeople = TotalPeople
    for i in range(TotalPeople - 1):
        mount = round(random.uniform(0.01,(restMoney / restPeople) * 2 - 0.01),2)
        restMoney -= mount
        restPeople -= 1
        print(&quot;抢到金额：&quot;+str(mount))
    print(&quot;抢到金额：&quot;+str(round(restMoney,2)))

money(50,30)
</code></pre>
<p>本篇博客就到此结束了，其实生活中处处充满着知识，就看你有没有一颗爱钻研的心！</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[初识Python，多多关照]]></title>
        <id>https://harriswilde.github.io/post/PythonBasic</id>
        <link href="https://harriswilde.github.io/post/PythonBasic">
        </link>
        <updated>2020-01-14T02:27:02.000Z</updated>
        <content type="html"><![CDATA[<p>在开始之前，我们先来认识认识Python的一些基本信息。</p>
<p>在上一节里面，我们已经带大家安装好了Python的官方IDLE，并且教给大家了一个命令，那就是<code>print(&quot;新年快乐！&quot;)</code>，那么这节我们就来大致了解下Python以及利用Python进行的程序设计。</p>
<hr>
<h1 id="算法是什么">算法是什么</h1>
<p>在开始编程之前，我们先来了解下什么是<strong>计算机程序设计</strong>。简单地说，计算机虽然能够做很多事情，而且速度很快，但是它好像浑身冒着一股不太聪明的亚子，不太擅长自己思考。只有我们告诉它要干什么，它才会去给我们效力。那么，这样的话，我们设计程序的时候，就需要告诉计算机每一步该怎么做，那么这些步骤按照顺序编排起来，就称之为<code>算法</code>。因此算法没啥大不了，不过就是做事情的步骤罢了。比如我要煎牛排，但是我不知道怎么做，那么我去请一位师傅，他就会这样告诉我：</p>
<pre><code>准备好炊具，食材
把锅烧热
放入黄油
将牛排放入其中
将火候调整为适中
每30秒翻一次面
检查牛排表面，若颜色呈金黄有焦香，则盛出
若没有，则重复翻面步骤
</code></pre>
<p>这就是做牛排的一种算法。计算机就是这样，每一步的任何细节你都要告诉它，否则它就无法判断，就会罢工。比如把<code>每30秒翻一次面</code>改为<code>每隔一会儿翻一次面</code>的话，计算机就不会了。</p>
<h1 id="对象">对象</h1>
<p>正所谓，万物皆对象。在Python里面，一个数，一个字符(串)等等都属于对象。</p>
<h2 id="查看对象的地址">查看对象的地址</h2>
<p>具体的每一个常量在Python中都是一个对象。每个对象，在内存中都有一个自己的地址，这就是它的<strong>身份</strong>。我们想要知道它的地址，只需要使用<code>id()</code>函数即可。</p>
<pre><code class="language-python">&gt;&gt;&gt; id(4)
140705889218928
&gt;&gt;&gt; id(3.14)
1923954506000
&gt;&gt;&gt; id(&quot;a&quot;)
1923945858224
&gt;&gt;&gt; id(&quot;TechZone&quot;)
1923955766256
</code></pre>
<h2 id="查看对象类型">查看对象类型</h2>
<p>每一个对象也都有自己的<strong>类型</strong>，这是它们的种族。我们只需要使用函数<code>type()</code>就可以知道每一个对象的类型。</p>
<pre><code class="language-python">&gt;&gt;&gt; type(4)
&lt;class 'int'&gt;
&gt;&gt;&gt; type(3.14)
&lt;class 'float'&gt;
&gt;&gt;&gt; type(&quot;a&quot;)
&lt;class 'str'&gt;
&gt;&gt;&gt; type(&quot;TechZone&quot;)
&lt;class 'str'&gt;
</code></pre>
<h1 id="数与四则运算">数与四则运算</h1>
<p>在Python里面，支持4中类型的数，分别是<code>int(有符号整型)</code> <code>long(长整型)</code> <code>float(浮点型)</code> <code>complex(复数)</code>。</p>
<p>四则运算和我们平时使用的计算机差不多：<code>+加</code> <code>-减</code> <code>*乘</code> <code>/除</code>。</p>
<p>不过，除法还有一种，就是<code>//整除</code>。也就是<strong>取整除法</strong>。</p>
<pre><code class="language-python">&gt;&gt;&gt; 1+2
3
&gt;&gt;&gt; 33+54
87
&gt;&gt;&gt; 1-3
-2
&gt;&gt;&gt; 99*99
9801
&gt;&gt;&gt; 3/2
1.5
&gt;&gt;&gt; 3//2
1
</code></pre>
<h1 id="语句和语句块">语句和语句块</h1>
<p>Python和大部分的语言不同，就在于它的语句块是使用<strong>缩进</strong>来控制的，而<strong>不是</strong>使用大括号。并且语句的结束<strong>没有</strong>分号，不使用转行符<code>\</code>的情况下，回车就代表语句的结束。</p>
<p>比如下面的一个程序，我分别使用C++和Python来写。</p>
<p>C++：</p>
<pre><code class="language-c++">#include &lt;iostream&gt;
using namespace std;
 
int main (void)
{
   int a = 100;
 
   if( a &lt; 20 )
   {
       cout &lt;&lt; &quot;a 小于 20&quot; &lt;&lt; endl;
   }
   else
   {
       cout &lt;&lt; &quot;a 大于 20&quot; &lt;&lt; endl;
   }
   cout &lt;&lt; &quot;a 的值是 &quot; &lt;&lt; a &lt;&lt; endl;
 
   return 0;
}
</code></pre>
<p>Python：</p>
<pre><code class="language-python">a = int(100)
if a &lt; int(20):
    print(&quot;a小于20&quot;)
else:
    print(&quot;a大于20&quot;)
print(f&quot;a的值是{a}&quot;)
</code></pre>
<p>那么换行符<code>\</code>怎么用呢？看例子：</p>
<p>这是一行写完的：</p>
<pre><code class="language-python">...
total = item1 + item2 + item3
...
</code></pre>
<p>这是换行：</p>
<pre><code class="language-python">...
total = iten1 + \
iten2 + \
item3
...
</code></pre>
<h1 id="变量">变量</h1>
<p>如果你数学不好，也不用害怕。这里的变量，就是指的一个名字而已。比如：</p>
<pre><code class="language-python">score = int(100)
</code></pre>
<p>这里，我就把整数100赋值给了变量<code>score</code>，如果以后有改动，<code>score</code>还可以重新赋值，因此称之为变量。</p>
<p>变量的类型就是被赋值元素的类型，比如这里<code>score</code>的类型就是<code>int</code>。</p>
<p>变量的名称可以包含<strong>数字、字母和下划线</strong>。但是数字<strong>不能</strong>够作为变量名的开头。</p>
<h2 id="多变量赋值">多变量赋值</h2>
<p>Python里面赋值还有一种方法，就是多变量赋值，比如：</p>
<p>多个变量的值相同：</p>
<pre><code class="language-python">a = b = c = 1
</code></pre>
<p>多个变量的值不同：</p>
<pre><code class="language-python">a, b, c = 1, 2, &quot;TechZone&quot;
</code></pre>
<p>或者你还可以交换两个变量的值：</p>
<pre><code class="language-python">a, b = b, a
</code></pre>
<p>还是很方便的，对吧？</p>
<h1 id="注释">注释</h1>
<p>注释，简单来说就是写一些方便人类对代码阅读的一些提示性语言，但是解释器在运行的时候是<strong>不会</strong>去理会这些东西的。</p>
<h2 id="单行注释">单行注释</h2>
<p>单行注释用<code>#</code>号，也就是说，<code>#</code>号后面的任何文字，解释器都不会去理会。</p>
<pre><code class="language-python">...
print(&quot;Hello, world!&quot;) #输出Hello,world!
...
</code></pre>
<h2 id="多行注释">多行注释</h2>
<p>多行注释使用三引号，具体使用三个单引号或者三个双引号都可以。</p>
<pre><code class="language-python">'''
这是一个多行注释，
你可以在这里面长篇大论
写篇小说也是没有问题
'''
</code></pre>
<pre><code class="language-python">&quot;&quot;&quot;
这也是多行注释，
随便你用哪种，
喜欢就好
&quot;&quot;&quot;
</code></pre>
<p>当然，三引号的作用还有别的，我们以后再讲。</p>
<h1 id="python中的保留字">Python中的保留字</h1>
<p>这些保留字，不能够用于<strong>任何</strong>常量，变量和标识符名称。这些是Python自身语法要用的字，并且只包含<strong>小写</strong>。</p>
<blockquote>
<p>and, exec, not, assert, finally, or, break, for, pass, class, from, print, continue, global, raise, def, if, return, del, import, try, elif, in, while, else, is, with, except, lambda, yield.</p>
</blockquote>
<hr>
<p>初识Python，希望它的简洁和优雅能够给你带来舒适和快乐！</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[C语言之指针]]></title>
        <id>https://harriswilde.github.io/post/CPointer</id>
        <link href="https://harriswilde.github.io/post/CPointer">
        </link>
        <updated>2020-01-12T14:18:53.000Z</updated>
        <content type="html"><![CDATA[<p>说到指针，估计还是有很多小伙伴都还是云里雾里的，有点“知其然，而不知其所以然”。但是，不得不说，学了指针，C语言才能算是入门了。指针是C语言的<strong>精华</strong>，可以说，对对指针的掌握程度，<strong>直接决定</strong>了你C语言的编程能力。</p>
<hr>
<p>在讲指针之前，我们先来了解下变量在<strong>内存</strong>中是如何存放的。</p>
<p>在程序中定义一个变量，那么在程序编译的过程中，系统会根据你定义变量的类型来分配<strong>相应尺寸</strong>的内存空间。那么如果要使用这个变量，只需要用变量名去访问即可。</p>
<p>通过变量名来访问变量，是一种<strong>相对安全</strong>的方式。因为只有你定义了它，你才能够访问相应的变量。这就是对内存的基本认知。但是，如果光知道这一点的话，其实你还是不知道内存是如何存放变量的，因为底层是如何工作的，你依旧不清楚。</p>
<p>那么如果要继续深究的话，你就需要把变量在内存中真正的样子是什么搞清楚。内存的最小索引单元是<code>1字节</code>，那么你其实可以把内存比作一个超级大的<strong>字符型数组</strong>。在上一节我们讲过，数组是有下标的，我们是通过数组名和下标来访问数组中的元素。那么内存也是一样，只不过我们给它起了个新名字：<code>地址</code>。每个地址可以存放<strong>1字节</strong>的数据，所以如果我们需要定义一个整型变量，就需要占据4个内存单元。</p>
<p>那么，看到这里你可能就明白了：其实在程序运行的过程中，完全不需要变量名的参与。变量名只是方便我们进行代码的编写和阅读，只有程序员和编译器知道这个东西的存在。而编译器还知道具体的变量名对应的<strong>内存地址</strong>，这个是我们不知道的，因此编译器就像一个桥梁。当读取某一个变量的时候，编译器就会找到变量名所对应的地址，读取对应的值。</p>
<h1 id="初识指针和指针变量">初识指针和指针变量</h1>
<p>那么我们现在就来切入正题，指针是个什么东西呢？</p>
<p>所谓指针，就是内存地址（下文简称地址）。C语言中设立了专门的<strong>指针变量</strong>来存储指针，和<strong>普通变量</strong>不一样的是，指针变量存储的是<strong>地址</strong>。</p>
<h2 id="定义指针">定义指针</h2>
<p>指针变量也有类型，实际上取决于地址指向的值的类型。那么如何定义指针变量呢：</p>
<p>很简单：<code>类型名* 指针变量名</code></p>
<pre><code class="language-c">char* pa;//定义一个字符变量的指针，名称为pa
int* pb;//定义一个整型变量的指针，名称为pb
float* pc;//定义一个浮点型变量的指针，名称为pc
</code></pre>
<p>注意，指针变量一定要和指向的变量的类型一样，不然类型不同可能在内存中所占的位置不同，如果定义错了就可能导致出错。</p>
<h2 id="取地址运算符和取值运算符">取地址运算符和取值运算符</h2>
<p>获取某个变量的地址，使用取地址运算符<code>&amp;</code>，如：</p>
<pre><code class="language-c">char* pa = &amp;a;
int* pb = &amp;f;
</code></pre>
<p>如果反过来，你要访问指针变量指向的数据，那么你就要使用取值运算符<code>*</code>，如：</p>
<pre><code class="language-c">printf(&quot;%c, %d\n&quot;, *pa, *pb);
</code></pre>
<p>这里你可能发现，定义指针的时候也使用了<code>*</code>，这里属于符号的<strong>重用</strong>，也就是说这种符号在不同的地方就有不同的用意：在定义的时候表示<strong>定义一个指针变量</strong>，在其他的时候则用来<strong>获取指针变量指向的变量的值</strong>。</p>
<p>直接通过变量名来访问变量的值称之为<code>直接访问</code>，通过指针这样的形式访问称之为<code>间接访问</code>，因此取值运算符有时候也成为<strong>间接运算符</strong>。</p>
<p>比如：</p>
<pre><code class="language-c">//Example 01
//代码来源于网络，非个人原创
#include &lt;stdio.h&gt;
int main(void)
{
    char a = 'f';
    int f = 123;
    char* pa = &amp;a;
    int* pf = &amp;f;
    
    printf(&quot;a = %c\n&quot;, *pa);
    printf(&quot;f = %d\n&quot;, *pf);
    
    *pa = 'c';
    *pf += 1;
    
    printf(&quot;now, a = %c\n&quot;, *pa);
    printf(&quot;now, f = %d\n&quot;, *pf);
    
    printf(&quot;sizeof pa = %d\n&quot;, sizeof(pa));
    printf(&quot;sizeof pf = %d\n&quot;, sizeof(pf));
    
    printf(&quot;the addr of a is: %p\n&quot;, pa);
    printf(&quot;the addr of f is: %p\n&quot;, pf);
    
    return 0;
}
</code></pre>
<p>程序实现如下：</p>
<pre><code>//Consequence 01
a = f
f = 123
now, a = c
now, f = 124
sizeof pa = 4
sizeof pf = 4
the addr of a is: 00EFF97F
the addr of f is: 00EFF970
</code></pre>
<h2 id="避免访问未初始化的指针">避免访问未初始化的指针</h2>
<pre><code class="language-c">void f()
{
    int* a;
    *a = 10;
}
</code></pre>
<p>像这样的代码是十分危险的。因为指针a到底指向哪里，我们不知道。就和访问未初始化的普通变量一样，会返回一个<strong>随机值</strong>。但是如果是在指针里面，那么就有可能覆盖到<strong>其他的内存区域</strong>，甚至可能是系统正在使用的<strong>关键区域</strong>，十分危险。不过这种情况，系统一般会驳回程序的运行，此时程序会被<strong>中止</strong>并<strong>报错</strong>。要是万一中奖的话，覆盖到一个合法的地址，那么接下来的赋值就会导致一些有用的数据被<strong>莫名其妙地修改</strong>，这样的bug是十分不好排查的，因此使用指针的时候一定要注意初始化。</p>
<h1 id="指针和数组">指针和数组</h1>
<p>有些读者可能会有些奇怪，指针和数组又有什么关系？这俩货明明八竿子打不着井水不犯河水。别着急，接着往下看，你的观点有可能会改变。</p>
<h2 id="数组的地址">数组的地址</h2>
<p>我们刚刚说了，指针实际上就是变量在<strong>内存中的地址</strong>，那么如果有细心的小伙伴就可能会想到，像数组这样的一大摞变量的集合，它的地址是啥呢？</p>
<p>我们知道，从标准输入流中读取一个值到变量中，用的是<code>scanf</code>函数，一般貌似在后面都要加上<code>&amp;</code>，这个其实就是我们刚刚说的<strong>取地址运算符</strong>。如果你存储的位置是指针变量的话，那就不需要。</p>
<pre><code class="language-c">//Example 02
int main(void)
{
    int a;
    int* p = &amp;a;
    
    printf(&quot;请输入一个整数：&quot;);
    scanf(&quot;%d&quot;, &amp;a);//此处需要&amp;
    printf(&quot;a = %d\n&quot;, a);
    
    printf(&quot;请再输入一个整数：&quot;);
    scanf(&quot;%d&quot;, p);//此处不需要&amp;
    printf(&quot;a = %d\n&quot;, a);
    
    return 0;
}
</code></pre>
<p>程序运行如下：</p>
<pre><code>//Consequence 02
请输入一个整数：1
a = 1
请再输入一个整数：2
a = 2
</code></pre>
<p>在普通变量读取的时候，程序需要知道这个变量在内存中的地址，因此需要<code>&amp;</code>来取地址完成这个任务。而对于指针变量来说，本身就是<strong>另外一个</strong>普通变量的<strong>地址信息</strong>，因此直接给出指针的值就可以了。</p>
<p>试想一下，我们在使用<code>scanf</code>函数的时候，是不是也有不需要使用<code>&amp;</code>的时候？就是在读取<strong>字符串</strong>的时候：</p>
<pre><code class="language-c">//Example 03
#include &lt;stdio.h&gt;
int main(void)
{
    char url[100];
    url[99] = '\0';
    printf(&quot;请输入TechZone的域名：&quot;);
    scanf(&quot;%s&quot;, url);//此处也不用&amp;
    printf(&quot;你输入的域名是：%s\n&quot;, url);
    return 0;
}
</code></pre>
<p>程序执行如下：</p>
<pre><code>//Consequence 03
请输入TechZone的域名：www.techzone.ltd
你输入的域名是：www.techzone.ltd
</code></pre>
<p>因此很好推理：数组名其实就是一个<strong>地址信息</strong>，实际上就是数组<strong>第一个元素的地址</strong>。咱们试试把第一个元素的地址和数组的地址做个对比就知道了：</p>
<pre><code class="language-c">//Example 03 V2
#include &lt;stdio.h&gt;
int main(void)
{
    char url[100];
    printf(&quot;请输入TechZone的域名：&quot;);
    url[99] = '\0';
    scanf(&quot;%s&quot;, url);
    printf(&quot;你输入的域名是：%s\n&quot;, url);

    printf(&quot;url的地址为：%p\n&quot;, url);
    printf(&quot;url[0]的地址为：%p\n&quot;, &amp;url[0]);

    if (url == &amp;url[0])
    {
        printf(&quot;两者一致！&quot;);
    }
    else
    {
        printf(&quot;两者不一致！&quot;);
    }
    return 0;
}
</code></pre>
<p>程序运行结果为：</p>
<pre><code>//Comsequense 03 V2
请输入TechZone的域名：www.techzone.ltd
你输入的域名是：www.techzone.ltd
url的地址为：0063F804
url[0]的地址为：0063F804
两者一致！
</code></pre>
<p>这么看，应该是实锤了。那么数组后面的元素也就是依次往后放置，有兴趣的也可以自己写代码尝试把它们输出看看。</p>
<h2 id="指向数组的指针">指向数组的指针</h2>
<p>刚刚我们验证了数组的地址就是数组第一个元素的地址。那么指向数组的指针自然也就有两种定义的方法：</p>
<pre><code class="language-c">...
char* p;
//方法1
p = a;
//方法2
p = &amp;a[0];
</code></pre>
<h2 id="指针的运算">指针的运算</h2>
<p>当指针指向数组元素的时候，可以对指针变量进行<strong>加减</strong>运算，<code>+n</code>表示指向p指针所指向的元素的<strong>下n个元素</strong>，<code>-n</code>表示指向p指针所指向的元素的<strong>上n个元素</strong>。并不是将地址加1。</p>
<p>如：</p>
<pre><code class="language-c">//Example 04
#include &lt;stdio.h&gt;
int main(void)
{
    int a[] = { 1,2,3,4,5 };
    int* p = a;
    printf(&quot;*p = %d, *(p+1) = %d, *(p+2) = %d\n&quot;, *p, *(p + 1), *(p + 2));
    printf(&quot;*p -&gt; %p, *(p+1) -&gt; %p, *(p+2) -&gt; %p\n&quot;, p, p + 1, p + 2);
    return 0;
}
</code></pre>
<p>执行结果如下：</p>
<pre><code>//Consequence 04
*p = 1, *(p+1) = 2, *(p+2) = 3
*p -&gt; 00AFF838, *(p+1) -&gt; 00AFF83C, *(p+2) -&gt; 00AFF840
</code></pre>
<p>有的小伙伴可能会想，编译器是怎么知道访问下一个元素而不是地址直接加1呢？</p>
<p>其实就在我们定义指针变量的时候，就已经告诉编译器了。如果我们定义的是整型数组的指针，那么指针加1，实际上就是加上一个<code>sizeof(int)</code>的距离。相对于标准的下标访问，使用指针来间接访问数组元素的方法叫做<code>指针法</code>。</p>
<p>其实使用指针法来访问数组的元素，不一定需要定义一个指向数组的单独的指针变量，因为数组名自身就是指向数组<strong>第一个元素</strong>的指针，因此指针法可以直接作用于数组名：</p>
<pre><code class="language-c">...
printf(&quot;p -&gt; %p, p+1 -&gt; %p, p+2 -&gt; %p\n&quot;, a, a+1, a+2);
printf(&quot;a = %d, a+1 = %d, a+2 = %d&quot;, *a, *(a+1), *(a+2));
...
</code></pre>
<p>执行结果如下：</p>
<pre><code class="language-c">p -&gt; 00AFF838, p+1 -&gt; 00AFF83C, p+2 -&gt; 00AFF840
b = 1, b+1 = 2, b+2 = 3
</code></pre>
<p>现在你是不是感觉，数组和指针有点像了呢？不过笔者先提醒，数组和指针虽然非常像，但是绝对<strong>不是</strong>       一种东西。</p>
<p>甚至你还可以直接用指针来定义字符串，然后用下标法来读取每一个元素：</p>
<pre><code class="language-c">//Example 05
//代码来源于网络
#include &lt;stdio.h&gt;
#include &lt;string.h&gt;
int main(void)
{
    char* str = &quot;I love TechZone!&quot;;
    int i, length;
    
    length = strlen(str);
    
    for (i = 0; i &lt; length, i++)
    {
        printf(&quot;%c&quot;, str[i]);
    }
    printf(&quot;\n&quot;);
    
    return 0;
}
</code></pre>
<p>程序运行如下：</p>
<pre><code>//Consequence 05
I love TechZone!
</code></pre>
<p>在刚刚的代码里面，我们定义了一个<strong>字符指针</strong>变量，并且初始化成指向一个字符串。后来的操作，不仅在它身上可以使用<strong>字符串处理函数</strong>，还可以用<strong>下标法</strong>访问字符串中的每一个字符。</p>
<p>当然，循环部分这样写也是没毛病的：</p>
<pre><code class="language-c">...
for (i = 0, i &lt; length, i++)
{
    printf(&quot;%c&quot;, *(str + i));
}
</code></pre>
<p>这就相当于利用了指针法来读取。</p>
<h2 id="指针和数组的区别">指针和数组的区别</h2>
<p>刚刚说了许多指针和数组相互替换的例子，可能有的小伙伴又开始说：“这俩货不就是一个东西吗？”</p>
<p>随着你对指针和数组越来越了解，你会发现，C语言的创始人不会这么无聊去创建两种一样的东西，还叫上不同的名字。指针和数组终究是<strong>不一样</strong>的。</p>
<p>比如笔者之前看过的一个例子：</p>
<pre><code class="language-c">//Example 06
//代码来源于网络
#include &lt;stdio.h&gt;
int main(void)
{
    char str[] = &quot;I love TechZone!&quot;;
    int count = 0;
    
    while (*str++ != '\0')
    {
        count++;
    }
    printf(&quot;总共有%d个字符。\n&quot;, count);
    
    return 0;
}
</code></pre>
<p>当编译器报错的时候，你可能会开始怀疑你学了假的C语言语法：</p>
<pre><code>//Error in Example 06
错误(活动)	E0137	表达式必须是可修改的左值
错误	C2105	“++”需要左值
</code></pre>
<p>我们知道，<code>*str++ != ‘\0’</code>是一个复合表达式，那么就要遵循<strong>运算符优先级</strong>来看。具体可以回顾<a href="http://www.techzone.ltd/post/COperatorASCII/">《C语言运算符优先级及ASCII对照表》</a>。</p>
<p><code>str++</code>比<code>*str</code>的优先级<strong>更高</strong>，但是自增运算符要在<strong>下一条语句</strong>的时候才能生效。所以这个语句的理解就是，先取出<code>str</code>所指向的值，判断是否为<code>\0</code>，若是，则跳出循环，然后<code>str</code>指向下一个字符的位置。</p>
<p>看上去貌似没啥毛病，但是，看看编译器告诉我们的东西：<code>表达式必须是可修改的左值</code></p>
<p><code>++</code>的操作对象是<code>str</code>，那么<code>str</code>到底是不是<strong>左值</strong>呢？</p>
<p>如果是左值的话，那么就必须满足左值的条件。</p>
<blockquote>
<ol>
<li>拥有用于识别和定位一个存储位置的标识符</li>
<li>存储值可修改</li>
</ol>
</blockquote>
<p>第一点，数组名<code>str</code>是可以满足的，因为数组名实际上就是定位数组第一个元素的位置。但是第二点就不满足了，数组名实际上是一个地址，地址是<strong>不可以</strong>修改的，它是一个常量。如果非要利用上面的思路来实现的话，可以将代码改成这样：</p>
<pre><code class="language-c">//Example 06 V2
//代码来源于网络
#include &lt;stdio.h&gt;
int main(void)
{
    char str[] = &quot;I love TechZone!&quot;;
    char* target = str;
    int count = 0;
    
    while (*target++ != '\0')
    {
        count++;
    }
    printf(&quot;总共有%d个字符。\n&quot;, count);
    
    return 0;
}
</code></pre>
<p>这样就可以正常执行了：</p>
<pre><code>//Consequence 06 V2
总共有16个字符。
</code></pre>
<p>这样我们就可以得出：数组名只是一个<strong>地址</strong>，而指针是一个<strong>左值</strong>。</p>
<h2 id="指针数组数组指针">指针数组？数组指针？</h2>
<p>看下面的例子，你能分辨出哪个是指针数组，哪个是数组指针吗？</p>
<pre><code class="language-c">int* p1[5];
int(*p2)[5];
</code></pre>
<p>单个的我们都可以判断，但是组合起来就有些难度了。</p>
<p>答案：</p>
<pre><code class="language-c">int* p1[5];//指针数组
int(*p2)[5];//数组指针
</code></pre>
<p>我们挨个来分析。</p>
<h3 id="指针数组">指针数组</h3>
<p>数组下标<code>[]</code>的优先级是最高的，因此<code>p1</code>是一个有5个元素的<strong>数组</strong>。那么这个数组的类型是什么呢？答案就是<code>int*</code>，是<strong>指向整型变量的指针</strong>。因此这是一个<strong>指针数组</strong>。</p>
<p>那么这样的数组应该怎么样去初始化呢？</p>
<p>你可以定义5个变量，然后挨个取地址来初始化。</p>
<p>不过这样太繁琐了，但是，并不是说指针数组就没什么用。</p>
<p>比如：</p>
<pre><code class="language-c">//Example 07
#include &lt;stdio.h&gt;
int main(void)
{
    char* p1[5] = {
        &quot;人生苦短，我用Python。&quot;,
        &quot;PHP是世界上最好的语言！&quot;,
        &quot;One more thing...&quot;,
        &quot;一个好的程序员应该是那种过单行线都要往两边看的人。&quot;,
        &quot;C语言很容易让你犯错误；C++看起来好一些，但当你用它时，你会发现会死的更惨。&quot;
    };
    int i;
    for (i = 0; i &lt; 5; i++)
    {
        printf(&quot;%s\n&quot;, p1[i]);
    }
    return 0;
}
</code></pre>
<p>结果如下：</p>
<pre><code>//Consequence 07
人生苦短，我用Python。
PHP是世界上最好的语言！
One more thing...
一个好的程序员应该是那种过单行线都要往两边看的人。
C语言很容易让你犯错误；C++看起来好一些，但当你用它时，你会发现会死的更惨。
</code></pre>
<p>这样是不是比二维数组来的更加直接更加通俗呢？</p>
<h3 id="数组指针">数组指针</h3>
<p><code>()</code>和<code>[]</code>在优先级里面属于<strong>同级</strong>，那么就按照<strong>先后顺序</strong>进行。</p>
<p><code>int(*p2)</code>将<code>p2</code>定义为<strong>指针</strong>， 后面跟随着一个5个元素的<strong>数组</strong>，<code>p2</code>就指向这个数组。因此，数组指针是一个<strong>指针</strong>，它指向的是一个数组。</p>
<p>但是，如果想对数组指针初始化的时候，千万要小心，比如：</p>
<pre><code class="language-c">//Example 08
#include &lt;stdio.h&gt;
int main(void)
{
    int(*p2)[5] = {1, 2, 3, 4, 5};
    int i;
    for (i = 0; i &lt; 5; i++)
    {
        printf(&quot;%d\n&quot;, *(p2 + i));
    }
    return 0;
}
</code></pre>
<p>Visual Studio 2019报出以下的错误：</p>
<pre><code>//Error and Warning in Example 08
错误(活动)	E0146	初始值设定项值太多
错误	C2440	“初始化”: 无法从“initializer list”转换为“int (*)[5]”
警告	C4477	“printf”: 格式字符串“%d”需要类型“int”的参数，但可变参数 1 拥有了类型“int *”
</code></pre>
<p>这其实是一个非常典型的错误使用指针的案例，编译器提示说这里有一个<strong>整数</strong>赋值给<strong>指针变量</strong>的问题，因为<code>p2</code>归根结底还是指针，所以应该给它传递一个<strong>地址</strong>才行，更改一下：</p>
<pre><code class="language-c">//Example 08 V2
#include &lt;stdio.h&gt;
int main(void)
{
    int temp[5] = {1, 2, 3, 4, 5};
    int(*p2)[5] = temp;
    int i;
    for (i = 0; i &lt; 5; i++)
    {
        printf(&quot;%d\n&quot;, *(p2 + i));
    }
    return 0;
}
</code></pre>
<pre><code>//Error and Warning in Example 08 V2
错误(活动)	E0144	&quot;int *&quot; 类型的值不能用于初始化 &quot;int (*)[5]&quot; 类型的实体
错误	C2440	“初始化”: 无法从“int [5]”转换为“int (*)[5]”
警告	C4477	“printf”: 格式字符串“%d”需要类型“int”的参数，但可变参数 1 拥有了类型“int *”
</code></pre>
<p>可是怎么还是有问题呢？</p>
<p>我们回顾一下，指针是如何指向数组的。</p>
<pre><code class="language-c">int temp[5] = {1, 2, 3, 4, 5};
int* p = temp;
</code></pre>
<p>我们原本以为，指针<code>p</code>是指向数组的指针，但是实际上<strong>并不是</strong>。仔细想想就会发现，这个指针实际上是指向的数组的<strong>第一个元素</strong>，而不是指向数组。因为数组里面的元素在内存中都是挨着个儿存放的，因此只需要知道第一个元素的地址，就可以访问到后面的所有元素。</p>
<p>但是，这么来看的话，指针<code>p</code>指向的就是一个<strong>整型变量</strong>的指针，并不是指向<strong>数组</strong>的指针。而刚刚我们用的数组指针，才是指向数组的指针。因此，应该将<strong>数组的地址</strong>传递给数组指针，而不是将第一个元素的地址传入，尽管它们值相同，但是<strong>含义</strong>确实不一样：</p>
<pre><code class="language-c">//Example 08 V3
//Example 08 V2
#include &lt;stdio.h&gt;
int main(void)
{
    int temp[5] = {1, 2, 3, 4, 5};
    int(*p2)[5] = &amp;temp;//此处取地址
    int i;
    for (i = 0; i &lt; 5; i++)
    {
        printf(&quot;%d\n&quot;, *(*p2 + i));
    }
    return 0;
}
</code></pre>
<p>程序运行如下：</p>
<pre><code>//Consequence 08
1
2
3
4
5
</code></pre>
<h2 id="指针和二维数组">指针和二维数组</h2>
<p>在上一节<a href="http://www.techzone.ltd/post/CArray/">《C语言之数组》</a>我们讲过<strong>二维数组</strong>的概念，并且我们也知道，C语言的二维数组其实在内存中也是<strong>线性存放</strong>的。</p>
<p>假设我们定义了：<code>int array[4][5]</code></p>
<h3 id="array">array</h3>
<p>array作为数组的名称，显然应该表示的是数组的<strong>首地址</strong>。由于二维数组实际上就是一维数组的<strong>线性拓展</strong>，因此array应该就是指的<code>指向包含5个元素的数组的指针</code>。</p>
<p>如果你用<code>sizeof()</code>去测试<code>array</code>和<code>array+1</code>的话，就可以测试出来这样的结论。</p>
<h3 id="array1">*(array+1)</h3>
<p>首先从刚刚的问题我们可以得出，<code>array+1</code>同样也是指的<code>指向包含5个元素的数组的指针</code>，因此<code>*(array+1)</code>就是相当于<code>array[1]</code>，而这刚好相当于<code>array[1][0]</code>的数组名。因此<code>*(array+1)</code>就是指第二行子数组的第一个元素的地址。</p>
<h3 id="array12">*(*(array+1)+2)</h3>
<p>有了刚刚的结论，我们就不难推理出，这个实际上就是<code>array[1][2]</code>。是不是感觉非常简单呢？</p>
<p>总结一下，就是下面的这些结论，记住就好，理解那当然更好：</p>
<pre><code class="language-c">*(array + i) == array[i]
*(*(array + i) + j) == array[i][j]
*(*(*(array + i) + j) + k) == array[i][j][k]
...
</code></pre>
<h2 id="数组指针和二维数组">数组指针和二维数组</h2>
<p>我们在上一节里面讲过，在初始化二维数组的时候是可以偷懒的：</p>
<pre><code class="language-C">int array[][3] = {
    {1, 2, 3},
    {4, 5, 6}
};
</code></pre>
<p>刚刚我们又说过，定义一个数组指针是这样的：</p>
<pre><code class="language-c">int(*p)[3];
</code></pre>
<p>那么组合起来是什么意思呢？</p>
<pre><code class="language-c">int(*p)[3] = array;
</code></pre>
<p>通过刚刚的说明，我们可以知道，<code>array</code>是指向一个3个元素的数组的<strong>指针</strong>，所以这里完全可以将<code>array</code>的值赋值给<code>p</code>。</p>
<p>其实C语言的指针非常灵活，同样的代码用不同的角度去解读，就可以有不同的应用。</p>
<p>那么如何使用指针来访问二维数组呢？没错，就是使用<strong>数组指针</strong>：</p>
<pre><code class="language-c">//Example 09
#include &lt;stdio.h&gt;
int main(void)
{
    int array[3][4] = {
        {0, 1, 2, 3},
        {4, 5, 6, 7},
        {8, 9, 10, 11}
    };
    int(*p)[4];
    int i, j;
    p = array;
    for (i = 0, i &lt; 3, i++)
    {
        for (j = 0, j &lt; 4, j++)
        {
            printf(&quot;%2d &quot;, *(*(p+i) + j)); 
        }
        printf(&quot;\n&quot;);
    }
    return 0;
}
</code></pre>
<p>运行结果：</p>
<pre><code>//Consequence 09
0 1 2 3 
4 5 6 7 
8 9 10 11 
</code></pre>
<h1 id="void指针">void指针</h1>
<p><code>void</code>实际上是<code>无类型</code>的意思。如果你尝试用它来定义一个变量，编译器肯定会<strong>报错</strong>，因为不同类型所占用的内存有可能<strong>不一样</strong>。但是如果定义的是一个指针，那就没问题。<code>void</code>类型中指针可以指向<strong>任何一个类型</strong>的数据，也就是说，任何类型的指针都可以赋值给<code>void</code>指针。</p>
<p>将任何类型的指针转换为<code>void</code>是没有问题的。但是如果你要反过来，那就需要<strong>强制类型转换</strong>。此外，不要对<code>void</code>指针<strong>直接解引用</strong>，因为编译器其实并不知道<code>void</code>指针会存放什么样的类型。</p>
<pre><code class="language-c">//Example 10
#include &lt;stdio.h&gt;
int main(void)
{
    int num = 1024;
    int* pi = &amp;num;
    char* ps = &quot;TechZone&quot;;
    void* pv;
    
    pv = pi;
    printf(&quot;pi:%p,pv:%p\n&quot;, pi, pv);
    printf(&quot;*pv:%d\n&quot;, *pv);
    
    pv = ps;
    printf(&quot;ps:%p,pv:%p\n&quot;, ps, pv);
    printf(&quot;*pv:%s\n&quot;, *pv);
}
</code></pre>
<p>这样会报错：</p>
<pre><code>//Error in Example 10
错误	C2100	非法的间接寻址
错误	C2100	非法的间接寻址
</code></pre>
<p>如果一定要这么做，那么可以用<strong>强制类型转换</strong>：</p>
<pre><code class="language-c">//Example 10 V2
#include &lt;stdio.h&gt;
int main(void)
{
    int num = 1024;
    int* pi = &amp;num;
    char* ps = &quot;TechZone&quot;;
    void* pv;

    pv = pi;
    printf(&quot;pi:%p,pv:%p\n&quot;, pi, pv);
    printf(&quot;*pv:%d\n&quot;, *(int*)pv);

    pv = ps;
    printf(&quot;ps:%p,pv:%p\n&quot;, ps, pv);
    printf(&quot;*pv:%s\n&quot;, pv);
}
</code></pre>
<p>当然，使用void指针一定要小心，由于void指针几乎可以<strong>通吃</strong>所有类型，所以间接使得不同类型的指针转换变得合法，如果代码中存在不合理的转换，编译器也不会报错。</p>
<p>因此，void指针能不用则不用，后面讲函数的时候，还可以解锁更多新的玩法。</p>
<h1 id="null指针">NULL指针</h1>
<p>在C语言中，如果一个指针不指向任何数据，那么就称之为<strong>空指针</strong>，用<strong>NULL</strong>来表示。NULL其实是一个宏定义：</p>
<pre><code class="language-c">#define NULL ((void *)0)
</code></pre>
<p>在大部分的操作系统中，地址0通常是一个<strong>不被使用</strong>的地址，所以如果一个指针指向NULL，就意味着不指向任何东西。为什么一个指针要指向NULL呢？</p>
<p>其实这反而是一种比较指的推荐的<strong>编程风格</strong>——当你暂时还不知道该指向哪儿的时候，就让它指向NULL，以后不会有太多的麻烦，比如：</p>
<pre><code class="language-c">//Example 11
#include &lt;stdio.h&gt;
int main(void)
{
    int* p1;
    int* p2 = NULL;
    printf(&quot;%d\n&quot;, *p1);
    printf(&quot;%d\n&quot;, *p2);
    return 0;
}
</code></pre>
<p>第一个指针未被初始化。在有的编译器里面，这样未初始化的变量就会被赋予<strong>随机值</strong>。这样指针被称为<strong>迷途指针</strong>，<strong>野指针</strong>或者<strong>悬空指针</strong>。如果后面的代码对这类指针解引用，而这个地址又刚好是合法的话，那么就会产生莫名其妙的结果，甚至导致程序的崩溃。因此养成良好的习惯，在暂时不清楚的情况下使用NULL，可以节省大量的后期调试的时间。</p>
<h1 id="指向指针的指针">指向指针的指针</h1>
<p>开始套娃了。其实只要你理解了指针的概念，也就没什么大不了的。</p>
<pre><code class="language-c">//Example 12
#include &lt;stdio.h&gt;
int main(void)
{
    int num = 1;
    int* p = &amp;num;
    int** pp = &amp;p;
    
    printf(&quot;num: %d\n&quot;, num);
    printf(&quot;*p: %d\n&quot;, *p);
    printf(&quot;**p: %d\n&quot;, **pp);
    printf(&quot;&amp;p: %p, pp: %p\n&quot;, &amp;p, pp);
    printf(&quot;&amp;num: %p, p: %p, *pp: %p\n&quot;, &amp;num, p, *pp);
    return 0;
}
</code></pre>
<p>程序结果如下：</p>
<pre><code>//Consequence 12
num: 1
*p: 1
**p: 1
&amp;p: 004FF960, pp: 004FF960
&amp;num: 004FF96C, p: 004FF96C, *pp: 004FF96C
</code></pre>
<p>当然你也可以无限地套娃，一直指下去。不过这样会让代码可读性变得<strong>很差</strong>，过段时间可能你自己都看不懂你写的代码了。</p>
<h1 id="指针数组和指向指针的指针">指针数组和指向指针的指针</h1>
<p>那么，指向指针的指针有什么用呢？</p>
<p>它可不是为了去创造混乱代码，在一个经典的实例里面，就可以体会到它的用处：</p>
<pre><code class="language-c">char* Books[] = {
    &quot;《C专家编程》&quot;,
    &quot;《C和指针》&quot;,
    &quot;《C的陷阱与缺陷》&quot;,
    &quot;《C Primer Plus》&quot;,
    &quot;《Python基础教程（第三版）》&quot;
};
</code></pre>
<p>然后我们需要将这些书进行分类。我们发现，其中有一本是写Python的，其他都是C语言的。这时候指向指针的指针就派上用场了。首先，我们刚刚定义了一个指针数组，也就是说，里面的所有元素的类型<strong>都是指针</strong>，而数组名却又可以用指针的形式来<strong>访问</strong>，因此就可以使用<strong>指向指针的指针</strong>来指向指针数组：</p>
<pre><code class="language-c">...
char** Python;
char** CLang[4];

Python = &amp;Books[5];
CLang[0] = &amp;Books[0];
CLang[1] = &amp;Books[1];
CLang[2] = &amp;Books[2];
CLang[3] = &amp;Books[3];
...
</code></pre>
<p>因为字符串的取地址值实际上就是其<strong>首地址</strong>，也就是一个<strong>指向字符指针的指针</strong>，所以可以这样赋值。</p>
<p>这样，我们就利用指向指针的指针完成了对书籍的分类，这样既避免了浪费多余的内存，而且当其中的书名要修改，只需要改一次即可，代码的灵活性和安全性都得到了提升。</p>
<h1 id="常量和指针">常量和指针</h1>
<p>常量，在我们目前的认知里面，应该是这样的：</p>
<pre><code>520, 'a'
</code></pre>
<p>或者是这样的：</p>
<pre><code class="language-c">#define MAX 1000
#define B 'b'
</code></pre>
<p>常量和变量最大的区别，就是前者<strong>不能够被修改</strong>，后者可以。那么在C语言中，可以将变量变成像具有常量一样的特性，利用<code>const</code>即可。</p>
<pre><code class="language-c">const int max = 1000;
const char a = 'a';
</code></pre>
<p>在<code>const</code>关键字的作用下，变量就会<strong>失去</strong>本来具有的可修改的特性，变成“只读”的属性。</p>
<h1 id="指向常量的指针">指向常量的指针</h1>
<p>强大的指针当然也是可以指向被<code>const</code>修饰过的变量，但这就意味着<strong>不能通过</strong>指针来修改它所引用的值。总结一下，就是以下4点：</p>
<blockquote>
<ol>
<li>指针可以修改为指向不同的变量</li>
<li>指针可以修改为指向不同的常量</li>
<li>可以通过解引用来读取指针指向的数据</li>
<li>不可以通过解引用来修改指针指向的数据</li>
</ol>
</blockquote>
<h1 id="常量指针">常量指针</h1>
<h2 id="指向非常量的常量指针">指向非常量的常量指针</h2>
<p>指针本身作为一种<strong>变量</strong>，也是可以修改的。因此，指针也是可以被<code>const</code>修饰的，只不过位置稍稍<strong>发生了点变化</strong>：</p>
<pre><code class="language-c">...
int* const p = &amp;num;
...
</code></pre>
<p>这样的指针有如下的特性：</p>
<blockquote>
<ol>
<li>指针自身不能够被修改</li>
<li>指针指向的值可以被修改</li>
</ol>
</blockquote>
<h2 id="指向常量的常量指针">指向常量的常量指针</h2>
<p>在定义普通变量的时候也用<code>const</code>修饰，就得到了这样的指针。不过由于限制太多，一般很少用到：</p>
<pre><code class="language-c">...
int num = 100;
const int cnum = 200;
const int* const p = &amp;cnum;
...
</code></pre>
<hr>
<p>这期博客就到此结束了，没学会的反复咀嚼，学会了的自己去实战，相信你的C语言编程能力会越来越强。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[积分变限函数的求导方法]]></title>
        <id>https://harriswilde.github.io/post/P-CkgTjqZ</id>
        <link href="https://harriswilde.github.io/post/P-CkgTjqZ">
        </link>
        <updated>2020-01-01T14:24:10.000Z</updated>
        <content type="html"><![CDATA[<p>所谓<strong>积分变限函数</strong>，就是<s>能够将你所学知识变现的函数</s> 在积分的上下限中加入了一个函数。由于函数的值在自变量不同的时候也不同，因此这个上下限也是不定的，故曰此名。</p>
<p>那么，这样的积分函数是不是就没法求了呢？就这么点难度怎么可能难得住咱们勤劳有智慧的人们呢？下面就来看看，这种阴险狡诈的积分函数到底怎么求。</p>
<hr>
<p>积分变限函数一般分为3种：<strong>仅上限为函数</strong>、<strong>仅下限为函数</strong>和<strong>上下限都为函数</strong>。</p>
<p>我们挨个来看看。</p>
<h1 id="仅上限为函数">仅上限为函数</h1>
<p>这种情况下，只需要把上限函数带入到被积函数里面去即可。如：</p>
<p class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>y</mi><mo>=</mo><msubsup><mo>∫</mo><mi>a</mi><mrow><mi>f</mi><mo>(</mo><mi>x</mi><mo>)</mo></mrow></msubsup><mi>g</mi><mo>(</mo><mi>t</mi><mo>)</mo><mtext> </mtext><mi mathvariant="normal">d</mi><mi>t</mi><mo>⇒</mo><msup><mi>y</mi><mo mathvariant="normal">′</mo></msup><mo>=</mo><mi>g</mi><mo fence="false">(</mo><mi>f</mi><mo>(</mo><mi>x</mi><mo>)</mo><mo fence="false">)</mo><mtext> </mtext><mi mathvariant="normal">d</mi><msup><mi>f</mi><mo mathvariant="normal">′</mo></msup><mo>(</mo><mi>x</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">y=\int_{a}^{f(x)} g(t)\,{\rm d}t\Rightarrow y^\prime=g\big(f(x)\big)\,{\rm d}f^\prime(x)
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">y</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:2.54985em;vertical-align:-0.9119499999999999em;"></span><span class="mop"><span class="mop op-symbol large-op" style="margin-right:0.44445em;position:relative;top:-0.0011249999999999316em;">∫</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.6379000000000001em;"><span style="top:-1.7880500000000001em;margin-left:-0.44445em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">a</span></span></span></span><span style="top:-3.8129em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.10764em;">f</span><span class="mopen mtight">(</span><span class="mord mathdefault mtight">x</span><span class="mclose mtight">)</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.9119499999999999em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="mopen">(</span><span class="mord mathdefault">t</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord"><span class="mord mathrm">d</span></span></span><span class="mord mathdefault">t</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">⇒</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.996332em;vertical-align:-0.19444em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03588em;">y</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.801892em;"><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">′</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1.20001em;vertical-align:-0.35001em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="mord"><span class="delimsizing size1">(</span></span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mopen">(</span><span class="mord mathdefault">x</span><span class="mclose">)</span><span class="mord"><span class="delimsizing size1">)</span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord"><span class="mord mathrm">d</span></span></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.801892em;"><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">′</span></span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord mathdefault">x</span><span class="mclose">)</span></span></span></span></span></p>
<p>比如像下面这个函数，咱们来试试：</p>
<p class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mtable><mtr><mtd><mstyle scriptlevel="0" displaystyle="true"><mi>y</mi></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="true"><mrow><mrow></mrow><mo>=</mo><msubsup><mo>∫</mo><mn>1</mn><msup><mi>x</mi><mn>2</mn></msup></msubsup><msup><mi>e</mi><msup><mi>t</mi><mn>2</mn></msup></msup><mi mathvariant="normal">d</mi><mi>t</mi></mrow></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="true"><mrow><mo>⇒</mo><msup><mi>y</mi><mo mathvariant="normal">′</mo></msup></mrow></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="true"><mrow><mrow></mrow><mo>=</mo><msup><mi>e</mi><mrow><mo>(</mo><msup><mi>x</mi><mn>2</mn></msup><msup><mo>)</mo><mn>2</mn></msup></mrow></msup><mi mathvariant="normal">d</mi><msup><mi>x</mi><mn>2</mn></msup><mo>=</mo><mn>2</mn><mi>x</mi><mo>⋅</mo><msup><mi>e</mi><msup><mi>x</mi><mn>4</mn></msup></msup></mrow></mstyle></mtd></mtr></mtable><annotation encoding="application/x-tex">\begin{aligned}
y&amp;=\int^{x^2}_1 e^{t^2}{\rm d}t\\
\Rightarrow y^\prime&amp;=e^{(x^2)^2}{\rm d}x^2=2x\cdot e^{x^4}
\end{aligned}
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:4.64569em;vertical-align:-2.072845em;"></span><span class="mord"><span class="mtable"><span class="col-align-r"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:2.572845em;"><span style="top:-4.572845em;"><span class="pstrut" style="height:3.7368200000000003em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03588em;">y</span></span></span><span style="top:-2.3239750000000003em;"><span class="pstrut" style="height:3.7368200000000003em;"></span><span class="mord"><span class="mrel">⇒</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03588em;">y</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.801892em;"><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">′</span></span></span></span></span></span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:2.072845em;"><span></span></span></span></span></span><span class="col-align-l"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:2.572845em;"><span style="top:-4.572845em;"><span class="pstrut" style="height:3.7368200000000003em;"></span><span class="mord"><span class="mord"></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mop"><span class="mop op-symbol large-op" style="margin-right:0.44445em;position:relative;top:-0.0011249999999999316em;">∫</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.7368200000000003em;"><span style="top:-1.7880500000000001em;margin-left:-0.44445em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span><span style="top:-3.8129000000000004em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight"><span class="mord mathdefault mtight">x</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8913142857142857em;"><span style="top:-2.931em;margin-right:0.07142857142857144em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.9119499999999999em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault">e</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:1.0369199999999998em;"><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight"><span class="mord mathdefault mtight">t</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8913142857142857em;"><span style="top:-2.931em;margin-right:0.07142857142857144em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span><span class="mord"><span class="mord"><span class="mord mathrm">d</span></span></span><span class="mord mathdefault">t</span></span></span><span style="top:-2.3239750000000003em;"><span class="pstrut" style="height:3.7368200000000003em;"></span><span class="mord"><span class="mord"></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mord"><span class="mord mathdefault">e</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:1.0369199999999998em;"><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mopen mtight">(</span><span class="mord mtight"><span class="mord mathdefault mtight">x</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8913142857142857em;"><span style="top:-2.931em;margin-right:0.07142857142857144em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mclose mtight"><span class="mclose mtight">)</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8913142857142857em;"><span style="top:-2.931em;margin-right:0.07142857142857144em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span><span class="mord"><span class="mord"><span class="mord mathrm">d</span></span></span><span class="mord"><span class="mord mathdefault">x</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8641079999999999em;"><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mord">2</span><span class="mord mathdefault">x</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">⋅</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord"><span class="mord mathdefault">e</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:1.0369199999999998em;"><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight"><span class="mord mathdefault mtight">x</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8913142857142857em;"><span style="top:-2.931em;margin-right:0.07142857142857144em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight">4</span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:2.072845em;"><span></span></span></span></span></span></span></span></span></span></span></span></p>
<h1 id="仅下限为函数">仅下限为函数</h1>
<p>这种情况我们就需要通过添加负号来转换成刚刚我们学的形式，再使用刚刚的方法来解决就可以了。</p>
<p class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>y</mi><mo>=</mo><msubsup><mo>∫</mo><mrow><mi>f</mi><mo>(</mo><mi>x</mi><mo>)</mo></mrow><mi>a</mi></msubsup><mi>g</mi><mo>(</mo><mi>t</mi><mo>)</mo><mtext> </mtext><mi mathvariant="normal">d</mi><mi>t</mi><mo>⇒</mo><mi>y</mi><mo>=</mo><mo>−</mo><msubsup><mo>∫</mo><mi>a</mi><mrow><mi>f</mi><mo>(</mo><mi>x</mi><mo>)</mo></mrow></msubsup><mi>g</mi><mo>(</mo><mi>t</mi><mo>)</mo><mtext> </mtext><mi mathvariant="normal">d</mi><mi>t</mi></mrow><annotation encoding="application/x-tex">y=\int^a_{f(x)}g(t)\,{\rm d}t\Rightarrow y=-\int^{f(x)}_a g(t)\,{\rm d}t
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">y</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:2.501242em;vertical-align:-1.0869499999999999em;"></span><span class="mop"><span class="mop op-symbol large-op" style="margin-right:0.44445em;position:relative;top:-0.0011249999999999316em;">∫</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.414292em;"><span style="top:-1.7880500000000004em;margin-left:-0.44445em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.10764em;">f</span><span class="mopen mtight">(</span><span class="mord mathdefault mtight">x</span><span class="mclose mtight">)</span></span></span></span><span style="top:-3.8129000000000004em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">a</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.0869499999999999em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="mopen">(</span><span class="mord mathdefault">t</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord"><span class="mord mathrm">d</span></span></span><span class="mord mathdefault">t</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">⇒</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">y</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:2.54985em;vertical-align:-0.9119499999999999em;"></span><span class="mord">−</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mop"><span class="mop op-symbol large-op" style="margin-right:0.44445em;position:relative;top:-0.0011249999999999316em;">∫</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.6379000000000001em;"><span style="top:-1.7880500000000001em;margin-left:-0.44445em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">a</span></span></span><span style="top:-3.8129em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.10764em;">f</span><span class="mopen mtight">(</span><span class="mord mathdefault mtight">x</span><span class="mclose mtight">)</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.9119499999999999em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="mopen">(</span><span class="mord mathdefault">t</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord"><span class="mord mathrm">d</span></span></span><span class="mord mathdefault">t</span></span></span></span></span></p>
<p>然后就可以用我们刚刚介绍的方法来进行计算啦：</p>
<p class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><msup><mi>y</mi><mo mathvariant="normal">′</mo></msup><mo>=</mo><mo>−</mo><mi>g</mi><mo fence="false">(</mo><mi>f</mi><mo>(</mo><mi>x</mi><mo>)</mo><mo fence="false">)</mo><mo>⋅</mo><msup><mi>f</mi><mo mathvariant="normal">′</mo></msup><mo>(</mo><mi>x</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">y^{\prime}=-g\big(f(x)\big)\cdot f^\prime(x)
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.996332em;vertical-align:-0.19444em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03588em;">y</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.801892em;"><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">′</span></span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1.20001em;vertical-align:-0.35001em;"></span><span class="mord">−</span><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="mord"><span class="delimsizing size1">(</span></span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mopen">(</span><span class="mord mathdefault">x</span><span class="mclose">)</span><span class="mord"><span class="delimsizing size1">)</span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">⋅</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1.051892em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.801892em;"><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">′</span></span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord mathdefault">x</span><span class="mclose">)</span></span></span></span></span></p>
<p>举个栗子：</p>
<p class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mtable><mtr><mtd><mstyle scriptlevel="0" displaystyle="true"><mi>y</mi></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="true"><mrow><mrow></mrow><mo>=</mo><msubsup><mo>∫</mo><mi>x</mi><mn>0</mn></msubsup><msup><mi>e</mi><mi>t</mi></msup><mi>cos</mi><mo>⁡</mo><mn>3</mn><mi>t</mi><mtext> </mtext><mi mathvariant="normal">d</mi><mi>t</mi></mrow></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="true"><mrow><mo>⟹</mo><mi>y</mi></mrow></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="true"><mrow><mrow></mrow><mo>=</mo><mo>−</mo><msubsup><mo>∫</mo><mn>0</mn><mi>x</mi></msubsup><msup><mi>e</mi><mi>t</mi></msup><mi>cos</mi><mo>⁡</mo><mn>3</mn><mi>t</mi><mtext> </mtext><mi mathvariant="normal">d</mi><mi>t</mi></mrow></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="true"><mrow><mo>⟹</mo><msup><mi>y</mi><mo mathvariant="normal">′</mo></msup></mrow></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="true"><mrow><mrow></mrow><mo>=</mo><mo>−</mo><msup><mi>e</mi><mi>x</mi></msup><mi>cos</mi><mo>⁡</mo><mn>3</mn><mi>x</mi><mtext> </mtext><mi mathvariant="normal">d</mi><mi>x</mi></mrow></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="true"><mrow></mrow></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="true"><mrow><mrow></mrow><mo>=</mo><mo>−</mo><msup><mi>e</mi><mi>x</mi></msup><mi>cos</mi><mo>⁡</mo><mn>3</mn><mi>x</mi></mrow></mstyle></mtd></mtr></mtable><annotation encoding="application/x-tex">\begin{aligned}
 y&amp;=\int^0_x e^t\cos 3t\,{\rm d}t\\
\Longrightarrow y&amp;=-\int^x_0 e^t\cos 3t\,{\rm d}t\\
\Longrightarrow y^\prime &amp; =-e^x\cos 3x\,{\rm d}x\\
&amp;=-e^x\cos 3x\\
\end{aligned}
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:8.4022em;vertical-align:-3.9510999999999994em;"></span><span class="mord"><span class="mtable"><span class="col-align-r"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:4.4511em;"><span style="top:-6.4511em;"><span class="pstrut" style="height:3.5640080000000003em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03588em;">y</span></span></span><span style="top:-3.824858em;"><span class="pstrut" style="height:3.5640080000000003em;"></span><span class="mord"><span class="mrel">⟹</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">y</span></span></span><span style="top:-1.7729080000000006em;"><span class="pstrut" style="height:3.5640080000000003em;"></span><span class="mord"><span class="mrel">⟹</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03588em;">y</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.801892em;"><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">′</span></span></span></span></span></span></span></span></span></span><span style="top:-0.27290800000000104em;"><span class="pstrut" style="height:3.5640080000000003em;"></span><span class="mord"></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:3.9510999999999994em;"><span></span></span></span></span></span><span class="col-align-l"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:4.4511em;"><span style="top:-6.4511em;"><span class="pstrut" style="height:3.5640080000000003em;"></span><span class="mord"><span class="mord"></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mop"><span class="mop op-symbol large-op" style="margin-right:0.44445em;position:relative;top:-0.0011249999999999316em;">∫</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.5640080000000003em;"><span style="top:-1.7880500000000001em;margin-left:-0.44445em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">x</span></span></span><span style="top:-3.812900000000001em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.9119499999999999em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault">e</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.843556em;"><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">t</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mop">cos</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">3</span><span class="mord mathdefault">t</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord"><span class="mord mathrm">d</span></span></span><span class="mord mathdefault">t</span></span></span><span style="top:-3.824858em;"><span class="pstrut" style="height:3.5640080000000003em;"></span><span class="mord"><span class="mord"></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mord">−</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mop"><span class="mop op-symbol large-op" style="margin-right:0.44445em;position:relative;top:-0.0011249999999999316em;">∫</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.414292em;"><span style="top:-1.7880500000000001em;margin-left:-0.44445em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">0</span></span></span><span style="top:-3.8129000000000004em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">x</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.9119499999999999em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault">e</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.843556em;"><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">t</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mop">cos</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">3</span><span class="mord mathdefault">t</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord"><span class="mord mathrm">d</span></span></span><span class="mord mathdefault">t</span></span></span><span style="top:-1.7729080000000006em;"><span class="pstrut" style="height:3.5640080000000003em;"></span><span class="mord"><span class="mord"></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mord">−</span><span class="mord"><span class="mord mathdefault">e</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.7143919999999999em;"><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">x</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mop">cos</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">3</span><span class="mord mathdefault">x</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord"><span class="mord mathrm">d</span></span></span><span class="mord mathdefault">x</span></span></span><span style="top:-0.27290800000000104em;"><span class="pstrut" style="height:3.5640080000000003em;"></span><span class="mord"><span class="mord"></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mord">−</span><span class="mord"><span class="mord mathdefault">e</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.7143919999999999em;"><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">x</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mop">cos</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">3</span><span class="mord mathdefault">x</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:3.9510999999999994em;"><span></span></span></span></span></span></span></span></span></span></span></span></p>
<h1 id="上下限均为函数">上下限均为函数</h1>
<p>这种情况，需要将其分为两个积分来求导，像下面这样：</p>
<p class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mtable><mtr><mtd><mstyle scriptlevel="0" displaystyle="true"><mrow></mrow></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="true"><mrow><mrow></mrow><mi>y</mi><mo>=</mo><msubsup><mo>∫</mo><mrow><mi>h</mi><mo>(</mo><mi>x</mi><mo>)</mo></mrow><mrow><mi>g</mi><mo>(</mo><mi>x</mi><mo>)</mo></mrow></msubsup><mi>f</mi><mo>(</mo><mi>t</mi><mo>)</mo><mtext> </mtext><mi mathvariant="normal">d</mi><mi>t</mi></mrow></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="true"><mo>⟹</mo></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="true"><mrow><mrow></mrow><mi>y</mi><mo>=</mo><msubsup><mo>∫</mo><mn>0</mn><mrow><mi>g</mi><mo>(</mo><mi>x</mi><mo>)</mo></mrow></msubsup><mi>f</mi><mo>(</mo><mi>t</mi><mo>)</mo><mtext> </mtext><mi mathvariant="normal">d</mi><mi>t</mi><mo>+</mo><msubsup><mo>∫</mo><mrow><mi>h</mi><mo>(</mo><mi>x</mi><mo>)</mo></mrow><mn>0</mn></msubsup><mi>f</mi><mo>(</mo><mi>t</mi><mo>)</mo><mtext> </mtext><mi mathvariant="normal">d</mi><mi>t</mi></mrow></mstyle></mtd></mtr></mtable><annotation encoding="application/x-tex">\begin{aligned}
&amp; y=\int^{g(x)}_{h(x)}f(t)\,{\rm d}t \\
\Longrightarrow &amp; y=\int^{g(x)}_0f(t)\,{\rm d}t +\int^0_{h(x)}f(t)\,{\rm d}t \\
\end{aligned}
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:6.049700000000001em;vertical-align:-2.774850000000001em;"></span><span class="mord"><span class="mtable"><span class="col-align-r"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:3.2748500000000003em;"><span style="top:-5.27485em;"><span class="pstrut" style="height:3.6379em;"></span><span class="mord"></span></span><span style="top:-2.249999999999999em;"><span class="pstrut" style="height:3.6379em;"></span><span class="mord"><span class="mrel">⟹</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:2.774850000000001em;"><span></span></span></span></span></span><span class="col-align-l"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:3.2748500000000003em;"><span style="top:-5.27485em;"><span class="pstrut" style="height:3.6379em;"></span><span class="mord"><span class="mord"></span><span class="mord mathdefault" style="margin-right:0.03588em;">y</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mop"><span class="mop op-symbol large-op" style="margin-right:0.44445em;position:relative;top:-0.0011249999999999316em;">∫</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.6379000000000004em;"><span style="top:-1.7880500000000004em;margin-left:-0.44445em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">h</span><span class="mopen mtight">(</span><span class="mord mathdefault mtight">x</span><span class="mclose mtight">)</span></span></span></span><span style="top:-3.8129000000000004em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.03588em;">g</span><span class="mopen mtight">(</span><span class="mord mathdefault mtight">x</span><span class="mclose mtight">)</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.0869499999999999em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mopen">(</span><span class="mord mathdefault">t</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord"><span class="mord mathrm">d</span></span></span><span class="mord mathdefault">t</span></span></span><span style="top:-2.249999999999999em;"><span class="pstrut" style="height:3.6379em;"></span><span class="mord"><span class="mord"></span><span class="mord mathdefault" style="margin-right:0.03588em;">y</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mop"><span class="mop op-symbol large-op" style="margin-right:0.44445em;position:relative;top:-0.0011249999999999316em;">∫</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.6379000000000004em;"><span style="top:-1.7880500000000001em;margin-left:-0.44445em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">0</span></span></span><span style="top:-3.8129000000000004em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.03588em;">g</span><span class="mopen mtight">(</span><span class="mord mathdefault mtight">x</span><span class="mclose mtight">)</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.9119499999999999em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mopen">(</span><span class="mord mathdefault">t</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord"><span class="mord mathrm">d</span></span></span><span class="mord mathdefault">t</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mop"><span class="mop op-symbol large-op" style="margin-right:0.44445em;position:relative;top:-0.0011249999999999316em;">∫</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.5640080000000003em;"><span style="top:-1.7880500000000004em;margin-left:-0.44445em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">h</span><span class="mopen mtight">(</span><span class="mord mathdefault mtight">x</span><span class="mclose mtight">)</span></span></span></span><span style="top:-3.8129000000000004em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.0869499999999999em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mopen">(</span><span class="mord mathdefault">t</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord"><span class="mord mathrm">d</span></span></span><span class="mord mathdefault">t</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:2.774850000000001em;"><span></span></span></span></span></span></span></span></span></span></span></span></p>
<p>分界点视具体情况而定。接下来使用负号：</p>
<p class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mtable><mtr><mtd><mstyle scriptlevel="0" displaystyle="true"><mrow></mrow></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="true"><mrow><mrow></mrow><mi>y</mi><mo>=</mo><msubsup><mo>∫</mo><mn>0</mn><mrow><mi>g</mi><mo>(</mo><mi>x</mi><mo>)</mo></mrow></msubsup><mi>f</mi><mo>(</mo><mi>t</mi><mo>)</mo><mtext> </mtext><mi mathvariant="normal">d</mi><mi>t</mi><mo>+</mo><msubsup><mo>∫</mo><mrow><mi>h</mi><mo>(</mo><mi>x</mi><mo>)</mo></mrow><mn>0</mn></msubsup><mi>f</mi><mo>(</mo><mi>t</mi><mo>)</mo><mtext> </mtext><mi mathvariant="normal">d</mi><mi>t</mi></mrow></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="true"><mo>⟹</mo></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="true"><mrow><mrow></mrow><mi>y</mi><mo>=</mo><msubsup><mo>∫</mo><mn>0</mn><mrow><mi>g</mi><mo>(</mo><mi>x</mi><mo>)</mo></mrow></msubsup><mi>f</mi><mo>(</mo><mi>t</mi><mo>)</mo><mtext> </mtext><mi mathvariant="normal">d</mi><mi>t</mi><mo>−</mo><msubsup><mo>∫</mo><mn>0</mn><mrow><mi>h</mi><mo>(</mo><mi>x</mi><mo>)</mo></mrow></msubsup><mi>f</mi><mo>(</mo><mi>t</mi><mo>)</mo><mtext> </mtext><mi mathvariant="normal">d</mi><mi>t</mi></mrow></mstyle></mtd></mtr></mtable><annotation encoding="application/x-tex">\begin{aligned}
&amp; y=\int^{g(x)}_0f(t)\,{\rm d}t +\int^0_{h(x)}f(t)\,{\rm d}t\\
\Longrightarrow &amp; y=\int^{g(x)}_0f(t)\,{\rm d}t -\int^{h(x)}_0f(t)\,{\rm d}t\\
\end{aligned}
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:5.874700000000001em;vertical-align:-2.6873500000000003em;"></span><span class="mord"><span class="mtable"><span class="col-align-r"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:3.1873500000000003em;"><span style="top:-5.18735em;"><span class="pstrut" style="height:3.6379em;"></span><span class="mord"></span></span><span style="top:-2.1624999999999996em;"><span class="pstrut" style="height:3.6379em;"></span><span class="mord"><span class="mrel">⟹</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:2.6873500000000003em;"><span></span></span></span></span></span><span class="col-align-l"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:3.1873500000000003em;"><span style="top:-5.18735em;"><span class="pstrut" style="height:3.6379em;"></span><span class="mord"><span class="mord"></span><span class="mord mathdefault" style="margin-right:0.03588em;">y</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mop"><span class="mop op-symbol large-op" style="margin-right:0.44445em;position:relative;top:-0.0011249999999999316em;">∫</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.6379000000000004em;"><span style="top:-1.7880500000000001em;margin-left:-0.44445em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">0</span></span></span><span style="top:-3.8129000000000004em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.03588em;">g</span><span class="mopen mtight">(</span><span class="mord mathdefault mtight">x</span><span class="mclose mtight">)</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.9119499999999999em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mopen">(</span><span class="mord mathdefault">t</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord"><span class="mord mathrm">d</span></span></span><span class="mord mathdefault">t</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mop"><span class="mop op-symbol large-op" style="margin-right:0.44445em;position:relative;top:-0.0011249999999999316em;">∫</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.5640080000000003em;"><span style="top:-1.7880500000000004em;margin-left:-0.44445em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">h</span><span class="mopen mtight">(</span><span class="mord mathdefault mtight">x</span><span class="mclose mtight">)</span></span></span></span><span style="top:-3.8129000000000004em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.0869499999999999em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mopen">(</span><span class="mord mathdefault">t</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord"><span class="mord mathrm">d</span></span></span><span class="mord mathdefault">t</span></span></span><span style="top:-2.1624999999999996em;"><span class="pstrut" style="height:3.6379em;"></span><span class="mord"><span class="mord"></span><span class="mord mathdefault" style="margin-right:0.03588em;">y</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mop"><span class="mop op-symbol large-op" style="margin-right:0.44445em;position:relative;top:-0.0011249999999999316em;">∫</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.6379000000000004em;"><span style="top:-1.7880500000000001em;margin-left:-0.44445em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">0</span></span></span><span style="top:-3.8129000000000004em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.03588em;">g</span><span class="mopen mtight">(</span><span class="mord mathdefault mtight">x</span><span class="mclose mtight">)</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.9119499999999999em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mopen">(</span><span class="mord mathdefault">t</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord"><span class="mord mathrm">d</span></span></span><span class="mord mathdefault">t</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mop"><span class="mop op-symbol large-op" style="margin-right:0.44445em;position:relative;top:-0.0011249999999999316em;">∫</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.6379000000000004em;"><span style="top:-1.7880500000000001em;margin-left:-0.44445em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">0</span></span></span><span style="top:-3.8129000000000004em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">h</span><span class="mopen mtight">(</span><span class="mord mathdefault mtight">x</span><span class="mclose mtight">)</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.9119499999999999em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mopen">(</span><span class="mord mathdefault">t</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord"><span class="mord mathrm">d</span></span></span><span class="mord mathdefault">t</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:2.6873500000000003em;"><span></span></span></span></span></span></span></span></span></span></span></span></p>
<p>当然，其实这种类型，有公式可以套，也可以自己推导哦：</p>
<p class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mtable><mtr><mtd><mstyle scriptlevel="0" displaystyle="true"><msup><mi>y</mi><mo mathvariant="normal">′</mo></msup></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="true"><mrow><mrow></mrow><mo>=</mo><msup><mrow><mo fence="true">(</mo><msubsup><mo>∫</mo><mrow><mi>h</mi><mo>(</mo><mi>x</mi><mo>)</mo></mrow><mrow><mi>g</mi><mo>(</mo><mi>x</mi><mo>)</mo></mrow></msubsup><mi>f</mi><mo>(</mo><mi>t</mi><mo>)</mo><mtext> </mtext><mi mathvariant="normal">d</mi><mi>t</mi><mo fence="true">)</mo></mrow><mo mathvariant="normal">′</mo></msup></mrow></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="true"><mrow></mrow></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="true"><mrow><mrow></mrow><mo>=</mo><mi>f</mi><mo fence="false">(</mo><mi>g</mi><mo>(</mo><mi>x</mi><mo>)</mo><mo fence="false">)</mo><mo>⋅</mo><msup><mi>g</mi><mo mathvariant="normal">′</mo></msup><mo>(</mo><mi>x</mi><mo>)</mo><mo>−</mo><mi>f</mi><mo fence="false">(</mo><mi>h</mi><mo>(</mo><mi>x</mi><mo>)</mo><mo fence="false">)</mo><mo>⋅</mo><msup><mi>h</mi><mo mathvariant="normal">′</mo></msup><mo>(</mo><mi>x</mi><mo>)</mo></mrow></mstyle></mtd></mtr></mtable><annotation encoding="application/x-tex">\begin{aligned}
y^\prime
&amp;=\left(\int^{g(x)}_{h(x)}f(t)\,{\rm d}t\right)^\prime\\
&amp;=f\big(g(x)\big)\cdot g^\prime(x)-f\big(h(x)\big)\cdot h^\prime(x)\\
\end{aligned}
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:4.951822em;vertical-align:-2.225911em;"></span><span class="mord"><span class="mtable"><span class="col-align-r"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:2.725911em;"><span style="top:-4.725911em;"><span class="pstrut" style="height:3.891792em;"></span><span class="mord"><span class="mord"><span class="mord mathdefault" style="margin-right:0.03588em;">y</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.801892em;"><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">′</span></span></span></span></span></span></span></span></span></span><span style="top:-2.3258810000000003em;"><span class="pstrut" style="height:3.891792em;"></span><span class="mord"></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:2.225911em;"><span></span></span></span></span></span><span class="col-align-l"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:2.725911em;"><span style="top:-4.725911em;"><span class="pstrut" style="height:3.891792em;"></span><span class="mord"><span class="mord"></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="minner"><span class="minner"><span class="mopen delimcenter" style="top:0em;"><span class="delimsizing size4">(</span></span><span class="mop"><span class="mop op-symbol large-op" style="margin-right:0.44445em;position:relative;top:-0.0011249999999999316em;">∫</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.6379000000000004em;"><span style="top:-1.7880500000000004em;margin-left:-0.44445em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">h</span><span class="mopen mtight">(</span><span class="mord mathdefault mtight">x</span><span class="mclose mtight">)</span></span></span></span><span style="top:-3.8129000000000004em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.03588em;">g</span><span class="mopen mtight">(</span><span class="mord mathdefault mtight">x</span><span class="mclose mtight">)</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.0869499999999999em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mopen">(</span><span class="mord mathdefault">t</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord"><span class="mord mathrm">d</span></span></span><span class="mord mathdefault">t</span><span class="mclose delimcenter" style="top:0em;"><span class="delimsizing size4">)</span></span></span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:1.8917920000000001em;"><span style="top:-4.2029000000000005em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">′</span></span></span></span></span></span></span></span></span></span><span style="top:-2.3258810000000003em;"><span class="pstrut" style="height:3.891792em;"></span><span class="mord"><span class="mord"></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mord"><span class="delimsizing size1">(</span></span><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="mopen">(</span><span class="mord mathdefault">x</span><span class="mclose">)</span><span class="mord"><span class="delimsizing size1">)</span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">⋅</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.801892em;"><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">′</span></span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord mathdefault">x</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mord"><span class="delimsizing size1">(</span></span><span class="mord mathdefault">h</span><span class="mopen">(</span><span class="mord mathdefault">x</span><span class="mclose">)</span><span class="mord"><span class="delimsizing size1">)</span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">⋅</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord"><span class="mord mathdefault">h</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.801892em;"><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">′</span></span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord mathdefault">x</span><span class="mclose">)</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:2.225911em;"><span></span></span></span></span></span></span></span></span></span></span></span></p>
<hr>
<p>其实这样的题目看起来复杂，实际上只要掌握了技巧和方法，解决就是分分钟的事情了！这节的内容非常简单，相信你很快就能够掌握。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Python的安装以及环境配置]]></title>
        <id>https://harriswilde.github.io/post/PythonInstall</id>
        <link href="https://harriswilde.github.io/post/PythonInstall">
        </link>
        <updated>2019-12-31T15:54:02.000Z</updated>
        <content type="html"><![CDATA[<p>在学习Python之前，我们需要安装Python才能够进行程序的编写。在这里，笔者就拿Python的官方发行版本来进行说明。对于早期的学习来说，官方的IDLE基本可以满足，如果真的要走上Python开发，或者是想要获得更高级的体验的话，后期可以自己尝试安装PyCharm、Visual Studio之类的IDE。</p>
<p>废话不多说，咱们开始。</p>
<hr>
<h1 id="windows环境">Windows环境</h1>
<h2 id="下载安装">下载安装</h2>
<p>Windows应该是咱们小伙伴最常用的一个系统了，应该对这个比较熟悉。那么其实直接去官网：<a href="https://www.python.org/downloads/">点我直达</a></p>
<p>在里面找到你想要下载的版本（如果你不知道你想要下载什么版本，那就下载<strong>最新</strong>的版本），点进去之后，翻到页面最底部，就可以看到所有的发行版文件。找到适用于Win的，然后找到后缀是<code>executable installer</code>的文件下载。如果你是<strong>64位</strong>的系统，那就找到含有<code>X86-64</code>关键字的文件下载，如果是<strong>32位</strong>就找<code>X86</code>。</p>
<p>下载好了之后应该是一个exe文件，双击安装即可。</p>
<p>安装的时候，注意在刚开始的时候把<code>Add Python to PATH</code>勾选上，它就会自动将Python添加到环境变量里面，如图：<br>
<img src="https://s2.ax1x.com/2020/01/09/lfpvsH.png" alt="勾选红色方框内的选项" loading="lazy"></p>
<p>如果你不知道你的Python是否添加了环境变量，那么只需要打开<code>CMD</code>，输入Python回车，如果提示“Python不是系统命令”的话，那就是没有添加。如果命令正常执行，Python交互解释器启动，那就已经添加完成了。</p>
<p>如果你是安装的Visual Studio这类IDE，或者在安装官方Python的时候忘记勾选，那么请看下面的教程手动添加。</p>
<h2 id="环境配置">环境配置</h2>
<p>虽然现在你已经可以开始写程序了，但是我们还是把环境变量先配置一下，方便以后安装拓展等等。</p>
<p>这里以Windows10为例，其他的操作系统也大同小异。</p>
<ol>
<li>右键此电脑，打开<code>属性</code><br>
<img src="https://s2.ax1x.com/2019/12/31/l1mAk8.png" alt="" loading="lazy"></li>
<li>选择<code>高级系统设置</code><br>
<img src="https://s2.ax1x.com/2019/12/31/l1mw0x.png" alt="" loading="lazy"></li>
<li>点击<code>高级</code>选项卡，进入<code>环境变量</code><br>
<img src="https://s2.ax1x.com/2019/12/31/l1mbcj.png" alt="" loading="lazy"></li>
<li>点击<code>Path</code>，<code>编辑</code><br>
<img src="https://s2.ax1x.com/2019/12/31/l1nzqI.png" alt="" loading="lazy"></li>
<li>点击<code>新建</code><br>
<img src="https://s2.ax1x.com/2019/12/31/l1uii8.png" alt="" loading="lazy"></li>
<li>找到你的Python安装的路径，将它和它的<code>Scripts</code>子目录也添加进去，像下面这样<br>
<img src="https://s2.ax1x.com/2019/12/31/l1u9dP.png" alt="" loading="lazy"><br>
添加完成，确定了之后，运行<code>cmd</code>，输入<code>Python</code>，如果出来的是这样的：</li>
</ol>
<pre><code>Microsoft Windows [Version 10.0.18363.535]
(c) 2019 Microsoft Corporation. All rights reserved.

C:\Users\Harris Wilde&gt;Python
Python 3.7.5 (tags/v3.7.5:5c02a39a0b, Oct 15 2019, 00:11:34) [MSC v.1916 64 bit (AMD64)] on win32
Type &quot;help&quot;, &quot;copyright&quot;, &quot;credits&quot; or &quot;license&quot; for more information.
&gt;&gt;&gt;_
</code></pre>
<p>那么恭喜你，你已经成功了！</p>
<p>如果是这样的：</p>
<pre><code>Microsoft Windows [Version 10.0.18363.535]
(c) 2019 Microsoft Corporation. All rights reserved.

C:\Users\Harris Wilde&gt;Python
'Python' is not recognized as an internal or external command,
operable program or batch file.
</code></pre>
<p>那么你可能中间有些步骤不对，回去再好好检查下吧。</p>
<hr>
<h1 id="linux和unix">Linux和Unix</h1>
<p>绝大部分的Linux和Unix系统（包括MacOS）都是内置Python解释器的，你只需要打开终端提示符，输入以下命令：</p>
<pre><code>$ python
</code></pre>
<p>这会启动Python交互解释器，同时也应该有下面这样的输出：</p>
<pre><code>Python 2.5.1 (r251:54869, Apr 18 2007, 22:08:04)
[GCC 4.0.1 (Apple Computer, Inc . build 5367)] on darwin
Type &quot;help&quot;, &quot;copyright&quot;, &quot;credits&quot; or &quot;license&quot; for more information.
&gt;&gt;&gt;▮
</code></pre>
<p>如果没有安装的话，可能会得到下面的错误：</p>
<pre><code>bash: python: command not found
</code></pre>
<p>那么，你就要自己安装了。</p>
<h2 id="使用包管理器">使用包管理器</h2>
<p>Linux系统家族存在多种包管理系他和安装机制。如果你使用的是Linux是有某种某种形式的包管理系统，那么你可以通过它很轻松地安装Python。</p>
<blockquote>
<p>注意，在Linux中使用包管理安装器安装Python的时候可能需要具备系统管理员（root账户）权限。</p>
</blockquote>
<p>例如，如果使用的操作系统位Debian Linux，那么可以使用下面的命令来安装Python：</p>
<pre><code>$ apt-get install python
</code></pre>
<p>如果是Gentoo Linux，则可以使用：</p>
<pre><code>$ emerge python
</code></pre>
<blockquote>
<p>许多包管理器都有自动下载的功能，包括Yum、Synaptic（Unbuntu Linux专有的包管理器）以及其他Debian样式的管理器。你能够通过这些管理器获得Python的最新版本。</p>
</blockquote>
<h2 id="从源文件编译">从源文件编译</h2>
<p>如果你没有包管理器，或者不想用的话，也可以尝试自己编译Python。当然也有可能是你没有管理员权限，这个方法也适用，十分灵活。你可以在<strong>任何位置</strong>安装Python，甚至可以安装在用户的主目录都是没问题的。那么接下来就来开始：</p>
<ol>
<li>访问官网的下载页：<a href="https://www.python.org/downloads/">点我直达</a></li>
<li>按照说明下载源代码</li>
<li>下载拓展名为<code>.tgz</code>的文件，将其保存在临时的位置。假设你想将Python安装在自己的主目录，那么可以将它放置在类似于<code>~/python</code>的目录中。进入这个目录（比如使用<code>cd ~/python</code>命令）。</li>
<li>使用<code>tar -xzvf Python-3.7.tgz</code>(3.7是版本号)解压缩文件。如果使用的tar版本不支持<code>z</code>选项，那么可以先使用gunzip进行解压，然后再使用<code>tar -xvf</code>命令。如果解压缩的过程中出错，那你就试试重新下载，因为下载的时候也有可能会出错。</li>
<li>进入解压好的文件夹：<pre><code>$ cd Python-3.7
</code></pre>
执行下面的命令：<pre><code>./configue --perfix=$(pwd)
make
make install
</code></pre>
最后应该可以再当前文件夹内找到一个名为python的可执行文件（如果上面的步骤无效的话，那就看看包含在发布版中的README文件）。将当前文件夹的路径包含在环境变量PATH中，这样安装就大功告成了！<br>
如果要看看其他的配置命令，那么就使用以下的命令：<pre><code>./configue --help
</code></pre>
</li>
</ol>
<hr>
<h1 id="macos">MacOS</h1>
<p>MacOS是有自带的Python解释器的。你只需要打开终端，输入python命令就可以运行。即使打算安装更新的版本，也应该保留这个默认的安装，因为操作系统需要用到它。读者可以使用<a href="http://macports.org">MacPorts</a>或者<a href="http://finkproject.org">Fink</a>进行安装，或者按照以下的步骤从Python官网获取最新的版本。</p>
<ol>
<li>访问官网下载：<a href="https://www.python.org/downloads/">点我直达</a></li>
<li>点击MacOS Installer的链接，应该会跳转到MacPython的下载页面，上面会有更多的信息。MacPython页面也有针对旧版MacOS的Python。</li>
<li>下载了<code>.dmg</code>安装文件之后，它有可能会自动挂载。如果没有，双击该文件。已经挂载的磁盘映像中，可以找到安装包文件<code>.mpkg</code>。如果双击该文件，，就会打开安装向导，引领你完成安装的步骤。</li>
</ol>
<hr>
<p>安装完成了之后，你可以使用命令或者Win下打开IDLE，输入</p>
<pre><code class="language-python">print(&quot;Hello, world!&quot;)
</code></pre>
<p>应该解释器就会给你打招呼啦：</p>
<pre><code>Python 3.7.5 (tags/v3.7.5:5c02a39a0b, Oct 15 2019, 00:11:34) [MSC v.1916 64 bit (AMD64)] on win32
Type &quot;help&quot;, &quot;copyright&quot;, &quot;credits&quot; or &quot;license()&quot; for more information.
&gt;&gt;&gt; print(&quot;Hello, world!&quot;)
Hello, world!
&gt;&gt;&gt; _
</code></pre>
<p>那么这时候，你也可以试着输入其他的指令看看：</p>
<pre><code>&gt;&gt;&gt; 你好吗？
SyntaxError: invalid character in identifier
&gt;&gt;&gt; _
</code></pre>
<p>这是因为你还不会和解释器进行交流，自然它就听不懂你在说什么了。</p>
<p>不过要是不会交流，还是挺没意思的吧？</p>
<p>如果你已经看到了这里，那么今天的基础工作应该做的差不多了，那咱们就开始吧。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Python学习开场白]]></title>
        <id>https://harriswilde.github.io/post/PythonBeginner</id>
        <link href="https://harriswilde.github.io/post/PythonBeginner">
        </link>
        <updated>2019-12-31T15:02:06.000Z</updated>
        <content type="html"><![CDATA[<p>在2019年的最后一天，写一篇小短文来正式开启我的Python学习的版面。</p>
<p>Python语言，用我的话来说，就是通识语言。基本上只要你会一点点英语，那么这门语言对于你来说，就毫无难度。语法几乎就是英语，你甚至不需要知道那些艰深晦涩的原理，就可以快速地达到你想达到的目的。无论你是文科还是理科，无论你是否有计算机基础，你都可以学习这门语言。我甚至有一种预感，这门语言未来将不再是程序员们的专属，可能会成为一门普适性的语言，现在已经有这种趋势了。</p>
<p>当然，Python也有许多令人诟病的地方，比如版本更新兼容性差，性能低，函数语法太过冗杂等等。咱们就来避重就轻，感受一下这门语言的魅力。</p>
<p>Python和大数据、人工智能、机器学习等名词连起来出现已经见怪不怪了，还是那句话，你不需要很专业，也不需要很痛苦，静下心来学习，你会发现，编程已经成为了一种享受，就像和计算机对话一样。</p>
<p>但是，如果你是计算机类专业的学生，或者打算从事这方面的工作，就千万别局限于Python，也别听那些什么机构吹的东西，Python虽然简单，但是用Python来解决的问题往往不简单，过硬的实力是必不可少的。</p>
<p>最后，祝诸君鼠年大吉，学业有成、事业攀升！</p>
<pre><code class="language-python">print(&quot;新年快乐！&quot;)
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[C语言之数组]]></title>
        <id>https://harriswilde.github.io/post/CArray</id>
        <link href="https://harriswilde.github.io/post/CArray">
        </link>
        <updated>2019-12-07T15:29:32.000Z</updated>
        <content type="html"><![CDATA[<p>学完了前面几种基础语法之后，你可能会渐渐发现，现有的数据的记录方式，已经无法很好地解决我们接下来要解决的问题。比如有一天，老师找你计算一下全班同学的平均成绩。那么你就会开始思考如何存储全班的成绩。按照之前学习的知识，我们可以定义<code>a1</code> <code>a2</code> <code>a3</code> <code>……</code>。但是，这样未免也太麻烦了，如果要记录全省人民的身高数据呢？如果下个学期班里学生人数有变化呢？</p>
<p>你会发现，种种原因，导致了我们编写的程序很繁杂，不够灵活。那么这样，编程也就没有太大的必要了。好在，C语言提供了一种存储数据的方式，叫做<strong>数组</strong>。</p>
<hr>
<p>数组，就是存放一堆<strong>同类型</strong>的数据的容器。比如刚刚的例子，我们要存储学生的成绩，这时候数组就可以大显神威了。</p>
<h1 id="定义一维数组">定义一维数组</h1>
<p>定义一维数组的方法很简单，只需要指定元素的类型和存放的数量即可。</p>
<p><code>类型 数组名[元素个数]</code></p>
<p>比如：</p>
<pre><code class="language-c">int Score1[50];//定义一个叫Score1的整型数组，有50个元素
float Score2[30];//定义一个叫Score2的浮点型数组，有30个元素
double Score3[20];//定义一个叫Score3的双精度浮点型数组，有20个元素
char Str[10];//定义一个叫Str的字符型数组，有10个元素
</code></pre>
<p>数组一旦被定义，在其生命周期内，就<strong>不可能被改变</strong>(其实是在内存中开辟了一段连续的空间了)。</p>
<h1 id="访问数组">访问数组</h1>
<p>访问数组的方法和定义有点类似，但是如果混淆了的话，那可就不是什么好事了。</p>
<p><code>数组名[下标]</code></p>
<p>方括号里面的，实际上是指的数组的<strong>下标</strong>，也可以叫<strong>索引</strong>。需要注意的是，下标的计数是从<code>0</code>开始的，最大的下标是<code>(元素个数-1)</code>。也就是说，如果我<code>int Score[10]</code>之后，那么我想访问第一个元素，就是这样<code>Score[0]</code>，如果要访问最后一个元素，就是<code>Score[9]</code>。</p>
<p>之前看到过一个段子，大概意思是说程序员数数都喜欢从0开始数。如果你是刚刚接触编程，那么你也要开始习惯从0开始计数的这种思路。</p>
<p>其实，并不是C语言才开始有数组，FORTRAN语言就有数组了。但是下标从0开始计数这种方式，是从C语言才开始有的。当时开发C语言编译器的人们就想让编译器能够更加简单，如果从0开始，那么编译器实际上能够少做很多事情，于是就多了这么一个设定。随着计算机科学的发展，后面出现的优秀的语言也越来越多。但是我们所说的&quot;C-Like”语言，也就是参照C语言来开发的语言，也都继承了C语言这一“优良传统”，因此就有了程序员数数是从0开始的这么一种说法。</p>
<p>讲到这里，想必大家也就会明白之前为什么我们在循环的时候，初始值都是设定为0的了。像这样：</p>
<pre><code class="language-c">for (i = 0; i &lt; 10; i++)
{
    ...
}
</code></pre>
<p>而不是像这样写(当然也没错)：</p>
<pre><code class="language-c">for (i = 1; i &lt;= 10; i++)
{
    ...
}
</code></pre>
<p>这就是因为，我们在使用循环的时候，经常会配合数组一起来使用，那么我们循环设置成和数组下标的计数方法一样，有利于我们使用数组。</p>
<p>还是回到我们最初的那个问题，存储班里面学生的成绩，然后计算出平均值：</p>
<pre><code class="language-c">//Example 01
#include &lt;stdio.h&gt;
int main(void)
{
    int s[10];//假定我们班上有10个人
    int i;
    double sum = 0;
    for (i = 0; i &lt; 10; i++)
    {
        printf(&quot;请输入第 %d 位同学的成绩：&quot;, i + 1);
            scanf(&quot;%d&quot;, &amp;s[i]);
        sum += s[i];
    }
    printf(&quot;成绩录入完毕，该次考试的平均分是：%.2f\n&quot;, sum/10);
    return 0;
}
</code></pre>
<p>程序实现如下：</p>
<pre><code>//Consequence 01
请输入第 1 位同学的成绩：80
请输入第 2 位同学的成绩：90
请输入第 3 位同学的成绩：70
请输入第 4 位同学的成绩：66
请输入第 5 位同学的成绩：77
请输入第 6 位同学的成绩：54
请输入第 7 位同学的成绩：67
请输入第 8 位同学的成绩：86
请输入第 9 位同学的成绩：78
请输入第 10 位同学的成绩：65
成绩录入完毕，该次考试的平均分是：73.30
</code></pre>
<h1 id="数组的初始化">数组的初始化</h1>
<p>在定义数组的时候同时对其<strong>各个元素</strong>进行赋值，称为数组的初始化。在刚刚的代码中，我们定义了数组，但却没有在定义的时候就初始化，而是在循环中进行赋值。那么初始化数组一般有下面几种方法：</p>
<ol>
<li>
<p>将数组中所有的元素初始化为0，可以这么写：</p>
<pre><code class="language-c">int a[10] = {0};
</code></pre>
</li>
<li>
<p>如果要赋予不同的值，用逗号分开即可：</p>
<pre><code class="language-c">int a[5] = {1, 2, 3, 4, 5};
</code></pre>
</li>
<li>
<p>给部分元素赋值，剩下的自动初始化为0：</p>
<pre><code class="language-c">int a[10] = {1, 2 ,3};//剩下的全部为0
</code></pre>
</li>
<li>
<p>也可以偷懒只给出每个元素的值，让编译器自己判断数组长度：</p>
<pre><code class="language-c">int a[] = {1, 2, 3, 4, 5};
</code></pre>
</li>
<li>
<p>C99中增加了一种特性，指定元素进行赋值，剩下的自动初始化为0。也就是说，可以针对不连续的几个元素赋值：</p>
<pre><code class="language-c">int a[10] = { [3] = 3, [5] = 5, [8] = 8 };//编译的时候记得加上-std=c99选项
</code></pre>
</li>
</ol>
<p>其实，在C语言界，还有一个所谓“口耳相传”的书写习惯，就是：</p>
<pre><code class="language-c">int a[] = {1, 2, 3, 4, 5,};
</code></pre>
<p>在最后一个元素后面加一个逗号。其实这对最终的编译没有任何影响，只不过一些老教材或者说计算机界的先辈们认为，这可以方便后人维护的时候添加元素。加不加逗号都无所谓，只不过习惯于加逗号的，都是在七八十年代就接触过C语言的人，某种意义上来说，这种习惯可以成为一个标签，拿出去 <s>装装逼</s> 也是可以的。</p>
<p>那可能你会说了，”你刚刚提到的一个问题还没解决呢！要是班里的人数变了怎么办呢？“</p>
<p>没错，我们现在就来解决下这个问题。</p>
<h1 id="可变长数组">可变长数组</h1>
<p>在C99标准推出之前，要求定义数组的时候，数组的维度必须是<strong>常量表达式</strong>或者<strong>const常量</strong>，但是C99标准中，支持了变量定义数组，那么，我们就可以将第一次的代码改成这样：</p>
<pre><code class="language-c">//Example 02
#include &lt;stdio.h&gt;
int main(void)
{
    int Member;
    printf(&quot;请输入班级人数：&quot;);
    scanf(&quot;%d&quot;, &amp;Member);
    int s[Member];//使用用户输入的值来确定数组的大小
    int i;
    float sum = 0;
    for (i = 0; i &lt; Member; i++)
    {
        printf(&quot;请输入第 %d 位同学的成绩：&quot;, i + 1);
            scanf(&quot;%d&quot;, &amp;s[i]);
        sum += s[i];
    }
    printf(&quot;成绩录入完毕，该次考试的平均分是：%.2f\n&quot;, sum/Menber);
    return 0;
}
</code></pre>
<p>这样，在开始存储成绩之前，先让使用者告诉程序班里有多少学生，该开辟多大的数组，然后就完美解决了人数变动的问题。</p>
<p>注意，这里的”可变长数组“是指的数组在程序运行的时候才<strong>确定长度</strong>，也就是说每一次运行都不一定一样。但是数组一旦被创建，在其生命周期内就不会再改变了，这是数组的<strong>根本特性</strong>。</p>
<p>但是，如果有的同学使用的是Visual Studio的话，是不支持C99的这个特性的(我也不知道为什么巨硬不支持，明明这么好的特性)，那么就只能使用<strong>动态分配</strong>的方法来创建数组。放在这里来讲的话有些超纲，后面会讲到。</p>
<h1 id="字符型数组">字符型数组</h1>
<p>还记得之前说过，C语言是没有字符串这种类型的。那么C语言处理字符串有两种方法：<strong>字符串常量</strong>和<strong>字符型数组</strong>。字符串常量是指用<strong>双引号</strong>括起来的字符串，一旦确定下来就<strong>无法改变</strong>。一般我们会更多地倾向于使用更加灵活的<strong>字符型数组</strong>。这样，数组中的每一个元素表示一个字符，当然还要多一位来表示<code>\0</code>。</p>
<p>那么接下来就讲讲字符串的一些方法，因为字符串实在是太重要了。</p>
<h2 id="获取字符串的长度">获取字符串的长度</h2>
<p>计算字符串的长度使用<code>strlen</code>函数（这是长度，不是尺寸）,这个函数包含在<code>string.h</code>中</p>
<pre><code class="language-c">#include &lt;string.h&gt;
...
size_t strlen ( const char * str );
</code></pre>
<p>这个方法是不包含字符串末尾的<code>\0</code>的。且看下面的例子：</p>
<pre><code class="language-c">//Example 03
#include &lt;stdio.h&gt;
#include &lt;string.h&gt;
int main(void)
{
    char str[] = &quot;I love Clang!&quot;;
    printf(&quot;sizeof str = %d\n&quot;, sizeof(str));
    printf(&quot;strlen str = %u\n&quot;, strlen(str));
    return 0;
}
</code></pre>
<p>运行结果如下：</p>
<pre><code>//Consequence 03
sizeof str = 14
strlen str = 13
</code></pre>
<p>除了验证不包含<code>\0</code>以外，我们还可以看到，<code>strlen</code>函数返回的是<code>size_t</code>而不是<code>int</code>。<code>size_t</code>被定义在<code>stddef.h</code>中，实际上就是<strong>无符号整型</strong>。</p>
<h2 id="复制字符串">复制字符串</h2>
<p>估计在第一次见到这个词的时候，你的大脑浮现出来的就是使用赋值符号<code>=</code>，但是，这是<strong>错的</strong>……</p>
<p>字符串的复制应该使用<code>strcpy</code>和<code>strncpy</code>来实现。</p>
<pre><code class="language-c">#include &lt;string.h&gt;
...
char *strcpy (char *dest, const char *src);
char *strncpy (char *dest, const char *src, size_t n);
</code></pre>
<p>不多废话，且看下面的例子：</p>
<pre><code class="language-c">//Example 04
#include &lt;stdio.h&gt;
#include &lt;string.h&gt;
int main(void)
{
	char str1[] = &quot;Original String&quot;;
	char str2[] = &quot;New String&quot;;
	char str3[100];
	strcpy(str1, str2);
	strcpy(str3, &quot;Successfully Copied&quot;);
	printf(&quot;\
str1: %s\n\
str2: %s\n\
str3: %s\n&quot;, \
		str1, str2, str3);
	return 0;
}
</code></pre>
<p>运行结果如下：</p>
<pre><code>//Consequence 04
str1: New String
str2: New String
str3: Successfully Copied
</code></pre>
<p>但是其实这个程序是<strong>有缺陷</strong>的。</p>
<p>我们可以看到，两个数组的长度其实<strong>不一样</strong>，我们现在是把短的复制到长的里面，那么不会有问题。如果上面的<code>str1</code>和<code>str2</code>对调一下，那么就极有可能出问题，这就是我们等会儿要讲的<strong>数组越界</strong>问题。</p>
<p>那么如何解决复制时的这个隐式bug呢？</p>
<p><strong>使用strncpy方法来复制</strong></p>
<p>如果超出的字符不是很多，那么程序有可能能够成功地运行。但是如果两者悬殊的话，那编译运行之后，程序会报<code>Segmentation fault</code>。</p>
<p>因此在复制的时候，我们应该确保不越界，在复制之后不溢出。那么使用<code>strncpy</code>函数，由于增加了一个参数来指定<strong>复制的字符个数</strong>，我们在编写代码的时候就可以规避这样的问题。</p>
<p>举个例子：</p>
<pre><code class="language-c">//Example 05
#include &lt;stdio.h&gt;
#include &lt;string.h&gt;
int main(void)
{
    char str1[] = &quot;TechZone was made by HarrisWilde&quot;;
    char str2[40];
    strncpy(str2, str1, 8);
    str2[8] = '\0';
    printf(&quot;%s\n&quot;, str2);
    return 0;
}
</code></pre>
<p>结果如下：</p>
<pre><code>//Consequence 05
TechZone
</code></pre>
<p>有一个地方要格外小心，<code>strncpy</code>函数<strong>并不会</strong>在字符串的末尾添加<code>\0</code>，因此在使用的时候要注意加上。</p>
<h2 id="连接字符串">连接字符串</h2>
<p>如果你想把一个字符串拼接到另一个后面的话，就可以使用<code>strcat</code>和<code>strncat</code>两个函数来实现。</p>
<pre><code class="language-c">#include &lt;string.h&gt;
...
char *strcat (char *dest, const char *src);
char *strncat (char *dest, const char *src, size_t n);
</code></pre>
<p>可以看到，这个函数的用法和上面复制字符串的用法完全相同，<code>strncat</code>也就是比<code>strcat</code>多了一个指定复制长度的参数罢了。</p>
<p>需要注意的是，这个函数<strong>会</strong>自动在末尾追加一个<code>\0</code>，这和复制不一样，要特别注意区分。</p>
<h2 id="比较字符串">比较字符串</h2>
<p>比较两个字符串，也和上面的一样，有两个类似的函数，<code>strcmp</code>和<code>strncmp</code>。</p>
<pre><code class="language-c">#include &lt;string.h&gt;
...
char *strcmp (char *dest, const char *src);
char *strncmp (char *dest, const char *src, size_t n);
</code></pre>
<p>采用这套函数来比较两个字符串是否相同的时候，如果两个字符串完全一致，那么返回的值为<code>0</code>。这个函数的原理是，从第一个字符开始，依次对比两个字符串中每个字符的ASCII，如果第一个字符串的ASCII小于第二个字符串对应的字符，那么返回一个小于<code>0</code>的数值（通常是<code>-1</code>），如果大于，那就会返回一个大于<code>0</code>的值（通常是<code>1</code>）。</p>
<p><code>strncmp</code>则是增加了一个参数，可以用来仅比较前面n个元素。</p>
<pre><code class="language-c">//Example 06
#include &lt;stdio.h&gt;
#include &lt;string.h&gt;
int main(void)
{
    char str1[10] = &quot;TechZone&quot;;
    char str2[20] = &quot;TechZone&quot;;
    if (!strcmp(str1, str2))
    {
        printf(&quot;Same!\n&quot;);
    }
    else
    {
        printf(&quot;Different!\n&quot;);
    }
    return 0;
}
</code></pre>
<p>运行结果为：</p>
<pre><code>//Consequence 06
Same!
</code></pre>
<h1 id="多维数组">多维数组</h1>
<p>有时候，使用数组来存储还是不够方便，比如，老师让你做一个全班全部科目的成绩的分析。如果利用我们刚刚所学习的数组知识，你可能会这么写：</p>
<pre><code class="language-c">//Example 07
#include &lt;stdio.h&gt;
int main(void)
{
    int chinese[50];
    int math[50];
    int English[50];
    int science[50];
    ...
}
</code></pre>
<p>但是如果我们使用二维数组的话，那么只需要定义一次就行了。</p>
<p>假设我们有6科。</p>
<p>那么就这样：</p>
<pre><code class="language-c">//Example 07 V2
#include &lt;stdio.h&gt;
int main(void)
{
    int score[6][50];
    ...
}
</code></pre>
<p>这其实就像一个表格一样，二维数组通常也被称为<strong>矩阵</strong>（matrix），将二维数组写成行和列的表示形式，可以形象地帮我们解决一些问题。</p>
<p>访问二维数组也和普通的数组一样，也是从<code>0</code>开始计数的，只不过下标随着维度的变化会增加罢了（比如二维数组就有2个下标）。</p>
<h2 id="二维数组的初始化">二维数组的初始化</h2>
<ol>
<li>
<p>二维数组在内存中是<strong>线性存放</strong>的，因此可以将所有的数据写在一个大括号内：</p>
<pre><code class="language-c">int a[2][3] = {1, 2, 3, 4, 5, 6};
</code></pre>
<p>这样就是先将第一行的三个元素初始化，然后再初始化第二行的元素。</p>
</li>
<li>
<p>为了更直观地表达我们可以这么写：</p>
<pre><code class="language-c">int a[2][3] = {
    {1, 2, 3},
    {4, 5, 6}
};
</code></pre>
</li>
<li>
<p>二维数组也可以仅对<strong>部分元素</strong>赋值：</p>
<pre><code class="language-c">int a[2][3] = {{1}, {4}};
</code></pre>
<p>这样写只是对各行的第一列元素赋值，其余的全部为0.</p>
</li>
<li>
<p>如果希望全部为0，那么可以这么写：</p>
<pre><code class="language-c">int a[2][3] = {0};
</code></pre>
</li>
<li>
<p>C99中增加的指定赋值的特性，这里也可以适用。其余未被操作的元素为<code>0</code>。</p>
<pre><code class="language-c">int a[2][3] = {[0][0] = 1, [1][2] = 6};
</code></pre>
</li>
<li>
<p>二维数组也可以偷懒，但是<strong>只有第一维度</strong>的元素个数可以不写，其他的都要写上：</p>
<pre><code class="language-c">int a[][3] = {
    {1, 2, 3},
    {4, 5, 6}
};
</code></pre>
</li>
</ol>
<h1 id="数组越界">数组越界</h1>
<p>我们刚刚说过了，我们在写程序的时候，尽量要把越界的情况通过代码的努力来规避。那么，可能有的小伙伴比较感兴趣，如果越界了，会发生什么呢？</p>
<p>那好，咱们就来试试。</p>
<pre><code class="language-c">//Example 08
#include &lt;stdio.h&gt;

void f();

int main(void)
{
    f();
    return 0;
}

void f()
{
    int a[10];
    a[10] = 0;//这里我们写到了一个不存在的下标里面
}
</code></pre>
<p>我们来跑一下这个程序。</p>
<p>笔者使用的Visual Studio 2019给出了以下的错误提示：</p>
<pre><code>//Consequence 08
Run-Time Check Failure #2 - Stack around the variable 'a' was corrupted.
</code></pre>
<p>它发现了我在写入一个<strong>错误的地址</strong>。并且还给了我两个<strong>warning</strong>：</p>
<pre><code>警告	C6201	索引“10”超出了“0”至“9”的有效范围(对于可能在堆栈中分配的缓冲区“a”)。
警告	C6386	写入到“a”时缓冲区溢出: 可写大小为“40”个字节，但可能写入了“44”个字节。	
</code></pre>
<p>如果我们像普通程序员一样，不管代码warning，直接强制执行，试试会发生什么。</p>
<p>为了更直观体现，我们把代码改成这样：</p>
<pre><code class="language-c">//Example 08
#include &lt;stdio.h&gt;

void f();

int main(void)
{
    f();
    printf(&quot;Here\n&quot;);//我们加了这句，如果函数正常执行完毕了，就可以看到这个语句的输出
    return 0;
}

void f()
{
    int a[10];
    a[10] = 0;
}
</code></pre>
<p>还是出现了这句：</p>
<pre><code>Run-Time Check Failure #2 - Stack around the variable 'a' was corrupted.
</code></pre>
<p>控制台上面没有看到<code>Here</code>的输出，说明函数还没有执行完，程序就已经<strong>崩溃</strong>了，根本没办法执行到输出。</p>
<p>但是，为什么编译器没有给我<strong>error</strong>，而是给了我<strong>warning</strong>呢？</p>
<p>有的编译器可能连warning都没有。</p>
<p>实际上，我们在对<code>a[10]</code>写入的时候，其实是<strong>成功</strong>了的。只不过我们把<code>a[10]</code>写在了一个<strong>不该写的地方</strong>（实际上就是这段数组内存的后面），干扰到了其他东西的运行，程序就有可能会崩溃。如果后面的内存为空或者是没有被回收的垃圾内存，那么就没关系，但是如果是有用的内存，出问题就很正常了。</p>
<p>有时候我们写了一个程序，可能这次运行没问题，下一次运行就出错，或者是在我的电脑上可以，在你的电脑上就不行了等等，都有可能是数组越界，或者是我们后面要学的指针出错了。我们作为创造代码的人，有责任通过代码上的设计，来规避这样的问题，避免程序的崩溃。</p>
<h1 id="长度为0的数组">长度为0的数组？</h1>
<p>有的同学可能会异想天开，说，我可不可以定义一个长度为0的数组呢？</p>
<p>类似于这样：</p>
<pre><code class="language-c">int a[0];
</code></pre>
<p>答案是，完全没问题！</p>
<p>不信的话可以去试试，编译可以通过的，只不过这样的数组不存在任何意义，因为没有符合要求的下标。我们说，最大的下标就是元素个数-1，那么<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>0</mn><mo>−</mo><mn>1</mn><mo>=</mo><mo>−</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">0-1=-1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.72777em;vertical-align:-0.08333em;"></span><span class="mord">0</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.72777em;vertical-align:-0.08333em;"></span><span class="mord">−</span><span class="mord">1</span></span></span></span>，-1显然不是一个合法的下标。所以这样的操作可行，但是没有任何意义。</p>
<p>好了，本节内容就到这里了，希望你能够从中有所收获哦！</p>
]]></content>
    </entry>
</feed>