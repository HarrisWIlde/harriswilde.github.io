<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://harriswilde.github.io</id>
    <title>TechZone</title>
    <updated>2020-02-13T08:03:32.335Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://harriswilde.github.io"/>
    <link rel="self" href="https://harriswilde.github.io/atom.xml"/>
    <subtitle>HarrisWilde祝诸君元旦快乐🎉</subtitle>
    <logo>https://harriswilde.github.io/images/avatar.png</logo>
    <icon>https://harriswilde.github.io/favicon.ico</icon>
    <rights>All rights reserved 2020, TechZone</rights>
    <entry>
        <title type="html"><![CDATA[排序算法：选择排序]]></title>
        <id>https://harriswilde.github.io/post/FojWe45tS</id>
        <link href="https://harriswilde.github.io/post/FojWe45tS">
        </link>
        <updated>2020-02-13T08:02:58.000Z</updated>
        <content type="html"><![CDATA[<p>所谓选择排序，就是每次将剩余区间内最大（或者最小）的数放在最右边（或者最左边），从而达到排序的算法。之所以叫做<strong>选择排序</strong>，是因为每一次都选出剩下的最大或者最小值来达到排序。</p>
<p>看动画：</p>
<img src="https://s2.ax1x.com/2020/02/13/1L9TK0.gif" alt="选择排序" style="zoom:67%;" />
<p>如图，每次将最大的放在右边，遍历完成之后就是一个有序数列了。</p>
<p>代码实现如下：</p>
<pre><code class="language-c">//C
#include &lt;stdio.h&gt;
void sort(int arr[])
{
    for (int i = sizeof(arr)/sizeof(arr[0]) - 1; i &gt;= 0; i--)
    {
        for(int j = 0; j &lt; i; j++)
        {
            int temp = 0;
            if (arr[j] &gt; arr[i])
            {
                temp = arr[j];
                arr[j] = arr[i];
                arr[i] = temp;
            }
        }
    }
}

</code></pre>
<pre><code class="language-java">//Java
public class SelectionSort implements IArraySort {

    @Override
    public int[] sort(int[] sourceArray) throws Exception {
        int[] arr = Arrays.copyOf(sourceArray, sourceArray.length);

        // 总共要经过 N-1 轮比较
        for (int i = 0; i &lt; arr.length - 1; i++) {
            int min = i;

            // 每轮需要比较的次数 N-i
            for (int j = i + 1; j &lt; arr.length; j++) {
                if (arr[j] &lt; arr[min]) {
                    // 记录目前能找到的最小值元素的下标
                    min = j;
                }
            }

            // 将找到的最小值和i位置所在的值进行交换
            if (i != min) {
                int tmp = arr[i];
                arr[i] = arr[min];
                arr[min] = tmp;
            }

        }
        return arr;
    }
}
</code></pre>
<pre><code class="language-python">#Python
def sort(arr):
    for i in range(0, len(arr), -1):
        for j in range(0, i):
            if arr[j] &gt; arr[i]:
                arr[j], arr[i] = arr[i], arr[j]
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[排序算法：冒泡排序及其优化]]></title>
        <id>https://harriswilde.github.io/post/wi0begzME</id>
        <link href="https://harriswilde.github.io/post/wi0begzME">
        </link>
        <updated>2020-02-13T04:21:33.000Z</updated>
        <content type="html"><![CDATA[<h1 id="冒泡排序">冒泡排序</h1>
<p>冒泡排序属于几种排序算法里面的最简单的一种，不需要什么高深的思维，就可以很快理解。</p>
<p>冒泡排序实际上就是把相邻的数相互比较，把大的放右边（或者左边，这取决于你想顺序排还是倒序排）。如果把大的放右边，那么第一轮遍历之后，就会把这组数据中最大的放到最后边。</p>
<p>此时，最后一个已经是固定的了，依次把前面的按照这样的套路排序下去就行了。</p>
<p>下面这个动画可能会更直观地帮助你理解：</p>
<img src="https://s2.ax1x.com/2020/02/13/1qJg2R.gif" alt="冒泡排序" style="zoom:67%;" />
<p>代码实现如下：</p>
<p>C:</p>
<pre><code class="language-c">#include &lt;stdio.h&gt;
void sort(int arr[])
{
    for (int i = 0; i &lt; sizeof(arr)/sizeof(arr[0]) - 1; i++)
    {
        for(int j = 0; j &lt; sizeof(arr)/sizeof(arr[0]) - 1 - i; j++)
        {
            int temp = 0;
            if (arr[j] &gt; arr[j + 1])
            {
                temp = arr[j];
                arr[j] = arr[j + 1];
                arr[j + 1] = temp;
            }
        }
    }
}
</code></pre>
<p>Java:</p>
<pre><code class="language-java">public static void sort(int arr[]){
    for( int i = 0 ; i &lt; arr.length - 1 ; i++ ){
        for(int j = 0;j &lt; arr.length - 1 - i ; j++){
            int temp = 0;
            if(arr[j] &gt; arr[j + 1]){
                temp = arr[j];
                arr[j] = arr[j + 1];
                arr[j + 1] = temp;
            }
        }
    }
}
</code></pre>
<p>Python:</p>
<pre><code class="language-python">def sort(arr):
    for i in range(len(arr)):
        for j in range(len(arr) - i):
            if arr[j] &gt; arr[j + 1]:
                arr[j], arr[j + 1] = arr[j + 1], arr[j]
</code></pre>
<p>我们看到双层循环，就不难推出这个算法的时间复杂度为<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>O</mi><mrow><mo>(</mo><msup><mi>n</mi><mn>2</mn></msup><mo>)</mo></mrow></msub></mrow><annotation encoding="application/x-tex">O_{(n^2)}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.03853em;vertical-align:-0.3551999999999999em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.34480000000000005em;"><span style="top:-2.5198em;margin-left:-0.02778em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mopen mtight">(</span><span class="mord mtight"><span class="mord mathdefault mtight">n</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.7463142857142857em;"><span style="top:-2.786em;margin-right:0.07142857142857144em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mclose mtight">)</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.3551999999999999em;"><span></span></span></span></span></span></span></span></span></span>，且为稳定排序。</p>
<p>其实通过我们上面的动图发现，当排到第4轮的时候，实际上整个列表就已经是有序的了，那么接下来的几轮，就是在浪费时间和资源。那么既然如此，有没有优化的方案呢？</p>
<p>当然是有的。</p>
<h1 id="冒泡排序优化版鸡尾酒排序">冒泡排序优化版：鸡尾酒排序</h1>
<p>我们所设想的，应该是这样：</p>
<img src="https://s2.ax1x.com/2020/02/13/1qGs1I.gif" alt="冒泡优化" style="zoom:67%;" />
<p>这个思路也很好实现。只需要设一个变量用来做标记，当某一次遍历的时候，一个元素都没有替换，那么就可以视为已经有序，后面的遍历就全省了。</p>
<p>代码实现如下：</p>
<p>C:</p>
<pre><code class="language-c">#include &lt;stdio.h&gt;
void sort(int arr[])
{
    for (int i = 0; i &lt; sizeof(arr)/sizeof(arr[0]) - 1; i++)
    {
        int flag = 1;//设置标记，每轮循环都初始化为1
        for(int j = 0; j &lt; sizeof(arr)/sizeof(arr[0]) - 1 - i; j++)
        {
            int temp = 0;
            if (arr[j] &gt; arr[j + 1])
            {
                temp = arr[j];
                arr[j] = arr[j + 1];
                arr[j + 1] = temp;
                flag = 0;//当发生元素交换的时候，将其改变为0
            }
        }
        if (flag)//当标记为真。即为1的时候，跳出循环
        {
            break;
        }
    }
}
</code></pre>
<p>Java:</p>
<pre><code class="language-java">public static void sort(int arr[]){
    for( int i = 0;i &lt; arr.length - 1 ; i++ ){
        boolean flag = true;//设置布尔变量，每轮循环初始化为真
        for( int j = 0;j &lt; arr.length - 1 - i ; j++ ){
            int temp = 0;
            if(arr[j] &lt; arr[j + 1]){
                temp = arr[j];
                arr[j] = arr[j + 1];
                arr[j + 1] = temp;
                flag = false;//有变量交换，就更改为假
            }
        }
        if(flag){//若一轮循环中没有改变变量，则跳出循环
            break;
        }
    }
}
</code></pre>
<p>Python:</p>
<pre><code class="language-python">def sort(arr):
    for i in range(len(arr)):
        flag = True #此处设置标记
        for j in range(len(arr) - i):
            if arr[j] &gt; arr[j + 1]:
                arr[j], arr[j + 1] = arr[j + 1], arr[j]
                flag = False #若有元素被交换，则更改标记
        if flag: #若一轮中没有任何变量被交换，则跳出循环
            break
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Python序列、列表及其方法]]></title>
        <id>https://harriswilde.github.io/post/NEar5wUsO</id>
        <link href="https://harriswilde.github.io/post/NEar5wUsO">
        </link>
        <updated>2020-02-11T13:40:02.000Z</updated>
        <content type="html"><![CDATA[<p>在上一节里面我们讲到了变量。但是，生活中也并不是哪里的数据都适合使用变量来存储。比如，一些成堆出现的数据。那么，本节就要引入一个新的概念：<strong>数据结构</strong>。</p>
<p>所谓数据结构，实际上就是通过某种方式（比如给元素编号），组织在一起的数据集合。在Python中，最基本的数据结构就是<strong>序列(sequence)</strong>。序列中的每一个元素都被分配一个序号，也就是元素的位置，称之为<strong>索引</strong>。但是，Python的索引是<strong>从0开始</strong>，而不是我们习惯的从1开始。</p>
<p>Python包括6中内建序列：列表(list)，元组(tuple)，字符串(string)，Unicode字符串(Unicode string)，buffer对象和xrange对象。本节只讨论<strong>列表</strong>和<strong>元组</strong>。</p>
<p>另外，序列中的元素也可以是一个序列，如：</p>
<pre><code class="language-python">&gt;&gt;&gt; edward = ['Edward Gumby', 42]
&gt;&gt;&gt; john = ['John Smith', 50]
&gt;&gt;&gt; database = [edward, john]
&gt;&gt;&gt; database
[['Edward Gumby', 42], ['John Smith', 50]]
</code></pre>
<h1 id="通用序列操作">通用序列操作</h1>
<p>所有下序列类型都可以进行某些特定的操作。包括<strong>索引(indexing)</strong>，<strong>分片(slicing)</strong>，<strong>加(adding)</strong>，<strong>乘(multiplying)</strong>，<strong>成员资格</strong>以及<strong>迭代(iteration，本节不讲)</strong>。除此之外，Python还有计算序列长度，找出最大最小元素等内建函数。</p>
<h2 id="索引">索引</h2>
<p>通过元素的编号来访问元素(<strong>从0开始，谨记！</strong>)：</p>
<pre><code class="language-python">&gt;&gt;&gt; name = 'TechZone'
&gt;&gt;&gt; name[0]
'T'
&gt;&gt;&gt; name[5]
'o'
</code></pre>
<p>由于是从0开始，于是索引0对应的就是第一个元素，索引6就是第五个元素。</p>
<p>当然，如果你不希望把这个序列赋值给一个变量，也可以直接进行操作：</p>
<pre><code class="language-python">&gt;&gt;&gt; 'TechZone'[5]
'o'
</code></pre>
<p>亦或许，你想把序列中某一个元素赋值给一个变量，也是可以的：</p>
<pre><code class="language-python">&gt;&gt;&gt; letter = 'TechZone'[5]
&gt;&gt;&gt; letter
'o'
</code></pre>
<p>如果这个序列很长，也可以倒着数：</p>
<pre><code class="language-python">&gt;&gt;&gt; 'Hello'[-1] #代表从结尾开始数的第一个
'o'
</code></pre>
<h2 id="分片">分片</h2>
<p>和索引一样，分片是用来访问一段元素的。比如我想一次性访问序列的第3到第6个元素：</p>
<pre><code class="language-python">&gt;&gt;&gt; name = 'TechZone'
&gt;&gt;&gt; name[2:6]
'chZo'
</code></pre>
<p>需要注意的是，起始元素（冒号左边）是包含在内的，而终止元素（冒号右边）是不包含在内的。因此<code>name[2:6]</code>实际上等价于<code>name[2] + name[3] + name[4] + name[5]</code> 。</p>
<p>如果我们要访问最后的三个元素怎么办呢？</p>
<p>当然可以使用常规的方法：</p>
<pre><code class="language-python">&gt;&gt;&gt; name[5:8]
'one'
</code></pre>
<p>如果我们要从结尾开始访问呢？</p>
<pre><code class="language-python">&gt;&gt;&gt; name[-3:-1]
'on'
</code></pre>
<p>由于终止元素不包含在分片里面，于是后面我们就访问不到。</p>
<p>改改试试：</p>
<pre><code class="language-python">&gt;&gt;&gt; name[-3:0]
''
</code></pre>
<p>什么都没有返回！为什么会这样呢？</p>
<p>因为<code>[0]</code>其实比<code>[-3]</code>更先出现。那么起始元素比终止元素还大，从数学的角度来说，就是<strong>空集</strong>了。</p>
<p>难道真的没有办法这样访问吗？</p>
<p>并不是，看看这样：</p>
<pre><code class="language-python">&gt;&gt;&gt; name[-3:]
'one'
</code></pre>
<p>把终止元素的位置留空，那么Python就会自动认为你要一直访问到最后元素，于是就把这个问题巧妙解决了。</p>
<p>当然，这个方法也可以这么用：</p>
<pre><code class="language-python">&gt;&gt;&gt; name[:3]
'Tec'
&gt;&gt;&gt; name[:]
'TechZone'
</code></pre>
<p>很好理解吧。</p>
<h2 id="分片的步长">分片的步长</h2>
<p>其实分片还有一个参数，我们刚刚并没有用，就是步长。步长的默认设置为1，意思就是挨个访问。比如：</p>
<pre><code class="language-python">&gt;&gt;&gt; name[1:4]
'ech'
</code></pre>
<p>实际上等价于：</p>
<pre><code class="language-python">&gt;&gt;&gt; name[1:4:1]
'ech'
</code></pre>
<p>如果步长改成2：</p>
<pre><code class="language-python">&gt;&gt;&gt; name[1:4:2]
'eh'
</code></pre>
<p>你会发现检索的单位变成了2（也就是说，中间会跳过一个元素）</p>
<p>也许这么看，就好理解了：</p>
<pre><code class="language-python">&gt;&gt;&gt; nums = [1,2,3,4,5,6,7,8,9,10]
&gt;&gt;&gt; nums[::1]
[1, 2, 3, 4, 5, 6, 7, 8, 9, 10]
&gt;&gt;&gt; nums[::2]
[1, 3, 5, 7, 9]
&gt;&gt;&gt; nums[::3]
[1, 4, 7, 10]
&gt;&gt;&gt; nums[::4]
[1, 5, 9]
</code></pre>
<p>当然，步长不能够为0，但是可以为负数（倒过来检索）：</p>
<pre><code class="language-python">&gt;&gt;&gt; nums[::-1]
[10, 9, 8, 7, 6, 5, 4, 3, 2, 1]
&gt;&gt;&gt; nums[::-2]
[10, 8, 6, 4, 2]
&gt;&gt;&gt; nums[::-3]
[10, 7, 4, 1]
&gt;&gt;&gt; nums[::-4]
[10, 6, 2]
</code></pre>
<h2 id="序列运算">序列运算</h2>
<h3 id="相加">相加</h3>
<pre><code class="language-python">&gt;&gt;&gt; [1,2,3]+[4,5,6]
[1, 2, 3, 4, 5, 6]
&gt;&gt;&gt; 'TechZone'+'Harris'
'TechZoneHarris'
&gt;&gt;&gt; [1,2,3]+'Harris'
'''
Traceback (most recent call last):
  File &quot;&lt;pyshell#35&gt;&quot;, line 1, in &lt;module&gt;
    [1,2,3]+'Harris'
TypeError: can only concatenate list (not &quot;str&quot;) to list
'''
</code></pre>
<p>相同类型的序列相加，实际上就是拼接起来。但是不同类型的序列是不能够相加的。</p>
<h3 id="乘法">乘法</h3>
<pre><code class="language-python">&gt;&gt;&gt; 'Harris' * 5
'HarrisHarrisHarrisHarrisHarris'
&gt;&gt;&gt; [1,2] * 10
[1, 2, 1, 2, 1, 2, 1, 2, 1, 2, 1, 2, 1, 2, 1, 2, 1, 2, 1, 2]
</code></pre>
<p>也很好理解。</p>
<h2 id="初始化">初始化</h2>
<p>如果我想创建一个列表，作为占位符（暂时不用，但是以后要用的），那么可以用一对方括号<code>[]</code>来表示。如果想创建一个拥有10个元素的列表占位符，那么该怎么办呢？</p>
<p>我们可以使用一些对于你来说没有意义的字符，比如0：</p>
<pre><code class="language-python">&gt;&gt;&gt; space = [0] * 10
&gt;&gt;&gt; space
[0, 0, 0, 0, 0, 0, 0, 0, 0, 0]
</code></pre>
<p>不过这样的作法其实并不是十分稳妥，因为没准你找不出来这样的特殊的数字。那么这里介绍一个Python内建值：<code>None</code>，表示什么都没有。那么我们的占位符就可以这样创建：</p>
<pre><code class="language-python">&gt;&gt;&gt; space = [None] * 10
&gt;&gt;&gt; space
[None, None, None, None, None, None, None, None, None, None]
</code></pre>
<h2 id="成员资格">成员资格</h2>
<p>判断一个值是否在序列中，我们可以使用<code>in</code>运算符。这种运算符不同于加减乘除，它会去检查我们的条件是否为真，若是，则返回<code>True</code>，反之则返回<code>False</code>。这样的运算符我们叫做<strong>布尔运算符</strong>，返回的这个值称之为<strong>布尔值</strong>。</p>
<pre><code class="language-python">&gt;&gt;&gt; user = ['Harris', 'Mary','Scott']
&gt;&gt;&gt; 'Harris' in user
True
&gt;&gt;&gt; 'Jack' in user
False
</code></pre>
<h2 id="长度-最值">长度、最值</h2>
<pre><code class="language-python">&gt;&gt;&gt; name = 'HarrisWilde'
&gt;&gt;&gt; len(name) #序列长度
11
&gt;&gt;&gt; len([1,2,3,4])
4
&gt;&gt;&gt; max([1,3,2,13,6,5,8]) #最大值
13
&gt;&gt;&gt; min([0.01, 0.02, 0.009, 0.015]) #最小值
0.009
</code></pre>
<h1 id="列表">列表</h1>
<p>使用<code>[]</code>括起来的序列集合就是列表。</p>
<h2 id="list函数">list函数</h2>
<p>使用<code>list</code>函数来将序列转换为列表。</p>
<pre><code class="language-python">&gt;&gt;&gt; list(&quot;TechZone&quot;)
['T', 'e', 'c', 'h', 'Z', 'o', 'n', 'e']
</code></pre>
<p>你还可以使用<code>join</code>函数来把序列中所有的元素(的字符串表示)合并为一个新的字符串：</p>
<pre><code class="language-python">&gt;&gt;&gt; seq = list(&quot;TechZone&quot;)
&gt;&gt;&gt; '-'.join(seq)
'T-e-c-h-Z-o-n-e'
</code></pre>
<h2 id="基本列表操作">基本列表操作</h2>
<h3 id="元素赋值">元素赋值</h3>
<p>为单个元素赋值：</p>
<pre><code class="language-python">&gt;&gt;&gt; x = [0] * 3
&gt;&gt;&gt; x[1] = 1
&gt;&gt;&gt; x
[0, 1, 0]
</code></pre>
<h3 id="删除元素">删除元素</h3>
<p>使用<code>del</code>函数：</p>
<pre><code class="language-python">&gt;&gt;&gt; x
[0, 1, 0]
&gt;&gt;&gt; del x[2]
&gt;&gt;&gt; x
[0, 1]
</code></pre>
<h3 id="分片赋值">分片赋值</h3>
<p>分片赋值可以实现一次性的批量赋值：</p>
<pre><code class="language-python">&gt;&gt;&gt; x = list(&quot;python&quot;)
&gt;&gt;&gt; x
['p', 'y', 't', 'h', 'o', 'n']
&gt;&gt;&gt; x[4:] = '12'
&gt;&gt;&gt; x
['p', 'y', 't', 'h', '1', '2']
</code></pre>
<p>而且还可以非等长替换：</p>
<pre><code class="language-python">&gt;&gt;&gt; x
['p', 'y', 't', 'h', '1', '2']
&gt;&gt;&gt; x[4:] = 'Lang'
&gt;&gt;&gt; x
['p', 'y', 't', 'h', 'L', 'a', 'n', 'g']
</code></pre>
<p>因此，也可以间接地增加或删除元素：</p>
<pre><code class="language-python">&gt;&gt;&gt; x[8:8] = '12' #在最后的不存在的位置增加
&gt;&gt;&gt; x
['p', 'y', 't', 'h', 'L', 'a', 'n', 'g', '1', '2']
&gt;&gt;&gt; x[4:8] = []
&gt;&gt;&gt; x
['p', 'y', 't', 'h', '1', '2']
</code></pre>
<h2 id="列表方法">列表方法</h2>
<h3 id="append">append</h3>
<p>此方法用于在列表后面追加元素：</p>
<pre><code class="language-python">&gt;&gt;&gt; nums = [1,2,3]
&gt;&gt;&gt; nums.append(4)
&gt;&gt;&gt; nums
[1, 2, 3, 4]
</code></pre>
<h3 id="count">count</h3>
<p>此方法统计某个元素在列表中出现的次数：</p>
<pre><code class="language-python">&gt;&gt;&gt; name = 'TechZone'
&gt;&gt;&gt; name.count('e')
2
</code></pre>
<h3 id="extend">extend</h3>
<p>此方法可以在末尾一次性追加多个值，并且更改原来的列表：</p>
<pre><code class="language-python">&gt;&gt;&gt; a = [1,2,3]
&gt;&gt;&gt; b = [4,5,6]
&gt;&gt;&gt; a.extend(b)
&gt;&gt;&gt; a
[1, 2, 3, 4, 5, 6]
&gt;&gt;&gt; b
[4, 5, 6]
</code></pre>
<h3 id="index">index</h3>
<p>此方法用于找出列表中某个值的第一个匹配元素的索引，若找不到则会返回错误：</p>
<pre><code class="language-python">&gt;&gt;&gt; name = 'TechZone'
&gt;&gt;&gt; name.index('e')
1
&gt;&gt;&gt; name.index('a')
'''
Traceback (most recent call last):
  File &quot;&lt;pyshell#13&gt;&quot;, line 1, in &lt;module&gt;
    name.index('a')
ValueError: substring not found
'''
</code></pre>
<h3 id="insert">insert</h3>
<p>此方法用于将对象插入到列表中：</p>
<pre><code class="language-python">&gt;&gt;&gt; nums = [1,2,3,5]
&gt;&gt;&gt; nums.insert(3, 'four')
&gt;&gt;&gt; nums
[1, 2, 3, 'four', 5]
</code></pre>
<h3 id="pop">pop</h3>
<p>此方法用于移除列表中的最后一个元素，并且返回被移除元素的值：</p>
<pre><code class="language-python">&gt;&gt;&gt; nums = [1,2,3,4]
&gt;&gt;&gt; nums.pop()
4
&gt;&gt;&gt; nums
[1, 2, 3]
</code></pre>
<blockquote>
<p>pop方法是唯一一个既能修改列表又能返回元素值（除了None）的列表方法</p>
</blockquote>
<h3 id="remove">remove</h3>
<p>remove方法用于移除列表中的某个值的首个匹配项：</p>
<pre><code class="language-python">&gt;&gt;&gt; words = ['a','friend','in','need','is','a','friend','indeed']
&gt;&gt;&gt; words.remove('friend')
&gt;&gt;&gt; words
['a', 'in', 'need', 'is', 'a', 'friend', 'indeed']
</code></pre>
<blockquote>
<p>remove是一个没有返回值的原位置改变方法。和pop恰恰相反。</p>
</blockquote>
<h3 id="reverse">reverse</h3>
<p>此方法将列表中的元素反向存放。</p>
<pre><code class="language-python">&gt;&gt;&gt; x = [1,2,3]
&gt;&gt;&gt; x.reverse()
&gt;&gt;&gt; x
[3, 2, 1]
</code></pre>
<p>此方法也是不返回值，和remove一样。</p>
<blockquote>
<p>如果需要对一个序列进行反向迭代，那么可以使用<code>reversed</code>函数。这个函数返回的是迭代器对象(iterator)。当然，使用<code>list</code>函数把返回的对象转换成列表也是可行的：</p>
<pre><code class="language-python">&gt;&gt;&gt; x = [1,2,3]
&gt;&gt;&gt; list(reversed(x))
[3, 2, 1]
</code></pre>
</blockquote>
<h3 id="sort">sort</h3>
<p>此方法用于对列表进行原地排序。所谓原地排序，就是更改原来的列表，而不是返回一个已排序的副本。</p>
<pre><code class="language-python">&gt;&gt;&gt; x = [4,5,3,6,2,5,1]
&gt;&gt;&gt; x.sort()
&gt;&gt;&gt; x
[1, 2, 3, 4, 5, 5, 6]
</code></pre>
<p>如果你想得到的恰恰是一个副本，想保留原来的列表，千万不要这么做：</p>
<pre><code class="language-python">&gt;&gt;&gt; x = [4,5,3,6,2,5,1]
&gt;&gt;&gt; y = x.sort() #错误的做法
&gt;&gt;&gt; print(y)
None
</code></pre>
<p>因为<code>sort</code>函数是不返回值的（实际上返回的是空值）。如果要实现这个功能，那么只能把原先x的副本赋给y，然后对y进行排序：</p>
<pre><code class="language-python">&gt;&gt;&gt; x = [4,5,3,6,2,5,1]
&gt;&gt;&gt; y = x
&gt;&gt;&gt; y.sort()
&gt;&gt;&gt; y
[1, 2, 3, 4, 5, 5, 6]
&gt;&gt;&gt; x
[1, 2, 3, 4, 5, 5, 6]
</code></pre>
<p>你会发现，为何原来的x也被改变了呢？</p>
<p>原来，简单的等号赋值，会让x和y指向同一个对象。那么，我们使用分片的方法来赋值，就可以巧妙地躲开这个问题：</p>
<pre><code class="language-python">&gt;&gt;&gt; x = [4,5,3,6,2,5,1]
&gt;&gt;&gt; y = x[:]
&gt;&gt;&gt; y.sort()
&gt;&gt;&gt; y
[1, 2, 3, 4, 5, 5, 6]
&gt;&gt;&gt; x
[4, 5, 3, 6, 2, 5, 1]
</code></pre>
<p>另外，还可以使用<code>sorted</code>函数来获取已排序副本：</p>
<pre><code class="language-python">&gt;&gt;&gt; x = [4,5,3,6,2,5,1]
&gt;&gt;&gt; y = sorted(x)
&gt;&gt;&gt; y
[1, 2, 3, 4, 5, 5, 6]
&gt;&gt;&gt; x
[4, 5, 3, 6, 2, 5, 1]
</code></pre>
<p><code>sorted</code>函数可以用于任何序列，但是总会返回一个列表：</p>
<pre><code class="language-python">&gt;&gt;&gt; sorted(&quot;TechZone&quot;)
['T', 'Z', 'c', 'e', 'e', 'h', 'n', 'o']
</code></pre>
<p>此函数默认是升序排序，如果我想降序，怎么办呢？</p>
<p>可以先排好序之后再反转，不过，有个更简便的方法：使用reverse参数。</p>
<pre><code class="language-python">&gt;&gt;&gt; x = [4,5,3,6,2,5,1]
&gt;&gt;&gt; x.sort(reverse = False) #默认情况，就是不写参数的情况
&gt;&gt;&gt; x
[1, 2, 3, 4, 5, 5, 6]
&gt;&gt;&gt; x.sort(reverse = True) #应用reverse参数
&gt;&gt;&gt; x
[6, 5, 5, 4, 3, 2, 1]
</code></pre>
<p>当然，此函数还可以进行更高级的排序，就是使用<code>key</code>参数。所谓key，笔者认为就是<strong>排序参考关键词</strong>。默认是按照值的大小（若是字符串则比较其对应编码的大小），使用此参数，就可以实现别的参考值。</p>
<p>比如我想根据字符串长度来排序：</p>
<pre><code class="language-python">&gt;&gt;&gt; string = ['TechZone','HarrisWIlde','Python','Programing']
&gt;&gt;&gt; string.sort(key=len)
&gt;&gt;&gt; string
['Python', 'TechZone', 'Programing', 'HarrisWIlde']
</code></pre>
<p>当然，两个参数也可以一起用：</p>
<pre><code class="language-python">&gt;&gt;&gt; string = ['TechZone','HarrisWIlde','Python','Programing']
&gt;&gt;&gt; string.sort(key=len, reverse=True)
&gt;&gt;&gt; string
['HarrisWIlde', 'Programing', 'TechZone', 'Python']
</code></pre>
<p>这两个参数对于<code>sorted()</code>都有效。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[C语言之函数（下）]]></title>
        <id>https://harriswilde.github.io/post/PS9G6tbW5</id>
        <link href="https://harriswilde.github.io/post/PS9G6tbW5">
        </link>
        <updated>2020-02-09T12:46:54.000Z</updated>
        <content type="html"><![CDATA[<h1 id="动态内存管理">动态内存管理</h1>
<p>我们知道，我们之前定义的变量、数组，都是我们事先定义好的，变量一旦被创建，就不能够再更改了。后来，C99标准又增加了变长数组，这一特性提高了我们程序对内存分配的灵活度，可是还是感觉不太灵活。那么有没有办法让它变得更灵活呢？</p>
<p>当然有，而且只需要几个库的函数就能够搞定。而这些库全部都包含在<code>stdlib.h</code>这个头文件中：</p>
<ul>
<li>malloc ——申请动态内存空间</li>
<li>free ——释放动态内存空间</li>
<li>calloc ——申请并初始化一系列内存空间</li>
<li>realloc ——重新分配内存空间</li>
</ul>
<h2 id="malloc">malloc</h2>
<p><code>malloc</code>函数用于申请动态内存空间：</p>
<pre><code class="language-c">#include &lt;stdlib.h&gt;
void* malloc(size_t size);
</code></pre>
<p><code>malloc</code>函数向系统申请分配<code>size</code>个字节的内存空间，并返回一个指向这块空间的指针。不过，申请的这块空间并没有被初始化，因此上面的数据是随机的（和局部变量一样）。</p>
<p>如果函数调用成功，那么会返回一个指向被申请的内存空间的指针，由于返回的是void类型的指针，所以它可以被转化成任何类型的数据。如果函数调用失败，返回值就是<code>NULL</code>。另外，如果<code>size</code>参数设置成0，那么返回值也有可能是0，但这种情况下并不一定代表调用失败。</p>
<pre><code class="language-c">//Exmple 01
#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;

int main(void)
{
    int* ptr;
    ptr = (int*)malloc(sizeof(int));
    if (ptr == NULL)
    {
        printf(&quot;分配内存失败！\n&quot;);
        exit(1);//程序异常退出
    }
    printf(&quot;请输入一个整数：&quot;);
    scanf(&quot;%d&quot;, ptr);
    printf(&quot;你输入的数据是：%d\n&quot;, *ptr);
    return 0;
}
</code></pre>
<p>运行结果为：</p>
<pre><code>请输入一个整数：12
你输入的数据是：12
</code></pre>
<p>这段代码的意思是，使用<code>malloc</code>函数申请一块int类型的空间，然后使用<code>ptr</code>指针来指向它，然后将用户输入的数据存储在这块空间里面。</p>
<p>不过，<code>malloc</code>函数申请的空间是在堆上，那么这就意味这它不会自动释放，直到程序执行结束。所以在使用完变量之后务必释放内存，否则很有可能造成内存泄漏。</p>
<h2 id="free">free</h2>
<p>释放动态内存空间需要用<code>free</code>函数，函数原型：</p>
<pre><code class="language-c">#include &lt;stdlib.h&gt;
...
void free(void* ptr);
</code></pre>
<p>释放的空间必须要是<code>malloc</code> <code>calloc</code> <code>realloc</code>函数申请的，否则将会导致未定义行为。如果<code>ptr</code>的参数是<code>NULL</code>，那么就不执行任何操作。</p>
<p>这个函数实际上并不会修改<code>ptr</code>参数的值，所以调用后它仍然能够指向原来的地方，只不过变为非法空间罢了。</p>
<p>有人会说了，现代计算机内存都不小，动辄16GB甚至更多，那么这个是否就用不上了呢？</p>
<p>答案当然是否定的。不信你试试下面的这个程序：</p>
<pre><code class="language-c">//Infinity malloc
#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;

int main(void)
{
    while (1)
    {
        malloc(1024);
    }
    return 0;
}
</code></pre>
<p>你会发现内存占用会飙升。这种情况就叫做<strong>内存泄漏</strong>。我们申请的空间，在使用完后应该要立即释放，不然很有可能会造成不堪设想的后果。</p>
<pre><code class="language-c">//Exmple 01 - Edited
#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;

int main(void)
{
    int* ptr;
    ptr = (int*)malloc(sizeof(int));
    if (ptr == NULL)
    {
        printf(&quot;分配内存失败！\n&quot;);
        exit(1);//程序异常退出
    }
    printf(&quot;请输入一个整数：&quot;);
    scanf(&quot;%d&quot;, ptr);
    printf(&quot;你输入的数据是：%d\n&quot;, *ptr);
    ////释放内存////
    free(ptr);
    return 0;
}
</code></pre>
<p>因此，在使用完申请的内存之后应该要手动释放。</p>
<p>我们再来看一个例子：</p>
<pre><code class="language-c">//Example 02
#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;

int main(void)
{
    int* ptr;
    int num = 123;
    ptr = (int*)malloc(sizeof(int));
    if (ptr == NULL)
    {
        printf(&quot;分配内存失败！\n&quot;);
        exit(1);
    }
    printf(&quot;请输入一个整数：&quot;);
    scanf(&quot;%d&quot;, ptr);
    printf(&quot;你输入的整数是：%d\n&quot;, *ptr);
    ptr = &amp;num;
    printf(&quot;你输入的整数是：%d\n&quot;, *ptr);
    free(ptr);
    return 0;
}
</code></pre>
<p>结果如下：</p>
<pre><code>请输入一个整数：10
你输入的整数是：10
你输入的整数是：123
HEAP[ConsoleApplication2.exe]: Invalid address specified to RtlValidateHeap( 00D20000, 0096F8E0 )
ConsoleApplication2.exe 已触发了一个断点。
</code></pre>
<p>程序被中断了。</p>
<p>刚开始，我们使用<code>malloc</code>函数申请了一段内存，并且只有<code>ptr</code>才知道这块内存的地址。所以后面我们更改了<code>ptr</code>后，这块内存就泄露了。后面我们尝试释放<code>ptr</code>，却发现，现在<code>ptr</code>所指向的变量是一个局部变量，不允许手动释放。这种情况的泄露一定要特别注意。</p>
<h2 id="申请任意尺寸的内存空间">申请任意尺寸的内存空间</h2>
<p><code>malloc</code>还可以用于申请一块任意尺寸的内存空间。对于后者，由于申请的空间是连续的，所以经常用数组的方式来进行索引。</p>
<p>还记得在<a href="http://www.techzone.ltd/post/CArray/">《C语言之数组》</a>里我们讲过，Visual Studio和C99之前的编译器是不支持可变长数组的。如果恰好碰到这种环境，怎么办呢？刚好可以用这种方式来曲线救国：</p>
<pre><code class="language-c">//Example 03
#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
 int main(void)
 {
     int* array;
     int n;
     printf(&quot;请输入你要创建的数组元素个数：&quot;);
     scanf(&quot;%d&quot;, &amp;n);
     array = (int*)malloc(sizeof(int) * n);
     for (int i = 0; i &lt; n; i++)
     {
         array[i] = i;
         printf(&quot;%d\n&quot;, array[i]);
     }
     return 0;
 }
</code></pre>
<p>运行结果如下：</p>
<pre><code>//Consequence 03
请输入你要创建的数组元素个数：10
0
1
2
3
4
5
6
7
8
9
</code></pre>
<p>多维数组也一样可以（本质上也是线性存储）：</p>
<pre><code class="language-c">//Example 04
#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;

int main(void)
{
    int** array;
    int n, m;
    scanf(&quot;%d %d&quot;, &amp;n, &amp;m);//n为几个大的数组，m是一个小数组中有几个元素
    array = (int**)malloc(sizeof(int*) * n);//分配行数
    for (int i = 0; i &lt; n; i++)
    {
        array[i] = (int*)malloc(sizeof(int) * m);//分配各个元素
    }
    for (int i = 0; i &lt; n; i++)
    {
        for (int j = 0; j &lt; m; j++)
        {
            array[i][j] = j;
            printf(&quot;%d &quot;, array[i][j]);
        }
        printf(&quot;\n&quot;);
    }
    return 0;
}
</code></pre>
<p>运行结果为：</p>
<pre><code>//Consequence 04
3 4
0 1 2 3
0 1 2 3
0 1 2 3
</code></pre>
<p>由于<code>malloc</code>不会初始化申请的内存空间，所以需要字节进行初始化。当然可以写一个循环，像我们刚刚那样，不过还是略显繁琐。</p>
<p>好在，标准库提供了更加高效的函数，包含在<code>string.h</code>头文件中：</p>
<ul>
<li>memset: 使用一个常量字节填充内存空间</li>
<li>memcpy: 复制内存空间</li>
<li>memmove: 移动内存空间</li>
<li>memcmp: 比较内存空间</li>
<li>memchr: 在内存空间中搜索一个字符</li>
</ul>
<p>函数原型如下：</p>
<pre><code class="language-c">#include &lt;string.h&gt;
void* memset(void* s, int c, size_t n);
void* memcpy(void* dest, const void* src, size_t n);
void* memmove(void* dest, const void* src, size_t n);
int memcmp(const void* s1, const void* s2, size_t n);
void* memchr(const void* s, int c, size_t n);
</code></pre>
<p>使用<code>memset</code>函数初始化空间：</p>
<pre><code class="language-c">//Example 05
#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;string.h&gt;

#define N 10

int main(void)
{
    int* ptr = NULL;
    ptr = (int*)malloc(N * sizeof(int));
    if (ptr == NULL)
    {
        exit(1);
    }
    memset(ptr, 0, N * sizeof(int));
    for (int i = 0; i &lt; N; i++)
    {
        printf(&quot;%d &quot;, ptr[i]);
    }
    putchar('\n');
    free(ptr);
    return 0;
}
</code></pre>
<p>运行结果为：</p>
<pre><code>//Consequence 05
0 0 0 0 0 0 0 0 0 0
</code></pre>
<p>如果觉得这样太麻烦，那么我们就可以使用<code>calloc</code>来一步到位。</p>
<h2 id="calloc">calloc</h2>
<p><code>calloc</code>函数用于申请并初始化一系列内存空间：</p>
<pre><code class="language-c">#include &lt;stdlib.h&gt;
...
void* calloc(size_t nmemb, size_t size);
</code></pre>
<p><code>calloc</code>函数在内存中动态地申请nmemb个长度为size的连续内存空间（即申请的总空间尺寸为<code>nmemb*size</code>），这些内存空间全部被初始化成0。</p>
<p>如果函数调用成功，会返回一个指向申请的内存空间的指针，由于返回类型是void指针，因此可以被转换成任何类型的数据。如果函数调用失败，返回值是<code>NULL</code>。如果<code>nmemb</code>或<code>size</code>参数设置为0，返回值也可能是<code>NULL</code>，但这不一定意味着函数调用失败。</p>
<h2 id="realloc">realloc</h2>
<p>有时候可能需要对原来分配的空间进行拓展，但是没办法确保两次申请的空间是线性连续的。所以需要先申请一个足够大的空间，再把数据搬运过去。</p>
<p>当然，这样确实可以，但是手动写代码的话感觉有些太繁琐了。使用<code>realloc</code>函数就可以帮我们完成这一系列的操作：</p>
<pre><code class="language-c">#include &lt;stdlib.h&gt;
...
void* realloc(void* ptr, size_t size);
</code></pre>
<p>以下几点是需要注意的：</p>
<ul>
<li><code>realloc</code>函数将<code>ptr</code>指向的内存空间大小修改为<code>size</code>字节</li>
<li>如果重新分配的内存比原来的大，则旧数据不会发生改变；若比原来小，数据有可能会丢失，慎用！</li>
<li>该函数会移动内存空间并返回新的指针</li>
<li>如果<code>ptr</code>的参数是<code>NULL</code>，那么调用该函数就相当于调用<code>malloc(size)</code></li>
<li>如果<code>size</code>的参数为0，并且<code>ptr</code>的参数不为<code>NULL</code>，那么调用该函数就相当于调用<code>free(ptr)</code></li>
<li>除非<code>ptr</code>的参数为<code>NULL</code>，否则<code>ptr</code>的值必须由先前调用的<code>malloc</code> <code>calloc</code> <code>realloc</code>函数返回</li>
</ul>
<p>下面这个程序，不断接受用户输入整数，直到用户输入-1结束，然后将所有的数据输出：</p>
<pre><code class="language-c">//Example 06
#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;

int main(void)
{
    int num;
    int count = 0;
    int* ptr = NULL;//这里必须初始化为NULL
    do
    {
        printf(&quot;请输入一个整数（输入-1表示结束：）&quot;);
        scanf(&quot;%d&quot;, &amp;num);
        count++;
        ptr = (int*)realloc(ptr, count * sizeof(int));
        if (ptr == NULL)
        {
            exit(1);
        }
        ptr[count - 1] = num;
    } while (num != -1);
    printf(&quot;输入的整数分别是：&quot;);
    for (int i = 0; i &lt; count - 1; i++)
    {
        printf(&quot;%d &quot;, ptr[i]);
    }
    printf(&quot;\n&quot;);
    free(ptr);
    return 0;
}
</code></pre>
<p>运行结果为：</p>
<pre><code>//Consequence 06
请输入一个整数（输入-1表示结束：）5
请输入一个整数（输入-1表示结束：）23
请输入一个整数（输入-1表示结束：）4
请输入一个整数（输入-1表示结束：）51
请输入一个整数（输入-1表示结束：）22
请输入一个整数（输入-1表示结束：）31
请输入一个整数（输入-1表示结束：）1
请输入一个整数（输入-1表示结束：）9
请输入一个整数（输入-1表示结束：）-1
输入的整数分别是：5 23 4 51 22 31 1 9
</code></pre>
<h1 id="c语言的内存布局">C语言的内存布局</h1>
<img src="https://s2.ax1x.com/2020/02/09/1hG8D1.png" alt="C语言的内存布局" style="zoom:33%;" />
<p>根据内存由低到高分别做如下划分：</p>
<ul>
<li>代码段(text segment)</li>
<li>数据段(initialized data segment)</li>
<li>BSS段(BSS segment / Uninitialized data segment)</li>
<li>栈(stack)</li>
<li>堆(heap)</li>
</ul>
<h2 id="代码段">代码段</h2>
<p>代码段通常用来存放程序执行代码的一块内存区域。这部分区域的大小再程序运行前就已经确定，并且内存区域通常值属于只读。在代码段中，也有可能包含一些只读的常数变量，如字符串常量等等。</p>
<h2 id="数据段">数据段</h2>
<p>数据段通常用来存放已经初始化的全局变量和局部静态变量。</p>
<h2 id="bss段">BSS段</h2>
<p>BSS段通常用来存放程序中为初始化的全局变量的一块内存区域。BSS是英文Black Started by Symbol的简称。这个区段中的数据在程序运行前将被自动初始化为0。</p>
<h2 id="堆">堆</h2>
<p>前面学习的动态内存管理，实际上就是在这里面进行的。堆里面主要放一些动态的内存段，能够扩展和缩小。</p>
<h2 id="栈">栈</h2>
<p>大家平时所听到的<strong>堆栈</strong>这个词，实际上就是指的栈。栈是函数执行的内存区域，通常和堆共享同一片区域。堆和栈是C语言运行时的重要元素之一。而它们之间也有很大的不同；<strong>堆</strong>由程序员手动申请，而<strong>栈</strong>由系统自动分配；<strong>堆</strong>由程序员手动释放，而<strong>栈</strong>由系统自动释放；<strong>堆</strong>的生存周期由程序员来决定，并且不同函数之间<strong>可以</strong>自由访问，而<strong>栈</strong>的生存周期由函数调用开始到函数返回时结束，函数之间的局部变量<strong>不可以</strong>互相访问。</p>
<h1 id="高级宏定义">高级宏定义</h1>
<p>作为C语言的三大预处理命令之一，宏定义的作用时替换。但是，宏定义就算再复杂，也只是替换不做任何的计算或者表达式求解。</p>
<h2 id="不带参数的宏定义">不带参数的宏定义</h2>
<p>这种就是我们常见的直接替换：</p>
<pre><code class="language-c">#define PI 3.14
</code></pre>
<blockquote>
<p>注意：</p>
<ul>
<li>为了和普通变量区分，宏的名字一般约定为全大写</li>
<li>宏定义只是简单的替换，且是在编译前就处理好了，所以编译器不会对宏定义的语法进行检查</li>
<li>宏定义的作用范围是从定义开始到程序的结束</li>
<li>可以使用#undef命令中止宏定义的作用域</li>
<li>宏定义允许嵌套(在宏定义中使用已定义的宏)</li>
</ul>
</blockquote>
<h2 id="带参数的宏定义">带参数的宏定义</h2>
<p>C语言的宏定义可以带参数。和函数类似，在宏定义里出现的叫做<strong>形参</strong>，而在调用的时候实际传递的叫做 <strong>实参</strong>。</p>
<p>如：</p>
<pre><code class="language-c">#define MAX(x, y) (((x) &gt; (y)) ? (x) : (y))
</code></pre>
<p>这个就是用来比较x和y哪个更大：</p>
<pre><code class="language-c">//Example 07
#include &lt;stdio.h&gt;
#define MAX(x, y) (((x) &gt; (y)) ? (x) : (y))

int main(void)
{
    int x, y;
    printf(&quot;请输入两个整数：&quot;)；
    scanf(&quot;%d %d&quot;, &amp;x, &amp;y);
    printf(&quot;%d更大！&quot;, MAX(x, y));
    return 0;
}
</code></pre>
<p>运行结果如下：</p>
<pre><code>//Consequence 08
请输入两个整数：3 5
5更大！
</code></pre>
<p>另外，参数的最外层建议加上一个小括号来确保优先级，不然很可能会出现隐式的bug。</p>
<h1 id="内联函数">内联函数</h1>
<p>由于预编译命令在编译之前就已经处理好了。而函数每次的调用却还要申请栈空间。的确，使用含参宏定义效率确实要更高。</p>
<p>不过，有的时候却会出现一些bug，比如：</p>
<pre><code class="language-c">//Example 09
#define SQUARE(x) ((x) * (x))
#include &lt;stdio.h&gt;

int main(void)
{
    int i = 1;
    while (i &lt;= 10)
    {
        printf(&quot;%d的平方根是%d\n&quot;, i-1, SQUARE(i++));
    }
    return 0;
}
</code></pre>
<p>结果为：</p>
<pre><code>//Consequence 09
2的平方根是1
4的平方根是9
6的平方根是25
8的平方根是49
10的平方根是81
</code></pre>
<p>这是怎么回事呢？</p>
<p>我们刚刚说过，宏定义只是简单的替换。那么<code>SQUARE(i++)</code>最终会被替换为<code>((i++) * (i++))</code>，那么没调用一次宏，就要自增两次。</p>
<p>那么我又想用宏定义，却又向避开这个bug，怎么办呢？</p>
<p>就是调用内联函数：</p>
<pre><code class="language-c">inline int square(int);
</code></pre>
<p>和普通的函数定义一样，只不过在前面加上<code>inline</code>即可。指定一个函数为内联函数，那么系统就会像处理宏定义那样，将整个函数直接在<code>main</code>函数中展开。</p>
<p>不过，内联函数也不是万能的。虽然节省了运行的时间，但是每个地方都要进行替换，实际上也增加了编译的时间。再者，其实现在的编译器也很聪明，对内联函数也有一套像寄存器变量那样的优化机制，并不是所有你声明的内联函数都能够成为内联函数，而有些普通函数也有可能会成为内联函数。</p>
<h1 id="一些小技巧">一些小技巧</h1>
<h2 id="和">#和##</h2>
<p>在含参宏定义中，#运算符后面应该跟一个参数，预处理器会把这个参数转换成一个字符串：</p>
<pre><code class="language-c">//Example 10
#define STR(s) # s
#include &lt;stdio.h&gt;

int main(void)
{
    printf(&quot;%s\n&quot;, STR(TechZone));
    return 0;
}
</code></pre>
<p>结果为：</p>
<pre><code>//Consequence 10
TechZone
</code></pre>
<p>虽然笔者传入的不是字符串形式，但是<code>#</code>将其变为了字符串，因此可以直接以<code>%s</code>的形式输出。</p>
<p>并且传入字符中，所有的保留字符都会做转义处理，比如<code>\</code>会被替换为<code>\\</code>。存在多个空白字符的时候，会被替换为一个空格。</p>
<p>而##运算符被成为连接运算符，如：</p>
<pre><code class="language-c">//Example 11
#define TOGETHER(x, y) x ## y
#include &lt;stdio.h&gt;
int main(void)
{
    printf(&quot;%d\n&quot;, TOGETHER(5, 20));
    return 0;
}
</code></pre>
<p>结果为：</p>
<pre><code>//Consequence 11
520
</code></pre>
<h2 id="可变参数">可变参数</h2>
<p>之前学习了如何让函数支持可变参数，带参数的宏定义也支持使用可变参数：</p>
<pre><code class="language-c">#define SHOWLIST(...) printf(#__VA_AGES__)
</code></pre>
<p>如：</p>
<pre><code class="language-c">//Example 12
#define SHOWLIST(...) printf(#__VA_AGES__)
#include &lt;stdio.h&gt;

int main(void)
{
    SHOWLIST(TechZone, HarrisWilde, C);
    return 0;
}
</code></pre>
<p>由于在VS2019下无法支持编译，这次的结果使用Linux下的GCC来执行：</p>
<pre><code>//Consequence 12 in GCC
TechZone, HarrisWilde, C
</code></pre>
<p>可变参数是允许存在空参数的，如果是空参数，则##前面的逗号也会一起被去掉，避免导致参数数量不一致：</p>
<pre><code class="language-c">//Example 13
#define PRINT(format, ...) printf(#format, ##__VA_AGES__)

int main(void)
{
    PRINT(num = %d\n, 10);
    PRINT(Hello, world!\n);
    return 0;
}
</code></pre>
<p>结果为：</p>
<pre><code>//Consequence 13 in GCC
num = 10
Hello, world!
</code></pre>
<p>函数的基础知识到这里就结束了，希望对大家有所帮助！</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[C语言之函数（中）]]></title>
        <id>https://harriswilde.github.io/post/IKKYqSXMf</id>
        <link href="https://harriswilde.github.io/post/IKKYqSXMf">
        </link>
        <updated>2020-02-06T13:47:02.000Z</updated>
        <content type="html"><![CDATA[<h1 id="局部变量和全局变量">局部变量和全局变量</h1>
<h2 id="局部变量">局部变量</h2>
<p>在我们学习函数之前，我们所理解的变量，只不过是在内存中开辟一个存储数据的位置，并取了个我们好懂的名字而已。因为我们之前写的程序只有一个主函数，因此我们觉得，定义了一个变量，就应该可以随时调用。但是学习了函数之后，我们发现，不同函数之间的变量是不能够相互调用的，这又是为什么呢？</p>
<p>比如：</p>
<pre><code class="language-c">//Example 01
#include &lt;stdio.h&gt;
int main(void)
{
    int i = 100;
    printf(&quot;Before i = %d\n&quot;, i);
    for (int i = 0; i &lt;= 10; i++)//再定义一个局部变量i
    {
        printf(&quot;i = %d\n&quot;, i);
    }
    printf(&quot;After i = %d\n&quot;, i);
    return 0;
}
</code></pre>
<p>结果如下：</p>
<pre><code>//Consequence 01
Before i = 100
i = 0
i = 1
i = 2
i = 3
i = 4
i = 5
i = 6
i = 7
i = 8
i = 9
i = 10
After i = 100
</code></pre>
<p>我们可以看到，我们在<code>for</code>函数里和<code>main</code>函数里都有一个<code>i</code>变量，但是我们在<code>for</code>函数里面定义的<code>i</code>却对外层函数不构成影响。</p>
<p>一般来说，变量名应该是不能够重复的。但是，由于我们定义的位置不一样（在不同的函数中），所以变量名重复又变得合法起来。这就是局部变量的特性：<strong>只能在自己的领域里面发挥作用</strong>。</p>
<p>像我们刚刚定义的<code>for</code>一样，C语言允许随处定义变量。也就是说，变量在需要用到的时候再定义。这样也符合我们的思维方式。因为当程序很庞大的时候，没有人愿意翻到顶上去看一个变量的注释。</p>
<h2 id="全局变量">全局变量</h2>
<p>既然有局部变量，那么全局变量也照样不可少。看下面的例子：</p>
<pre><code class="language-c">//Example 02
#include &lt;stdio.h&gt;
void f1(void);
void f2(void);
void f3(void);
int a = 0;//定义一个全局变量

void f1(void)
{
    a++;
}

void f2(void)
{
    a++;
}

void f3(void)
{
    a++;
}

int main(void)
{
    f1();
    f2();
    f3();
    printf(&quot;a = %d\n&quot;, ++a);
    return 0;
}
</code></pre>
<p>运行结果如下：</p>
<pre><code>//Consequence 02
a = 4
</code></pre>
<p>我们发现，全局变量在每一个函数里面的更改都“有效”，也就是说，全局变量是贯穿整个程序始终的。</p>
<p>有的小伙伴可能会好奇，如果全局变量和局部变量重名了，会发生什么呢？</p>
<p>那我们就来试试：</p>
<pre><code class="language-c">//Example 03
#include &lt;stdio.h&gt;
void f(void);
int a, b = 100;
void f(void)
{
    int b;
    a = 50; b = 101;
    printf(&quot;func, a = %d, b = %d\n&quot;, a, b);
}

int main(void)
{
    printf(&quot;Main, a = %d, b = %d\n&quot;, a, b);
    f();
    printf(&quot;Main, a = %d, b = %d\n&quot;, a, b);
}
</code></pre>
<p>运行结果如下：</p>
<pre><code>//Consequence 03
Main, a = 0, b = 100
func, a = 50, b = 101
Main, a = 50, b = 100
</code></pre>
<p>我们发现，名字叫<code>a</code>的变量只有全局变量，那么被赋值之后就等于在函数<code>f()</code>中赋的值。但是<code>b</code>就不一样了。在函数<code>f()</code>中，也有一个变量叫做<code>b</code>，那么此时编译器的做法是，在函数<code>f()</code>里先暂时屏蔽全局变量<code>b</code>，使用自己的局部变量。等走出了函数<code>f()</code>，局部变量被释放。</p>
<p>而我们还发现一个问题，我们可以直接输出没有被初始化的<code>a</code>！这也是全局变量的一个特点，不同于局部变量，全局变量在没有手动初始化的时候，会被系统自动初始化为<code>0</code>而不是像局部变量那样的很小的一个很奇怪的数。</p>
<p>另外，如果没有需要，尽量不要大量使用全局变量。因为全局变量的内存将会伴随着这个程序，直到程序执行完毕。如果大量使用全局变量的话，可能会造成内存占用过多等问题。这在嵌入式开发这种领域，内存空间寸土寸金，不当使用全局变量会导致资源的浪费。其次，全局变量会造成程序可读性变差。最后，全局变量会使得程序牵连性变强，牵一发而动全身的情况可能会再次出现。</p>
<p>因此全局变量虽然是个好东西，但也要谨慎使用。</p>
<h1 id="作用域和链接属性">作用域和链接属性</h1>
<p>在上一节，我们简单地了解了不同的变量，它能够有不同的作用范围，那么这个范围，就是我们所说的<strong>作用域</strong>。C语言的编译器一共能够确认4种不同的作用域：<code>代码块作用域</code> <code>文件作用域</code> <code>原型作用域</code> <code>函数作用域</code></p>
<h2 id="代码块作用域">代码块作用域</h2>
<pre><code class="language-c">//Example 04
#include &lt;stdio.h&gt;
int main(void)
{
    int i = 1;
    {
        int i = 2;
        printf(&quot;i = %d\n&quot;, i);
    }
    {
        printf(&quot;i = %d\n&quot;, i);
        int i = 3;
        printf(&quot;i = %d\n&quot;, i);
    }
    printf(&quot;i = %d\n&quot;, i);
    return 0;
}
</code></pre>
<p>运行结果如下：</p>
<pre><code>//Consequence 04
i = 2
i = 1
i = 3
i = 1
</code></pre>
<p>我们通常管一个大括号里面的语句叫做代码块，那么看这个程序，一个代码块里面的变量只能作用于所在的代码块里，超出了的就无效了。若存在代码块嵌套，那么优先内层代码块的变量。这就是<strong>代码块作用域</strong>。</p>
<p>当然，有一点需要说说，就是函数的形参也是代码块作用域，只能作用于函数定义代码块里面，即便它没有写在代码块里面。</p>
<h2 id="文件作用域">文件作用域</h2>
<p>在任何代码块之外定义的变量，都具有<strong>文件作用域</strong>。它们的作用域是从变量声明开始，一直到文件尾结束。另外，函数名也是文件作用域，因为函数名本身也在代码块之外。</p>
<h2 id="原型作用域">原型作用域</h2>
<p>原型作用域只适合那些在函数原型中声明的参数名。我们知道，在声明一个函数的时候，形参的名字是可以不用写的，只需要把类型写好就行了。但是，其实不妨可以试试写上名字，即便这个名字和正式定义的时候形参的名字不一样，也是没问题的（当然这样做毫无意义），这其实就是原型作用域在起作用。</p>
<h2 id="函数作用域">函数作用域</h2>
<p>函数作用域只适用于<code>goto</code>语句的标签，作用是将<code>goto</code>语句的标签限定在一个函数的内部，避免出现重名的标签。</p>
<h2 id="链接属性">链接属性</h2>
<p>简单来说，编译器将源代码转换成机器码的时候需要有两个步骤：<strong>编译</strong>和<strong>链接</strong>。</p>
<p>所谓编译，就是将我们写的源代码转换为机器码，而链接，就是将相关的库文件添加进来。比如我们在写程序的时候加入的头文件，在最终生成的时候就是要链接进来的。</p>
<p>我们知道，大型程序是由很多源文件构成的，那么在不同的文件中的同名标识符，编译器是入场处理的呢？</p>
<p>在C语言中，链接属性一共有以下3种：</p>
<ul>
<li>external(外部的)：多个文件中声明的同名标识符表示同一个实体</li>
<li>internal(内部的)：单个文件中声明的同名标识符表示同一个实体</li>
<li>none(无)：声明的同名标识符被当作独立不同的实体。比如，函数的局部变量。</li>
</ul>
<p>默认情况下，具备文件作用域的标识符拥有<code>external</code>属性，也就是说，这种标识符允许跨文件访问。使用<code>static</code>可以使原先拥有<code>external</code>属性的标识符变为<code>internal</code>属性。但是<code>static</code>只能修改具有文件作用域的标识符，并且是不可逆修改。</p>
<h1 id="生存期和存储类型">生存期和存储类型</h1>
<h2 id="生存期">生存期</h2>
<p>上一节我们用空间的角度去解释了不同的变量，但其实，还可以从时间的角度来分析。</p>
<p>C语言的变量通常有两种生存期，静态存储期(static storage duration)和自动存储期(automatic storage duration)。</p>
<p>具有文件作用域的变量具有静态存储期（如全局变量），函数名也有静态存储期。静态存储期的变量在程序执行的期间内将一直占据存储空间。</p>
<p>具有代码块作用域的变量通常具有自动存储期（如局部变量和形参），具有自动存储期的变量将在代码块执行完毕的时候释放内存。</p>
<h2 id="存储类型">存储类型</h2>
<p>变量的存储类型实际上是指存储变量值的内存类型。C语言提供了5种存储类型：<code>auto</code> <code>register</code> <code>static</code> <code>extern</code> <code>typedef</code></p>
<h3 id="1-自动变量">1. 自动变量</h3>
<p>在代码块中声明的变量默认就是自动变量(auto)。</p>
<pre><code class="language-c">//Example 05
#include &lt;stdio.h&gt;
int main(void)
{
    auto int a, b, c;
    return 0;
}
</code></pre>
<p>但是由于是默认存储类型，所以<code>auto</code>一般不写也完全没问题。函数中的形参、局部变量以及复合语句中定义的局部变量都具有自动变量。自动变量拥有代码块作用域、自动存储期和空链接属性。</p>
<h3 id="2-寄存器变量">2. 寄存器变量</h3>
<p>如果你学过汇编语言，或者对计算机的原理比较了解的话，一定没少听说<strong>寄存器</strong>这个词。寄存及就集成在CPU内部，因此它和CPU之间的交流几乎可以说没有延迟。</p>
<p>如果你申请了寄存器变量，那么就有可能被存储到寄存器里面去。当然，编译器也有自己的优化方案，它会在程序运行的时候权衡哪些变量更应该被放到寄存器的位置，因此，你的申请只是做一个参考而已。那么那些没有被放入寄存器的变量就会成为<strong>自动变量</strong>，所以，寄存器变量和自动变量在很多地方是一样的，也拥有代码块作用域、自动存储期和空链接属性。</p>
<p>但是，如果是寄存器变量的话，那么理论上就没法通过**取地址运算符&amp;**来获取地址了，因为我们知道这个是针对内存的。</p>
<pre><code class="language-c">//Example 06
#include &lt;stdio.h&gt;
int main(void)
{
    register int i = 100;
    printf(&quot;addr of i is %p\n&quot;, &amp;i);
    return 0;
}
</code></pre>
<p>但是VS可能对这种代码有优化，将变量转换成自动变量了：</p>
<pre><code>//Consequence 06 of Visual Studio 2019
addr of i is 00CFFE90
</code></pre>
<h3 id="3-静态局部变量">3. 静态局部变量</h3>
<p><code>static</code>用于描述具有文件作用域的变量或者函数时，表示将其链接属性从<code>external</code>修改成<code>internal</code>，它的作用范围就变成了仅当前文件可访问。如果<code>static</code>用于描述局部变量，那可就不太一样了。</p>
<p>默认情况下，局部变量是自动变量，具有自动存储期。如果使用了<code>static</code>来声明，那么就可以将局部变量指定为静态局部变量(static)。这使得局部变量具有静态存储期，所以它的生存期和全局变量一样。但是作用域依旧是局部变量，在别的函数中是无法访问这个局部变量的。</p>
<h3 id="4-extern">4.  extern</h3>
<p><code>extern</code>关键字告诉编译器这个变量或函数在别的地方已经定义过了，先在别的地方找找，不要急着报错。</p>
<p>通常情况下，这个关键词可以不写，但是为了程序更加完善，更加易读。在多人协作的时候，可以避免很多重名的问题。</p>
<h3 id="5-typedef">5.  typedef</h3>
<p><code>typedef</code>与其他四个存储类型的语义不同，<code>typedef</code>与内存存储无关，用于为数据类型定义一个新名字。</p>
<h1 id="递归">递归</h1>
<p>虽然递归隶属于算法的范畴，但是几乎所有的程序语言教程，都会讲到这个知识点。因为，递归是一个非常好的编程思路，有时候一个很难解决的问题，使用递归就可以巧妙地搞定。</p>
<h2 id="什么是递归">什么是递归</h2>
<p>递归说白了，就是函数在执行的时候，调用自身的行为。其实递归在生活中有很多实例，比如：</p>
<ol>
<li>
<p>汉诺塔游戏</p>
<figure data-type="image" tabindex="1"><img src="https://ss0.bdstatic.com/70cFuHSh_Q1YnxGkpoWK1HF6hhy/it/u=2591095191,1547695417&amp;fm=26&amp;gp=0.jpg" alt="汉诺塔游戏" loading="lazy"></figure>
<p>这个游戏要求将中间的柱子的圆盘全部移动到另外一个柱子上，要求每次只能移动一个圆盘，并且较大的圆盘始终在下方。</p>
</li>
<li>
<p>谢尔宾斯基三角形</p>
<figure data-type="image" tabindex="2"><img src="https://ss1.bdstatic.com/70cFvXSh_Q1YnxGkpoWK1HF6hhy/it/u=3361120212,184359007&amp;fm=26&amp;gp=0.jpg" alt="谢尔宾斯基三角形" loading="lazy"></figure>
<p>三角形里边填充三角形，只要空间够大，它可以撑满整个宇宙。</p>
</li>
</ol>
<p>甚至还诞生了一门数学分支：分形几何。专门研究这种递归现象。</p>
<p>说了这么多，那么递归在程序里面该如何实现呢？</p>
<pre><code class="language-c">//Example 07
#include &lt;stdio.h&gt;
void r(void);
void r(void)
{
    printf(&quot;Hi!&quot;);
    r();
}
int main(void)
{
    r();
    return 0;
}
</code></pre>
<p>运行结果如下：</p>
<pre><code>//Consequence 08
...
Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Segmentation fault
</code></pre>
<p>可以看到，满屏幕的Hi！这就是初学者经常会犯的错误，程序无休止地执行下去，直到消耗掉所有的内存。这就像我们讲过的“从前有座山，山里有座庙……”这个故事一样，没有中止的条件，讲多久都讲不完。</p>
<p>修改下代码：</p>
<pre><code class="language-c">//Example 07 V2
#include &lt;stdio.h&gt;
void r(void);
void r(void)
{
    static int count = 5;//设置计数变量
    printf(&quot;Hi!\n&quot;);
    if (--count)//设置跳出条件
    {
        r();
    }
}

int main(void)
{
    r();
    return 0;
}
</code></pre>
<p>运行结果如下：</p>
<pre><code>//Consequence 07 V2
Hi!
Hi!
Hi!
Hi!
Hi!
</code></pre>
<p>这样，递归这头小猛兽，就这样被我们控制住了。</p>
<h2 id="递归求斐波那契数列">递归求斐波那契数列</h2>
<p>斐波那契数列每一项等于前两项之和，正好符合递归的思路：</p>
<pre><code class="language-c">#include &lt;stdio.h&gt;
int fibo(int n)
{
    if (n &lt;= 2)
    {
        return 1;
    }
    else
    {
        return fibo(n - 1) + fibo(n - 2);
    }
}
int main()
{
    int n;
    printf(&quot;请输入斐波那契数列长度：&quot;);
    scanf(&quot;%d&quot;, &amp;n);
    for (int i = 1; i &lt;= n; ++i)
    {
        printf(&quot;%d&quot;, fibo(i));
        if (i &lt; n)
        {
            printf(&quot;, &quot;);
        }
    }
    return 0;
}
</code></pre>
<p>程序执行如下：</p>
<pre><code>请输入斐波那契数列长度：10
1, 1, 2, 3, 5, 8, 13, 21, 34, 55
</code></pre>
<h2 id="递归求汉诺塔">递归求汉诺塔</h2>
<p>其实，不论有多少层汉诺塔，都可以使用递归一层一层往下解包。</p>
<pre><code class="language-c">//Example 08
#include &lt;stdio.h&gt;
void hanoi(int, char, char, char);
void hanoi(int n, char x, char y, char z)
{
    if (n == 1)
    {
        printf(&quot;%c --&gt; %c\n&quot;, x, z);//剩下底部的圆盘
    }
    else
    {
        hanoi(n - 1, x, z, y);//将n-1个圆盘从x移动到y
        printf(&quot;x --&gt; z\n&quot;);
        hanoi(n - 1, y, x, z);//将n-1个圆盘从y移动到z
    }
}
int main(void)
{
    int n;
    printf(&quot;请输入汉诺塔的层数：&quot;);
    scanf(&quot;%d&quot;, &amp;n);
    hanoi(n, 'X', 'Y', 'Z');
    return 0;
}
</code></pre>
<p>运行结果如下：</p>
<pre><code>//Consequence 08
请输入汉诺塔的层数：4
X --&gt; Y
x --&gt; z
Y --&gt; Z
x --&gt; z
Z --&gt; X
x --&gt; z
X --&gt; Y
x --&gt; z
Y --&gt; Z
x --&gt; z
Z --&gt; X
x --&gt; z
X --&gt; Y
x --&gt; z
Y --&gt; Z
</code></pre>
<h2 id="分治法">分治法</h2>
<p>所谓分治法，就是大事化小的思维。递归实际上就是一种分治。层层递归，然后从最简单的问题开始解决。</p>
<p>说到这里，就不得不提到一种排序算法，就是十分经典的——快速排序。</p>
<p>作为20世纪十大算法之一，快速排序的基本思想是：通过一项将待排序数据分割成独立的两部分，其中一部分元素均比另一部分小，然后分别对这两部分继续排序，重复步骤直到完成。</p>
<figure data-type="image" tabindex="3"><img src="https://www.cxyxiaowu.com/wp-content/uploads/2019/10/1571057581-e7b9d65b41e66df.gif" alt="快速排序动画演示" loading="lazy"></figure>
<p>代码如下：</p>
<pre><code class="language-c">//Example 09
#include &lt;stdio.h&gt;
void qs(int, int, int);
void qs(int array[], int left, int right)
{
    int i = left, j = right;
    int temp;
    int pivot;
    
    //基准点设置为中间元素，当然别的也可以
    pivot = array[(left + right) / 2];
    
    while (i &lt;= j)
    {
        //找到左边大于等于基准点的元素
        while (array[i] &lt; pivot)
        {
            ++i;
        }
        //找到右边小于等于基准点的元素
        while (array[j] &gt; pivot)
        {
            --j;
        }
        //如果左边下标小于右边，则交换元素
        if (i &lt;= j)
        {
            temp = array[i];
            array[i] = array[j];
            array[j] = temp;
            ++i;
            --j;
        }
    }
    
    //递归遍历左子
    if (left &lt; j)
    {
        qs(array, left, j);
    }
    //递归遍历右子
    if (i &lt; right)
    {
        qs(array, i, right);
    }
}

int main(void)
{
    int array[] = {135, 156, 120, 102, 130, 62, 410, 158, 173, 113, 124, 184, 131, 214};
    int length;
    length = sizeof(array) / sizeof(array[0]);
    qs(array, 0, length - 1);
    
    printf(&quot;排序后结果为：&quot;);
    for (int i = 0; i &lt; length; i++)
    {
        printf(&quot;%d&quot;, array[i]);
        if (i &lt; length - 1)
        {
            printf(&quot;, &quot;);
        }
    }
    putchar('\n');
    return 0;
}
</code></pre>
<p>执行结果如下：</p>
<pre><code>//Consequence 09
排序后结果为：62, 102, 113, 120, 124, 130, 131, 135, 156, 158, 173, 184, 214, 410
</code></pre>
<p>学了这么多，也该好好休息下了！下期再见！</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[C语言之函数（上）]]></title>
        <id>https://harriswilde.github.io/post/cYwGcFKPK</id>
        <link href="https://harriswilde.github.io/post/cYwGcFKPK">
        </link>
        <updated>2020-02-03T06:49:54.000Z</updated>
        <content type="html"><![CDATA[<p>在学习了指针以后，我们的C语言学习就算真正入门了。那么，随着我们自己编写的程序规模越来越大，我们写的代码也越来越繁杂，经常会碰到大脑不够用，或者名字不会起了这类看似很搞笑的问题。再者，就是往往要更改代码的时候牵一发而动全身，稍微出差错，就只能推倒重来。</p>
<p>那么，在做开发，尤其是多人协作的大型开发的时候，程序模块化是十分重要的，你只需要预留一些供他人使用的必须的接口，然后把你定义的方法写个文档方便他人开发就行了。那么这种思维，就是<strong>结构化编程</strong>。</p>
<p>比如，我们经常使用的<code>printf</code>函数，就是C语言开发者写好在<code>stdio.h</code>里面的。有了这个函数，我们就可以很简单地输出文本，而不需要去关注底层到底是如何实现的。你会发现，有函数，我们就可以把更多的注意力放在逻辑的实现上，而不需要去关注太多的细枝末节。</p>
<h1 id="函数的定义和声明">函数的定义和声明</h1>
<h2 id="绪论">绪论</h2>
<p>虽然C语言的内置函数已经十分丰富，可以帮我们实现大部分的问题。什么字符串的处理啊，数学方面的计算啊，等等……但是，作为一门高级语言，C语言还可以让我们自己来定义函数，把我们的一些方法抽象封装出来，用于其他的对象上。</p>
<p>我们举个简单的例子，封装一个输出字符图的函数：</p>
<pre><code class="language-c">//Example 01
#include &lt;stdio.h&gt;
//------定义开始------//
void print_house(void)
{
    printf(&quot;¤╭⌒╮ ╭⌒╮:∴★∵**☆．\n&quot;);
    printf(&quot;╱◥██◣ :∴☆∵**★．\n&quot;);
    printf(&quot;|田︱田田|:∴★∵**☆．\n&quot;);
    printf(&quot;╬╬╬╬╬╬╬╬╬╬╬╬╬╬ \n&quot;);
}
//------定义结束------//
int main(void)
{
    print_house();//调用函数
    return 0;
}
</code></pre>
<p>运行结果如下：</p>
<pre><code>//Consequence 01
¤╭⌒╮ ╭⌒╮:∴★∵**☆．
╱◥██◣ :∴☆∵**★．
|田︱田田|:∴★∵**☆．
╬╬╬╬╬╬╬╬╬╬╬╬╬╬ 
</code></pre>
<h2 id="函数的定义">函数的定义</h2>
<p>定义函数的方法，和我们使用<code>main</code>函数的方法差不多：</p>
<pre><code class="language-c">类型名 函数名(参数列表)
{
    函数体
}
</code></pre>
<ul>
<li>类型名就是函数返回值的类型，如果不希望函数返回任何类型，那么就应该使用<code>void</code>（无类型，表示没有返回值）。</li>
<li><strong>函数名</strong>就是函数的名字，自己想怎么命名都可以，但是不要和保留字重复。</li>
<li><strong>参数列表</strong>指定了参数的<strong>类型</strong>和<strong>名字</strong>，如果不需要传递参数，则写上<code>void</code>即可。</li>
<li><strong>函数体</strong>是指函数的具体算法，是函数中关键部分</li>
</ul>
<h2 id="函数的声明">函数的声明</h2>
<p>所谓的声明，就是将函数先告诉编译器，但是具体算法，则在<code>main</code>函数之后开发。</p>
<p>如果不做声明，把上面的程序改成这样则会出错：</p>
<pre><code class="language-c">//Example 01
#include &lt;stdio.h&gt;
int main(void)
{
    print_house();//调用函数
    return 0;
}
//------定义开始------//
void print_house(void)
{
    printf(&quot;¤╭⌒╮ ╭⌒╮:∴★∵**☆．\n&quot;);
    printf(&quot;╱◥██◣ :∴☆∵**★．\n&quot;);
    printf(&quot;|田︱田田|:∴★∵**☆．\n&quot;);
    printf(&quot;╬╬╬╬╬╬╬╬╬╬╬╬╬╬ \n&quot;);
}
//------定义结束------//
</code></pre>
<p>因为道理上，程序是<strong>从上往下</strong>编译的，如果不提前告知，那么<code>main</code>函数里面的<code>print_house</code>，编译器便不知道这是个什么东西。</p>
<p>如果你做了函数的声明，那么这个程序就可以正常执行：</p>
<pre><code class="language-c">//Example 01
#include &lt;stdio.h&gt;
void print_house(void);//声明函数
int main(void)
{
    print_house();//调用函数
    return 0;
}
//------定义开始------//
void print_house(void)
{
    printf(&quot;¤╭⌒╮ ╭⌒╮:∴★∵**☆．\n&quot;);
    printf(&quot;╱◥██◣ :∴☆∵**★．\n&quot;);
    printf(&quot;|田︱田田|:∴★∵**☆．\n&quot;);
    printf(&quot;╬╬╬╬╬╬╬╬╬╬╬╬╬╬ \n&quot;);
}
//------定义结束------//
</code></pre>
<p>原则上来说，函数必须先定义，再使用。况且在以后的开发尤其是团队协作的情况下，先使用函数，后开发函数的情况比较多，因此养成<strong>先定义，后使用</strong>的良好习惯是最好的。</p>
<h1 id="函数的参数和返回值">函数的参数和返回值</h1>
<p>向函数传入参数，可以使函数的功能更加丰富。比如，我们刚刚定义了一个输出字符画的函数，但是这个函数无论在什么时候，它执行出来的结果都是一样的。无法实现更加个性化的功能。比如：</p>
<pre><code class="language-c">//Example 02
#include &lt;stdio.h&gt;
void print(int);

int main(void)
{
	int a;
	scanf(&quot;%d&quot;, &amp;a);
	print(a);
	return 0;
}

void print(int a)
{
	for (int i = a; i &gt; 0; i--)
	{
		printf(&quot;-&quot;);
	}
}
</code></pre>
<p>运行结果如下：</p>
<pre><code>//Consequence 02 - 01
5
-----
</code></pre>
<pre><code>//Consequence 02 - 02
7
-------
</code></pre>
<p>你看，输出的内容会随着用户输入的数字而改变，就像<strong>定制</strong>一样。</p>
<p>那么函数的<strong>返回值</strong>又是什么呢？</p>
<p>我们发现，我们刚刚写的函数，都没有返回值，因为在函数体的执行过程中，我们要得到的结果已经执行完毕了，并不需要返回什么东西。但是，有些函数就不一样了。</p>
<p>比如，我们现在要创建一个函数，能够实现阶乘，这时候，就需要返回值了。</p>
<pre><code class="language-c">//Example 03 - 迭代法
#include &lt;stdio.h&gt;
int factorial(int);

int main(void)
{
    int a;
    scanf(&quot;%d&quot;,&amp;a);
    printf(&quot;%d&quot;, factorial(a));
    return 0;
}

int factorial(int a)
{
    int sum = 1;
    for (int i = a; i &gt; 0; i--)
    {
        sum *= i;
    }
    return sum;
}
</code></pre>
<pre><code class="language-c">//Example 03 - 递归法
#include &lt;stdio.h&gt;
int factorial(int);

int main(void)
{
    int a;
    scanf(&quot;%d&quot;, &amp;a);
    printf(&quot;%d&quot;, factorial(a));
    return 0;
}

int factorial(int a)
{
    int sum;
    if (a == 1)
    {
        return 1;
    }
    else
    {
        return a * factorial(a - 1);
    }
}
</code></pre>
<p>执行结果如下：</p>
<pre><code>//Consequence 03
5
120
</code></pre>
<h2 id="形参和实参">形参和实参</h2>
<p>所谓<strong>形参</strong>，就是形式参数，如：</p>
<pre><code class="language-c">...
int f(int a, int b);
...
</code></pre>
<p>这其中的<code>a</code>和<code>b</code>就是形式参数，此时只是作占位符而已，而在函数真正使用的时候：</p>
<pre><code class="language-c">...
int main(void)
{
    f(x, y);
    ...
}
...
</code></pre>
<p>此时的<code>x</code>和<code>y</code>就是<strong>实参</strong>。因为此时传递进去的值是真正程序里面拥有的值，是实实在在的。</p>
<p>其实形参和实参的作用就是用来传递数据的，当我们自己定义的函数被调用的时候，实参会将值传递给形参（单向传递）。形参变量只有在函数被调用的时候才会分配内存，调用结束后，立即释放内存，因此形参变量只有在函数内部有效，<strong>对函数外的变量不影响</strong>。</p>
<h2 id="传值和传址">传值和传址</h2>
<pre><code class="language-c">//Example 04 - 01
#include &lt;stdio.h&gt;
void swap(int, int);
void swap(int a, int b)
{
    int temp;
    printf(&quot;swap中，交换前：a = %d, b = %d\n&quot;, a, b);
    temp = a;
    a = b;
    b = temp;
    printf(&quot;swap中，交换前：a = %d, b = %d\n&quot;, a, b);
}

int main(void)
{
    int a = 1, b = 2;
    printf(&quot;main中，交换前：a = %d, b = %d\n&quot;, a, b);
    swap(a, b);
    printf(&quot;main中，交换前：a = %d, b = %d\n&quot;, a, b);
    return 0;
}
</code></pre>
<p>运行结果为：</p>
<pre><code>//Consequence 04 - 01
main中，交换前：a = 1, b = 2
swap中，交换前：a = 1, b = 2
swap中，交换前：a = 2, b = 1
main中，交换前：a = 1, b = 2
</code></pre>
<p>可以看到，在<code>swap</code>函数内，传入的值被互换，但是在主函数内，值依旧没有被改变。因此可以得出结论：<strong>函数内部无法改变实参的值</strong></p>
<p>但是，如果换成指针会怎样呢？</p>
<pre><code class="language-c">//Example 04 - 02
#include &lt;stdio.h&gt;
void swap(int*, int*);
void swap(int* a, int* b)
{
    int temp;
    printf(&quot;swap中，交换前：a = %d, b = %d\n&quot;, *a, *b);
    temp = *a;
    *a = *b;
    *b = temp;
    printf(&quot;swap中，交换前：a = %d, b = %d\n&quot;, *a, *b);
}

int main(void)
{
    int a = 1, b = 2;
    printf(&quot;main中，交换前：a = %d, b = %d\n&quot;, a, b);
    swap(&amp;a, &amp;b);
    printf(&quot;main中，交换前：a = %d, b = %d\n&quot;, a, b);
    return 0;
}
</code></pre>
<p>运行结果为：</p>
<pre><code class="language-c">//Consequence 04 - 02
main中，交换前：a = 1, b = 2
swap中，交换前：a = 1, b = 2
swap中，交换前：a = 2, b = 1
main中，交换前：a = 2, b = 1
</code></pre>
<p>欸？怎么这会儿就能变了呢？有人可能会说，Harris你是不是刚刚骗我？</p>
<p>其实并不是，我们看这句：<code>swap(&amp;a, &amp;b);</code>，我们其实传入的实参是两个变量的地址。</p>
<p>打个比方，如果变量<code>a</code>的在内存里面住的是1号房间，变量<code>b</code>在内存中住的是2号房间。那么函数处理了之后，他俩住的地方并没有改变，也就是说，两个变量的内存地址并没有改变，只是函数把这个地址对应的值改变了而已。函数内对指针进行解引用，实际上就是间接地访问了变量的值。</p>
<h2 id="传数组">传数组</h2>
<p>既然是可以传递指针，那么数组按理来说，应该也是可以传的。</p>
<pre><code class="language-c">//Example 05
#include &lt;stdio.h&gt;
void get_array(int);
void get_array(int a[10])
{
	for (int i = 0; i &lt; 10; i++)
	{
		printf(&quot;a[%d] = %d\n&quot;, i, a[i]);
	}
}

int main(void)
{
	int a[10] = { 1,2,3,4,5,6,7,8,9,10 };
	get_array(a);
	return 0;
}
</code></pre>
<pre><code class="language-c">//Consequence 05
a[0] = 1
a[1] = 2
a[2] = 3
a[3] = 4
a[4] = 5
a[5] = 6
a[6] = 7
a[7] = 8
a[8] = 9
a[9] = 10
</code></pre>
<p>如果我们尝试着在函数内改变数组的值呢？</p>
<pre><code class="language-c">//Example 06
#include &lt;stdio.h&gt;
void get_array(int);
void get_array(int a[10])
{
	a[4] = 1;//更改一个值
	for (int i = 0; i &lt; 10; i++)
	{
		printf(&quot;a[%d] = %d\n&quot;, i, a[i]);
	}
}

int main(void)
{
	int a[10] = { 1,2,3,4,5,6,7,8,9,10 };
	get_array(a);
	return 0;
}
</code></pre>
<pre><code>//Consequence 06
a[0] = 1
a[1] = 2
a[2] = 3
a[3] = 4
a[4] = 1
a[5] = 6
a[6] = 7
a[7] = 8
a[8] = 9
a[9] = 10
</code></pre>
<p>可以看到，在主函数里面输出数组，也是被改变了的。于是可以断定，其实传入的并不是一个数组，而是这个数组的<strong>首地址</strong>而已。</p>
<h2 id="可变参数">可变参数</h2>
<p>可能有的同学会纳闷，我们定义的函数，都是给参数预留了位置的，那如果像<code>printf()</code>这种函数，它的参数是取决于占位符的数量，这种函数是怎么定义的呢？</p>
<p>这里，我们就要将一个以前没有用过的头文件<code>&lt;stdarg.h&gt;</code>。这个头文件中有一个类型和三个宏是需要用到的：</p>
<p>一个类型是<code>va_list</code>，三个宏是<code>va_start</code> <code>va_arg</code> <code>va_end</code>，其中，<code>va</code>就是指<strong>variable-argument（可变参数）</strong>。</p>
<pre><code class="language-c">//Example 07
#include &lt;stdio.h&gt;
#include &lt;stdarg.h&gt;
int sum(int n, ...);
int sum(int n, ...)//第一个参数n代表后面可变参数的数量，三个点代表不确定参数个数
{
	int sum = 0;
	va_list arg;//定义参数列表
	va_start(arg, n);//初始化参数列表，n为第一个参数的名称
	for (int i = 0; i &lt; n; i++)
	{
		sum += va_arg(arg, int);//依次获取参数值
	}
	va_end(arg);//结束参数列表
	return sum;
}

int main(void)
{
	int result;
	result = sum(5, 1, 2, 3, 4, 5);
	printf(&quot;result = %d\n&quot;, result);
	return 0;
}
</code></pre>
<p>结果如下：</p>
<pre><code>//Consequence 07
result = 15
</code></pre>
<h1 id="指针函数和函数指针">指针函数和函数指针</h1>
<h2 id="指针函数">指针函数</h2>
<p>函数的类型，实际上就是函数返回值的类型，那么顾名思义，指针函数就是返回指针的函数。</p>
<pre><code class="language-c">//Example 08
#include &lt;stdio.h&gt;
char* getWord(char);
char* getWord(char c)
{
    switch (c)
    {
    case 'A':return &quot;Apple&quot;;
    case 'B':return &quot;Boy&quot;;
    case 'C':return &quot;Cat&quot;;
    case 'D':return &quot;Dog&quot;;
    default:return &quot;None&quot;;
    }
}
int main(void)
{
    char input;
    scanf(&quot;%c&quot;, &amp;input);
    printf(&quot;%s&quot;, getWord(input));
    return 0;
}
</code></pre>
<p>运行结果：</p>
<pre><code>//Consequence 08
A
Apple
</code></pre>
<p>有的小伙伴可能会说，为啥这个<code>switch</code>语句中不用加<code>break</code>呢？</p>
<p>因为<code>return</code>实际上就代表函数执行的结束，因此不会执行到下面的<code>case</code>。</p>
<p>这个例子就是让函数返回字符串(指针)。</p>
<p>另外，不要将函数中局部变量的值作为返回值，因为局部变量的值的作用域（有效范围）只有<strong>函数内部</strong>，因此返回局部变量是不合法的（详细将在下一节中讲到）。</p>
<h2 id="函数指针">函数指针</h2>
<pre><code class="language-c">指针函数 -&gt; int* f();
函数指针 -&gt; int (*p)();
</code></pre>
<p>本质上，函数表示法就是指针表示法。因为函数的名字经过取值会变成函数的地址，所以在定义了函数指针以后，给它传递一个已经被定义的函数名，即可通过该指针进行调用。</p>
<pre><code class="language-c">//Example 09
#include &lt;stdio.h&gt;
int square(int);
int square(int a)
{
    return a * a;
}
int main(void)
{
    int num;
    int (*fp)(int);
    scanf(&quot;%d&quot;, &amp;num);
    fp = square;
    printf(&quot;%d * %d = %d\n&quot;, num, num, (*fp)(num));
    return 0;
}
</code></pre>
<p>结果如下：</p>
<pre><code>//Consequence 10
5
5 * 5 = 25
</code></pre>
<p>这里<code>fp = square</code>可以写成<code>fp = &amp;square</code>，<code>(*fp)(num)</code>可以写成<code>fp(num)</code>，可能更加符合我们之前的习惯。</p>
<h2 id="函数指针作为参数">函数指针作为参数</h2>
<p>函数指针也可以作为参数传递，这样函数就可以实现更加丰富的功能。</p>
<pre><code class="language-c">//Example 11
#include &lt;stdio.h&gt;

int add(int, int);
int sub(int, int);
int calc(int (*fp)(int, int), int, int);

int add(int a, int b)
{
    return a + b;
}
int sub(int a, int b)
{
    return a - b;
}
int calc(int (*fp)(int, int), int a, int b)
{
    return (*fp)(a, b);
}

int main(void)
{
    printf(&quot;1 + 2 = %d\n&quot;, calc(add, 1, 2));
    printf(&quot;1 - 2 = %d\n&quot;, calc(sub, 1, 2));
    return 0;
}
</code></pre>
<p>运行结果为：</p>
<pre><code>//Consequence 11
1 + 2 = 3
1 - 2 = -1
</code></pre>
<h2 id="函数指针作为返回值">函数指针作为返回值</h2>
<p>假设现在有个问题，让用户输入一个表达式，然后根据用户输入的运算符来确定应该调用哪一个函数进行运算。</p>
<pre><code class="language-c">//Example 12
#include &lt;stdio.h&gt;

int add(int, int);
int sub(int, int);
int calc(int (*fp)(int, int), int, int);
int (*select(char op))(int, int);

int add(int a, int b)
{
    return a+b;
}
int sub(int a, int b)
{
    return a-b;
}
int calc(int (*fp)(int, int), int a, int b)
{
    return (*fp)(a, b);
}
int (*select(char op))(int, int)
{
    switch(op)
    {
        case '+':return add;
        case '-':return sub;
    }
}
int main(void)
{
    int a, b;
    char op;
    int (*fp)(int, int);
    printf(&quot;请输入一个式子，如1+2：&quot;);
    scanf(&quot;%d%c%d&quot;, &amp;a, &amp;op, &amp;b);
    fp =  select(op);
    printf(&quot;%d %c %d = %d\n&quot;, a, op, b, calc(fp, a, b));
    return 0;
}
</code></pre>
<p>运行结果如下：</p>
<pre><code>//Consequence 12
请输入一个式子，如1+2：3+4
3 + 4 = 7
</code></pre>
<p>函数的知识太多太繁杂，所以Harris这次采用分节式来写博客。本期的就到这里啦！如果没有理解的，好好去消化下，理解了的就等我下一篇吧！</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[浅谈拼手气红包的算法]]></title>
        <id>https://harriswilde.github.io/post/BGqcimUfF</id>
        <link href="https://harriswilde.github.io/post/BGqcimUfF">
        </link>
        <updated>2020-01-27T08:22:30.000Z</updated>
        <content type="html"><![CDATA[<hr>
<p>首先，在这里祝各位小伙伴们鼠年大吉！！</p>
<p>今天是大年初三，Harris在这里用一个简单的话题，开启鼠年的博客之旅。</p>
<p>大家每逢佳节，最少不了的活动，就是“抢红包”。自打微信推出了电子红包之后，中国人的节日，又多了一种庆祝方式，那就是<strong>红包雨</strong>。这种将传统活动用科技的方式封装的做法，是Harris比较赞成的。把传统溶于新时代，为我们的传统春节带来了新鲜的空气。</p>
<p>但是，我们在群里发红包的时候，可能有的小伙伴会纳闷儿，这个所谓的随机金额，到底是怎么算的呢？它到底是不是公平的呢？</p>
<p>有的小伙伴和我说，这还不简单么，每一个人打开红包的时候，都按照当前剩余的余额为范围，随机生成一个数字就好了。</p>
<p>但是呢，这样的话，随着红包被打开的越来越多，金额的总数也会越来越少。那么，可以抢到的红包也就越来越小，这虽然遵循我们常规所认为的“先来后到”，但是并不公平。</p>
<p>那么要实现绝对的公平，该怎么办呢？</p>
<h1 id="1-随机分割">1. 随机分割</h1>
<p>其实，这种方法很直观就能想到。我们把一个红包想象成一个香肠，假设有<code>N</code>个人来分这个香肠，那么我们只要随机切<code>N-1</code>刀，把每一块分别分给每一个人即可。</p>
<p>红包也是一样的道理，我们可以在红包发出去的同时，就随机分配好金额。等大家来分的时候，再依次分给每一个人就好了。</p>
<p>这种算法思路并不难，而且也能够达到我们的目的，但是由于以下的两点，导致微信没有采用这种算法：</p>
<ol>
<li>算法复杂度高</li>
<li>对服务器端的要求高</li>
</ol>
<p>首先第一点，这个算法的复杂度，肯定是要比现行的微信随机红包算法的复杂度高很多。另外，由于在红包发出去的瞬间，服务器上就需要存储关于这个红包的分配信息，在春节这种红包高峰期的时候，势必会给服务器带来巨大的压力。在分布式系统没有普及之前，第二点都将是一个难以解决的问题。</p>
<p>因此，微信就退而求其次，采用第二种办法。</p>
<h1 id="2-二倍均值法">2. 二倍均值法</h1>
<p>实际上，我们每个人抢到的红包，都是在下面这个区间里面去随机一个数值：</p>
<p class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mrow><mo fence="true">(</mo><mn>0</mn><mo separator="true">,</mo><mn>2</mn><mover accent="true"><mi>M</mi><mo stretchy="true">‾</mo></mover><mo fence="true">]</mo></mrow><mspace width="1em"/><mo separator="true">;</mo><mover accent="true"><mi>M</mi><mo stretchy="true">‾</mo></mover><mo>=</mo><mfrac><mrow><mi mathvariant="normal">剩</mi><mi mathvariant="normal">余</mi><mi mathvariant="normal">金</mi><mi mathvariant="normal">额</mi></mrow><mrow><mi mathvariant="normal">剩</mi><mi mathvariant="normal">余</mi><mi mathvariant="normal">红</mi><mi mathvariant="normal">包</mi><mi mathvariant="normal">数</mi></mrow></mfrac></mrow><annotation encoding="application/x-tex">\left(0,2\overline {M}\right]\quad;\overline M=\frac{剩余金额}{剩余红包数}
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.23334em;vertical-align:-0.35001em;"></span><span class="minner"><span class="mopen delimcenter" style="top:0em;"><span class="delimsizing size1">(</span></span><span class="mord">0</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">2</span><span class="mord overline"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8833300000000001em;"><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.10903em;">M</span></span></span><span style="top:-3.80333em;"><span class="pstrut" style="height:3em;"></span><span class="overline-line" style="border-bottom-width:0.04em;"></span></span></span></span></span></span><span class="mclose delimcenter" style="top:0em;"><span class="delimsizing size1">]</span></span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mspace" style="margin-right:1em;"></span><span class="mpunct">;</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord overline"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8833300000000001em;"><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="mord mathdefault" style="margin-right:0.10903em;">M</span></span><span style="top:-3.80333em;"><span class="pstrut" style="height:3em;"></span><span class="overline-line" style="border-bottom-width:0.04em;"></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1.363em;vertical-align:-0.686em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.677em;"><span style="top:-2.314em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord cjk_fallback">剩</span><span class="mord cjk_fallback">余</span><span class="mord cjk_fallback">红</span><span class="mord cjk_fallback">包</span><span class="mord cjk_fallback">数</span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.677em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord cjk_fallback">剩</span><span class="mord cjk_fallback">余</span><span class="mord cjk_fallback">金</span><span class="mord cjk_fallback">额</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.686em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span></span></p>
<p>微信，正是采用的这种方法。</p>
<p>那么，为什么这个是公平的呢？</p>
<p>假设，发一个100元的红包，10份。那么第一个人的金额，就会在<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo fence="true">(</mo><mn>0</mn><mo separator="true">,</mo><mn>20</mn><mo fence="true">]</mo></mrow><annotation encoding="application/x-tex">\left(0,20\right]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="minner"><span class="mopen delimcenter" style="top:0em;">(</span><span class="mord">0</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">2</span><span class="mord">0</span><span class="mclose delimcenter" style="top:0em;">]</span></span></span></span></span>元里面随机。假设第一个人抢到了平均值10块钱，那么还剩90.</p>
<p>第二个人的抢到的，应该是<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mrow><mo fence="true">(</mo><mn>0</mn><mo separator="true">,</mo><mn>2</mn><mo>⋅</mo><mfrac><mn>90</mn><mn>9</mn></mfrac><mo fence="true">]</mo></mrow><mo>⇒</mo><mrow><mo fence="true">(</mo><mn>0</mn><mo separator="true">,</mo><mn>20</mn><mo fence="true">]</mo></mrow></mrow><annotation encoding="application/x-tex">\left(0,2\cdot \frac{90}{9}\right]\Rightarrow \left(0,20\right]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.20001em;vertical-align:-0.35001em;"></span><span class="minner"><span class="mopen delimcenter" style="top:0em;"><span class="delimsizing size1">(</span></span><span class="mord">0</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">2</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">⋅</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.845108em;"><span style="top:-2.6550000000000002em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">9</span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.394em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">9</span><span class="mord mtight">0</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.345em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mclose delimcenter" style="top:0em;"><span class="delimsizing size1">]</span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">⇒</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="minner"><span class="mopen delimcenter" style="top:0em;">(</span><span class="mord">0</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">2</span><span class="mord">0</span><span class="mclose delimcenter" style="top:0em;">]</span></span></span></span></span>，和之前的一样，以此类推，这个算法是公平的。</p>
<p>但是，并不是每一次都能够理想化地抢到平均值，毕竟我们是要在这个范围内取随机值。假设第一个人只抢到了1块钱，那么第二个人能够抢到的范围是<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo fence="true">(</mo><mn>0</mn><mo separator="true">,</mo><mn>22</mn><mo fence="true">]</mo></mrow><annotation encoding="application/x-tex">\left(0,22\right]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="minner"><span class="mopen delimcenter" style="top:0em;">(</span><span class="mord">0</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">2</span><span class="mord">2</span><span class="mclose delimcenter" style="top:0em;">]</span></span></span></span></span>，范围就更大了点，假设第二个人也只抢到1块钱，那么第三个人的范围就是<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo fence="true">(</mo><mn>0</mn><mo separator="true">,</mo><mn>24.5</mn><mo fence="true">]</mo></mrow><annotation encoding="application/x-tex">\left(0,24.5\right]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="minner"><span class="mopen delimcenter" style="top:0em;">(</span><span class="mord">0</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">2</span><span class="mord">4</span><span class="mord">.</span><span class="mord">5</span><span class="mclose delimcenter" style="top:0em;">]</span></span></span></span></span>，以此类推，假设前面的9个人都只抢到1块钱，那么最后一个人的范围，就是<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo fence="true">(</mo><mn>0</mn><mo separator="true">,</mo><mn>91</mn><mo fence="true">]</mo></mrow><annotation encoding="application/x-tex">\left(0,91\right]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="minner"><span class="mopen delimcenter" style="top:0em;">(</span><span class="mord">0</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">9</span><span class="mord">1</span><span class="mclose delimcenter" style="top:0em;">]</span></span></span></span></span>，实际上就是91块。所以我们可以看到，如果每个人都抢到范围内平均值以下，那么后面的人的随机范围则会越来越大。</p>
<p>那么，我们来看看另外一个极端，如果第一个人抢到20块钱，那么第二个人的范围就是<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo fence="true">(</mo><mn>0</mn><mo separator="true">,</mo><mn>17.76</mn><mo fence="true">]</mo></mrow><annotation encoding="application/x-tex">\left(0,17.76\right]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="minner"><span class="mopen delimcenter" style="top:0em;">(</span><span class="mord">0</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">1</span><span class="mord">7</span><span class="mord">.</span><span class="mord">7</span><span class="mord">6</span><span class="mclose delimcenter" style="top:0em;">]</span></span></span></span></span>，假设第二个人抢到17元，第三个人的范围就是<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo fence="true">(</mo><mn>0</mn><mo separator="true">,</mo><mn>15.75</mn><mo fence="true">]</mo></mrow><annotation encoding="application/x-tex">\left(0,15.75\right]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="minner"><span class="mopen delimcenter" style="top:0em;">(</span><span class="mord">0</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">1</span><span class="mord">5</span><span class="mord">.</span><span class="mord">7</span><span class="mord">5</span><span class="mclose delimcenter" style="top:0em;">]</span></span></span></span></span>……</p>
<p>范围会越来越小，但是每个人的红包都不大，都没有超过第一个人，因此第一个人是本次的运气王。</p>
<p>所以，其实这个算法这么看，貌似的确不那么公平，第一个人永远只能抢到二倍均值以下，也就是说，第一个人就是抢不到大红包，而越往后越<strong>有可能</strong>抢到大红包。</p>
<p>当然，运气王是有可能出现在任意的位置，运气王的位置靠前，则整体不会有很大的红包，运气王靠后的话，后面就有可能出现比前面大很多的红包。</p>
<p>那么这样的算法用代码如何实现呢？</p>
<p>Harris都给大家列出来了，如果感兴趣可以研究研究：</p>
<p>Java:</p>
<pre><code class="language-java">//代码来源于网络
//发红包算法，金额参数以分为单位
public static List&lt;Integer&gt; divideRedPackage(Integer totalAmount, Integer totalPeopleNum){
    List&lt;Integer&gt; amountList = new ArrayList&lt;Integer&gt;();
    Integer restAmount = totalAmount;
    Integer restPeopleNum = totalPeopleNum;
    Random random = new Random();
    for(int i=0; i&lt;totalPeopleNum-1; i++){
        //随机范围：[1，剩余人均金额的两倍)，左闭右开
        int amount = random.nextInt(restAmount / restPeopleNum * 2 - 1) + 1;
        restAmount -= amount;
        restPeopleNum --;
        amountList.add(amount);
    }
    amountList.add(restAmount);
    return amountList;
}
public static void main(String[] args){
    List&lt;Integer&gt; amountList = divideRedPackage(5000, 30);
    for(Integer amount : amountList){
        System.out.println(&quot;抢到金额：&quot; + new BigDecimal(amount).divide(new BigDecimal(100)));
    }
}
</code></pre>
<p>C/C++：</p>
<pre><code class="language-c">#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;

void money();
void money(double TotalAmount, int TotalPeople)
{
	double restAmount = TotalAmount;
	int restPeople = TotalPeople;
	for (int i = 0; i &lt; TotalPeople - 1; ++i)
	{
		int amount = rand() % ((int)((restAmount / restPeople) * 2) * 100);
		restAmount -= amount / 100;
		--restPeople;
		printf(&quot;抢到金额：%.2f\n&quot;, (double)amount / 100);
	}
	printf(&quot;抢到金额：%.2f\n&quot;, (double)restAmount / 100);
}

int main(void)
{
	money(50, 30);
	return 0;
}
</code></pre>
<p>Python：</p>
<pre><code class="language-python">import random
def money(TotalMoney,TotalPeople):
    restMoney = TotalMoney
    restPeople = TotalPeople
    for i in range(TotalPeople - 1):
        mount = round(random.uniform(0.01,(restMoney / restPeople) * 2 - 0.01),2)
        restMoney -= mount
        restPeople -= 1
        print(&quot;抢到金额：&quot;+str(mount))
    print(&quot;抢到金额：&quot;+str(round(restMoney,2)))

money(50,30)
</code></pre>
<p>本篇博客就到此结束了，其实生活中处处充满着知识，就看你有没有一颗爱钻研的心！</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[初识Python，多多关照]]></title>
        <id>https://harriswilde.github.io/post/PythonBasic</id>
        <link href="https://harriswilde.github.io/post/PythonBasic">
        </link>
        <updated>2020-01-14T02:27:02.000Z</updated>
        <content type="html"><![CDATA[<p>在开始之前，我们先来认识认识Python的一些基本信息。</p>
<p>在上一节里面，我们已经带大家安装好了Python的官方IDLE，并且教给大家了一个命令，那就是<code>print(&quot;新年快乐！&quot;)</code>，那么这节我们就来大致了解下Python以及利用Python进行的程序设计。</p>
<hr>
<h1 id="算法是什么">算法是什么</h1>
<p>在开始编程之前，我们先来了解下什么是<strong>计算机程序设计</strong>。简单地说，计算机虽然能够做很多事情，而且速度很快，但是它好像浑身冒着一股不太聪明的亚子，不太擅长自己思考。只有我们告诉它要干什么，它才会去给我们效力。那么，这样的话，我们设计程序的时候，就需要告诉计算机每一步该怎么做，那么这些步骤按照顺序编排起来，就称之为<code>算法</code>。因此算法没啥大不了，不过就是做事情的步骤罢了。比如我要煎牛排，但是我不知道怎么做，那么我去请一位师傅，他就会这样告诉我：</p>
<pre><code>准备好炊具，食材
把锅烧热
放入黄油
将牛排放入其中
将火候调整为适中
每30秒翻一次面
检查牛排表面，若颜色呈金黄有焦香，则盛出
若没有，则重复翻面步骤
</code></pre>
<p>这就是做牛排的一种算法。计算机就是这样，每一步的任何细节你都要告诉它，否则它就无法判断，就会罢工。比如把<code>每30秒翻一次面</code>改为<code>每隔一会儿翻一次面</code>的话，计算机就不会了。</p>
<h1 id="对象">对象</h1>
<p>正所谓，万物皆对象。在Python里面，一个数，一个字符(串)等等都属于对象。</p>
<h2 id="查看对象的地址">查看对象的地址</h2>
<p>具体的每一个常量在Python中都是一个对象。每个对象，在内存中都有一个自己的地址，这就是它的<strong>身份</strong>。我们想要知道它的地址，只需要使用<code>id()</code>函数即可。</p>
<pre><code class="language-python">&gt;&gt;&gt; id(4)
140705889218928
&gt;&gt;&gt; id(3.14)
1923954506000
&gt;&gt;&gt; id(&quot;a&quot;)
1923945858224
&gt;&gt;&gt; id(&quot;TechZone&quot;)
1923955766256
</code></pre>
<h2 id="查看对象类型">查看对象类型</h2>
<p>每一个对象也都有自己的<strong>类型</strong>，这是它们的种族。我们只需要使用函数<code>type()</code>就可以知道每一个对象的类型。</p>
<pre><code class="language-python">&gt;&gt;&gt; type(4)
&lt;class 'int'&gt;
&gt;&gt;&gt; type(3.14)
&lt;class 'float'&gt;
&gt;&gt;&gt; type(&quot;a&quot;)
&lt;class 'str'&gt;
&gt;&gt;&gt; type(&quot;TechZone&quot;)
&lt;class 'str'&gt;
</code></pre>
<h1 id="数与四则运算">数与四则运算</h1>
<p>在Python里面，支持4中类型的数，分别是<code>int(有符号整型)</code> <code>long(长整型)</code> <code>float(浮点型)</code> <code>complex(复数)</code>。</p>
<p>四则运算和我们平时使用的计算机差不多：<code>+加</code> <code>-减</code> <code>*乘</code> <code>/除</code>。</p>
<p>不过，除法还有一种，就是<code>//整除</code>。也就是<strong>取整除法</strong>。</p>
<pre><code class="language-python">&gt;&gt;&gt; 1+2
3
&gt;&gt;&gt; 33+54
87
&gt;&gt;&gt; 1-3
-2
&gt;&gt;&gt; 99*99
9801
&gt;&gt;&gt; 3/2
1.5
&gt;&gt;&gt; 3//2
1
</code></pre>
<h1 id="语句和语句块">语句和语句块</h1>
<p>Python和大部分的语言不同，就在于它的语句块是使用<strong>缩进</strong>来控制的，而<strong>不是</strong>使用大括号。并且语句的结束<strong>没有</strong>分号，不使用转行符<code>\</code>的情况下，回车就代表语句的结束。</p>
<p>比如下面的一个程序，我分别使用C++和Python来写。</p>
<p>C++：</p>
<pre><code class="language-cpp">#include &lt;iostream&gt;
using namespace std;
 
int main (void)
{
   int a = 100;
 
   if( a &lt; 20 )
   {
       cout &lt;&lt; &quot;a 小于 20&quot; &lt;&lt; endl;
   }
   else
   {
       cout &lt;&lt; &quot;a 大于 20&quot; &lt;&lt; endl;
   }
   cout &lt;&lt; &quot;a 的值是 &quot; &lt;&lt; a &lt;&lt; endl;
 
   return 0;
}
</code></pre>
<p>Python：</p>
<pre><code class="language-python">a = int(100)
if a &lt; int(20):
    print(&quot;a小于20&quot;)
else:
    print(&quot;a大于20&quot;)
print(f&quot;a的值是{a}&quot;)
</code></pre>
<p>那么换行符<code>\</code>怎么用呢？看例子：</p>
<p>这是一行写完的：</p>
<pre><code class="language-python">...
total = item1 + item2 + item3
...
</code></pre>
<p>这是换行：</p>
<pre><code class="language-python">...
total = iten1 + \
iten2 + \
item3
...
</code></pre>
<h1 id="变量">变量</h1>
<p>如果你数学不好，也不用害怕。这里的变量，就是指的一个名字而已。比如：</p>
<pre><code class="language-python">score = int(100)
</code></pre>
<p>这里，我就把整数100赋值给了变量<code>score</code>，如果以后有改动，<code>score</code>还可以重新赋值，因此称之为变量。</p>
<p>变量的类型就是被赋值元素的类型，比如这里<code>score</code>的类型就是<code>int</code>。</p>
<p>变量的名称可以包含<strong>数字、字母和下划线</strong>。但是数字<strong>不能</strong>够作为变量名的开头。</p>
<h2 id="多变量赋值">多变量赋值</h2>
<p>Python里面赋值还有一种方法，就是多变量赋值，比如：</p>
<p>多个变量的值相同：</p>
<pre><code class="language-python">a = b = c = 1
</code></pre>
<p>多个变量的值不同：</p>
<pre><code class="language-python">a, b, c = 1, 2, &quot;TechZone&quot;
</code></pre>
<p>或者你还可以交换两个变量的值：</p>
<pre><code class="language-python">a, b = b, a
</code></pre>
<p>还是很方便的，对吧？</p>
<h1 id="注释">注释</h1>
<p>注释，简单来说就是写一些方便人类对代码阅读的一些提示性语言，但是解释器在运行的时候是<strong>不会</strong>去理会这些东西的。</p>
<h2 id="单行注释">单行注释</h2>
<p>单行注释用<code>#</code>号，也就是说，<code>#</code>号后面的任何文字，解释器都不会去理会。</p>
<pre><code class="language-python">...
print(&quot;Hello, world!&quot;) #输出Hello,world!
...
</code></pre>
<h2 id="多行注释">多行注释</h2>
<p>多行注释使用三引号，具体使用三个单引号或者三个双引号都可以。</p>
<pre><code class="language-python">'''
这是一个多行注释，
你可以在这里面长篇大论
写篇小说也是没有问题
'''
</code></pre>
<pre><code class="language-python">&quot;&quot;&quot;
这也是多行注释，
随便你用哪种，
喜欢就好
&quot;&quot;&quot;
</code></pre>
<p>当然，三引号的作用还有别的，我们以后再讲。</p>
<h1 id="python中的保留字">Python中的保留字</h1>
<p>这些保留字，不能够用于<strong>任何</strong>常量，变量和标识符名称。这些是Python自身语法要用的字，并且只包含<strong>小写</strong>。</p>
<blockquote>
<p>and, exec, not, assert, finally, or, break, for, pass, class, from, print, continue, global, raise, def, if, return, del, import, try, elif, in, while, else, is, with, except, lambda, yield.</p>
</blockquote>
<hr>
<p>初识Python，希望它的简洁和优雅能够给你带来舒适和快乐！</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[C语言之指针]]></title>
        <id>https://harriswilde.github.io/post/CPointer</id>
        <link href="https://harriswilde.github.io/post/CPointer">
        </link>
        <updated>2020-01-12T14:18:53.000Z</updated>
        <content type="html"><![CDATA[<p>说到指针，估计还是有很多小伙伴都还是云里雾里的，有点“知其然，而不知其所以然”。但是，不得不说，学了指针，C语言才能算是入门了。指针是C语言的<strong>精华</strong>，可以说，对对指针的掌握程度，<strong>直接决定</strong>了你C语言的编程能力。</p>
<hr>
<p>在讲指针之前，我们先来了解下变量在<strong>内存</strong>中是如何存放的。</p>
<p>在程序中定义一个变量，那么在程序编译的过程中，系统会根据你定义变量的类型来分配<strong>相应尺寸</strong>的内存空间。那么如果要使用这个变量，只需要用变量名去访问即可。</p>
<p>通过变量名来访问变量，是一种<strong>相对安全</strong>的方式。因为只有你定义了它，你才能够访问相应的变量。这就是对内存的基本认知。但是，如果光知道这一点的话，其实你还是不知道内存是如何存放变量的，因为底层是如何工作的，你依旧不清楚。</p>
<p>那么如果要继续深究的话，你就需要把变量在内存中真正的样子是什么搞清楚。内存的最小索引单元是<code>1字节</code>，那么你其实可以把内存比作一个超级大的<strong>字符型数组</strong>。在上一节我们讲过，数组是有下标的，我们是通过数组名和下标来访问数组中的元素。那么内存也是一样，只不过我们给它起了个新名字：<code>地址</code>。每个地址可以存放<strong>1字节</strong>的数据，所以如果我们需要定义一个整型变量，就需要占据4个内存单元。</p>
<p>那么，看到这里你可能就明白了：其实在程序运行的过程中，完全不需要变量名的参与。变量名只是方便我们进行代码的编写和阅读，只有程序员和编译器知道这个东西的存在。而编译器还知道具体的变量名对应的<strong>内存地址</strong>，这个是我们不知道的，因此编译器就像一个桥梁。当读取某一个变量的时候，编译器就会找到变量名所对应的地址，读取对应的值。</p>
<h1 id="初识指针和指针变量">初识指针和指针变量</h1>
<p>那么我们现在就来切入正题，指针是个什么东西呢？</p>
<p>所谓指针，就是内存地址（下文简称地址）。C语言中设立了专门的<strong>指针变量</strong>来存储指针，和<strong>普通变量</strong>不一样的是，指针变量存储的是<strong>地址</strong>。</p>
<h2 id="定义指针">定义指针</h2>
<p>指针变量也有类型，实际上取决于地址指向的值的类型。那么如何定义指针变量呢：</p>
<p>很简单：<code>类型名* 指针变量名</code></p>
<pre><code class="language-c">char* pa;//定义一个字符变量的指针，名称为pa
int* pb;//定义一个整型变量的指针，名称为pb
float* pc;//定义一个浮点型变量的指针，名称为pc
</code></pre>
<p>注意，指针变量一定要和指向的变量的类型一样，不然类型不同可能在内存中所占的位置不同，如果定义错了就可能导致出错。</p>
<h2 id="取地址运算符和取值运算符">取地址运算符和取值运算符</h2>
<p>获取某个变量的地址，使用取地址运算符<code>&amp;</code>，如：</p>
<pre><code class="language-c">char* pa = &amp;a;
int* pb = &amp;f;
</code></pre>
<p>如果反过来，你要访问指针变量指向的数据，那么你就要使用取值运算符<code>*</code>，如：</p>
<pre><code class="language-c">printf(&quot;%c, %d\n&quot;, *pa, *pb);
</code></pre>
<p>这里你可能发现，定义指针的时候也使用了<code>*</code>，这里属于符号的<strong>重用</strong>，也就是说这种符号在不同的地方就有不同的用意：在定义的时候表示<strong>定义一个指针变量</strong>，在其他的时候则用来<strong>获取指针变量指向的变量的值</strong>。</p>
<p>直接通过变量名来访问变量的值称之为<code>直接访问</code>，通过指针这样的形式访问称之为<code>间接访问</code>，因此取值运算符有时候也成为<strong>间接运算符</strong>。</p>
<p>比如：</p>
<pre><code class="language-c">//Example 01
//代码来源于网络，非个人原创
#include &lt;stdio.h&gt;
int main(void)
{
    char a = 'f';
    int f = 123;
    char* pa = &amp;a;
    int* pf = &amp;f;
    
    printf(&quot;a = %c\n&quot;, *pa);
    printf(&quot;f = %d\n&quot;, *pf);
    
    *pa = 'c';
    *pf += 1;
    
    printf(&quot;now, a = %c\n&quot;, *pa);
    printf(&quot;now, f = %d\n&quot;, *pf);
    
    printf(&quot;sizeof pa = %d\n&quot;, sizeof(pa));
    printf(&quot;sizeof pf = %d\n&quot;, sizeof(pf));
    
    printf(&quot;the addr of a is: %p\n&quot;, pa);
    printf(&quot;the addr of f is: %p\n&quot;, pf);
    
    return 0;
}
</code></pre>
<p>程序实现如下：</p>
<pre><code>//Consequence 01
a = f
f = 123
now, a = c
now, f = 124
sizeof pa = 4
sizeof pf = 4
the addr of a is: 00EFF97F
the addr of f is: 00EFF970
</code></pre>
<h2 id="避免访问未初始化的指针">避免访问未初始化的指针</h2>
<pre><code class="language-c">void f()
{
    int* a;
    *a = 10;
}
</code></pre>
<p>像这样的代码是十分危险的。因为指针a到底指向哪里，我们不知道。就和访问未初始化的普通变量一样，会返回一个<strong>随机值</strong>。但是如果是在指针里面，那么就有可能覆盖到<strong>其他的内存区域</strong>，甚至可能是系统正在使用的<strong>关键区域</strong>，十分危险。不过这种情况，系统一般会驳回程序的运行，此时程序会被<strong>中止</strong>并<strong>报错</strong>。要是万一中奖的话，覆盖到一个合法的地址，那么接下来的赋值就会导致一些有用的数据被<strong>莫名其妙地修改</strong>，这样的bug是十分不好排查的，因此使用指针的时候一定要注意初始化。</p>
<h1 id="指针和数组">指针和数组</h1>
<p>有些读者可能会有些奇怪，指针和数组又有什么关系？这俩货明明八竿子打不着井水不犯河水。别着急，接着往下看，你的观点有可能会改变。</p>
<h2 id="数组的地址">数组的地址</h2>
<p>我们刚刚说了，指针实际上就是变量在<strong>内存中的地址</strong>，那么如果有细心的小伙伴就可能会想到，像数组这样的一大摞变量的集合，它的地址是啥呢？</p>
<p>我们知道，从标准输入流中读取一个值到变量中，用的是<code>scanf</code>函数，一般貌似在后面都要加上<code>&amp;</code>，这个其实就是我们刚刚说的<strong>取地址运算符</strong>。如果你存储的位置是指针变量的话，那就不需要。</p>
<pre><code class="language-c">//Example 02
int main(void)
{
    int a;
    int* p = &amp;a;
    
    printf(&quot;请输入一个整数：&quot;);
    scanf(&quot;%d&quot;, &amp;a);//此处需要&amp;
    printf(&quot;a = %d\n&quot;, a);
    
    printf(&quot;请再输入一个整数：&quot;);
    scanf(&quot;%d&quot;, p);//此处不需要&amp;
    printf(&quot;a = %d\n&quot;, a);
    
    return 0;
}
</code></pre>
<p>程序运行如下：</p>
<pre><code>//Consequence 02
请输入一个整数：1
a = 1
请再输入一个整数：2
a = 2
</code></pre>
<p>在普通变量读取的时候，程序需要知道这个变量在内存中的地址，因此需要<code>&amp;</code>来取地址完成这个任务。而对于指针变量来说，本身就是<strong>另外一个</strong>普通变量的<strong>地址信息</strong>，因此直接给出指针的值就可以了。</p>
<p>试想一下，我们在使用<code>scanf</code>函数的时候，是不是也有不需要使用<code>&amp;</code>的时候？就是在读取<strong>字符串</strong>的时候：</p>
<pre><code class="language-c">//Example 03
#include &lt;stdio.h&gt;
int main(void)
{
    char url[100];
    url[99] = '\0';
    printf(&quot;请输入TechZone的域名：&quot;);
    scanf(&quot;%s&quot;, url);//此处也不用&amp;
    printf(&quot;你输入的域名是：%s\n&quot;, url);
    return 0;
}
</code></pre>
<p>程序执行如下：</p>
<pre><code>//Consequence 03
请输入TechZone的域名：www.techzone.ltd
你输入的域名是：www.techzone.ltd
</code></pre>
<p>因此很好推理：数组名其实就是一个<strong>地址信息</strong>，实际上就是数组<strong>第一个元素的地址</strong>。咱们试试把第一个元素的地址和数组的地址做个对比就知道了：</p>
<pre><code class="language-c">//Example 03 V2
#include &lt;stdio.h&gt;
int main(void)
{
    char url[100];
    printf(&quot;请输入TechZone的域名：&quot;);
    url[99] = '\0';
    scanf(&quot;%s&quot;, url);
    printf(&quot;你输入的域名是：%s\n&quot;, url);

    printf(&quot;url的地址为：%p\n&quot;, url);
    printf(&quot;url[0]的地址为：%p\n&quot;, &amp;url[0]);

    if (url == &amp;url[0])
    {
        printf(&quot;两者一致！&quot;);
    }
    else
    {
        printf(&quot;两者不一致！&quot;);
    }
    return 0;
}
</code></pre>
<p>程序运行结果为：</p>
<pre><code>//Comsequense 03 V2
请输入TechZone的域名：www.techzone.ltd
你输入的域名是：www.techzone.ltd
url的地址为：0063F804
url[0]的地址为：0063F804
两者一致！
</code></pre>
<p>这么看，应该是实锤了。那么数组后面的元素也就是依次往后放置，有兴趣的也可以自己写代码尝试把它们输出看看。</p>
<h2 id="指向数组的指针">指向数组的指针</h2>
<p>刚刚我们验证了数组的地址就是数组第一个元素的地址。那么指向数组的指针自然也就有两种定义的方法：</p>
<pre><code class="language-c">...
char* p;
//方法1
p = a;
//方法2
p = &amp;a[0];
</code></pre>
<h2 id="指针的运算">指针的运算</h2>
<p>当指针指向数组元素的时候，可以对指针变量进行<strong>加减</strong>运算，<code>+n</code>表示指向p指针所指向的元素的<strong>下n个元素</strong>，<code>-n</code>表示指向p指针所指向的元素的<strong>上n个元素</strong>。并不是将地址加1。</p>
<p>如：</p>
<pre><code class="language-c">//Example 04
#include &lt;stdio.h&gt;
int main(void)
{
    int a[] = { 1,2,3,4,5 };
    int* p = a;
    printf(&quot;*p = %d, *(p+1) = %d, *(p+2) = %d\n&quot;, *p, *(p + 1), *(p + 2));
    printf(&quot;*p -&gt; %p, *(p+1) -&gt; %p, *(p+2) -&gt; %p\n&quot;, p, p + 1, p + 2);
    return 0;
}
</code></pre>
<p>执行结果如下：</p>
<pre><code>//Consequence 04
*p = 1, *(p+1) = 2, *(p+2) = 3
*p -&gt; 00AFF838, *(p+1) -&gt; 00AFF83C, *(p+2) -&gt; 00AFF840
</code></pre>
<p>有的小伙伴可能会想，编译器是怎么知道访问下一个元素而不是地址直接加1呢？</p>
<p>其实就在我们定义指针变量的时候，就已经告诉编译器了。如果我们定义的是整型数组的指针，那么指针加1，实际上就是加上一个<code>sizeof(int)</code>的距离。相对于标准的下标访问，使用指针来间接访问数组元素的方法叫做<code>指针法</code>。</p>
<p>其实使用指针法来访问数组的元素，不一定需要定义一个指向数组的单独的指针变量，因为数组名自身就是指向数组<strong>第一个元素</strong>的指针，因此指针法可以直接作用于数组名：</p>
<pre><code class="language-c">...
printf(&quot;p -&gt; %p, p+1 -&gt; %p, p+2 -&gt; %p\n&quot;, a, a+1, a+2);
printf(&quot;a = %d, a+1 = %d, a+2 = %d&quot;, *a, *(a+1), *(a+2));
...
</code></pre>
<p>执行结果如下：</p>
<pre><code class="language-c">p -&gt; 00AFF838, p+1 -&gt; 00AFF83C, p+2 -&gt; 00AFF840
b = 1, b+1 = 2, b+2 = 3
</code></pre>
<p>现在你是不是感觉，数组和指针有点像了呢？不过笔者先提醒，数组和指针虽然非常像，但是绝对<strong>不是</strong>       一种东西。</p>
<p>甚至你还可以直接用指针来定义字符串，然后用下标法来读取每一个元素：</p>
<pre><code class="language-c">//Example 05
//代码来源于网络
#include &lt;stdio.h&gt;
#include &lt;string.h&gt;
int main(void)
{
    char* str = &quot;I love TechZone!&quot;;
    int i, length;
    
    length = strlen(str);
    
    for (i = 0; i &lt; length, i++)
    {
        printf(&quot;%c&quot;, str[i]);
    }
    printf(&quot;\n&quot;);
    
    return 0;
}
</code></pre>
<p>程序运行如下：</p>
<pre><code>//Consequence 05
I love TechZone!
</code></pre>
<p>在刚刚的代码里面，我们定义了一个<strong>字符指针</strong>变量，并且初始化成指向一个字符串。后来的操作，不仅在它身上可以使用<strong>字符串处理函数</strong>，还可以用<strong>下标法</strong>访问字符串中的每一个字符。</p>
<p>当然，循环部分这样写也是没毛病的：</p>
<pre><code class="language-c">...
for (i = 0, i &lt; length, i++)
{
    printf(&quot;%c&quot;, *(str + i));
}
</code></pre>
<p>这就相当于利用了指针法来读取。</p>
<h2 id="指针和数组的区别">指针和数组的区别</h2>
<p>刚刚说了许多指针和数组相互替换的例子，可能有的小伙伴又开始说：“这俩货不就是一个东西吗？”</p>
<p>随着你对指针和数组越来越了解，你会发现，C语言的创始人不会这么无聊去创建两种一样的东西，还叫上不同的名字。指针和数组终究是<strong>不一样</strong>的。</p>
<p>比如笔者之前看过的一个例子：</p>
<pre><code class="language-c">//Example 06
//代码来源于网络
#include &lt;stdio.h&gt;
int main(void)
{
    char str[] = &quot;I love TechZone!&quot;;
    int count = 0;
    
    while (*str++ != '\0')
    {
        count++;
    }
    printf(&quot;总共有%d个字符。\n&quot;, count);
    
    return 0;
}
</code></pre>
<p>当编译器报错的时候，你可能会开始怀疑你学了假的C语言语法：</p>
<pre><code>//Error in Example 06
错误(活动)	E0137	表达式必须是可修改的左值
错误	C2105	“++”需要左值
</code></pre>
<p>我们知道，<code>*str++ != ‘\0’</code>是一个复合表达式，那么就要遵循<strong>运算符优先级</strong>来看。具体可以回顾<a href="http://www.techzone.ltd/post/COperatorASCII/">《C语言运算符优先级及ASCII对照表》</a>。</p>
<p><code>str++</code>比<code>*str</code>的优先级<strong>更高</strong>，但是自增运算符要在<strong>下一条语句</strong>的时候才能生效。所以这个语句的理解就是，先取出<code>str</code>所指向的值，判断是否为<code>\0</code>，若是，则跳出循环，然后<code>str</code>指向下一个字符的位置。</p>
<p>看上去貌似没啥毛病，但是，看看编译器告诉我们的东西：<code>表达式必须是可修改的左值</code></p>
<p><code>++</code>的操作对象是<code>str</code>，那么<code>str</code>到底是不是<strong>左值</strong>呢？</p>
<p>如果是左值的话，那么就必须满足左值的条件。</p>
<blockquote>
<ol>
<li>拥有用于识别和定位一个存储位置的标识符</li>
<li>存储值可修改</li>
</ol>
</blockquote>
<p>第一点，数组名<code>str</code>是可以满足的，因为数组名实际上就是定位数组第一个元素的位置。但是第二点就不满足了，数组名实际上是一个地址，地址是<strong>不可以</strong>修改的，它是一个常量。如果非要利用上面的思路来实现的话，可以将代码改成这样：</p>
<pre><code class="language-c">//Example 06 V2
//代码来源于网络
#include &lt;stdio.h&gt;
int main(void)
{
    char str[] = &quot;I love TechZone!&quot;;
    char* target = str;
    int count = 0;
    
    while (*target++ != '\0')
    {
        count++;
    }
    printf(&quot;总共有%d个字符。\n&quot;, count);
    
    return 0;
}
</code></pre>
<p>这样就可以正常执行了：</p>
<pre><code>//Consequence 06 V2
总共有16个字符。
</code></pre>
<p>这样我们就可以得出：数组名只是一个<strong>地址</strong>，而指针是一个<strong>左值</strong>。</p>
<h2 id="指针数组数组指针">指针数组？数组指针？</h2>
<p>看下面的例子，你能分辨出哪个是指针数组，哪个是数组指针吗？</p>
<pre><code class="language-c">int* p1[5];
int(*p2)[5];
</code></pre>
<p>单个的我们都可以判断，但是组合起来就有些难度了。</p>
<p>答案：</p>
<pre><code class="language-c">int* p1[5];//指针数组
int(*p2)[5];//数组指针
</code></pre>
<p>我们挨个来分析。</p>
<h3 id="指针数组">指针数组</h3>
<p>数组下标<code>[]</code>的优先级是最高的，因此<code>p1</code>是一个有5个元素的<strong>数组</strong>。那么这个数组的类型是什么呢？答案就是<code>int*</code>，是<strong>指向整型变量的指针</strong>。因此这是一个<strong>指针数组</strong>。</p>
<p>那么这样的数组应该怎么样去初始化呢？</p>
<p>你可以定义5个变量，然后挨个取地址来初始化。</p>
<p>不过这样太繁琐了，但是，并不是说指针数组就没什么用。</p>
<p>比如：</p>
<pre><code class="language-c">//Example 07
#include &lt;stdio.h&gt;
int main(void)
{
    char* p1[5] = {
        &quot;人生苦短，我用Python。&quot;,
        &quot;PHP是世界上最好的语言！&quot;,
        &quot;One more thing...&quot;,
        &quot;一个好的程序员应该是那种过单行线都要往两边看的人。&quot;,
        &quot;C语言很容易让你犯错误；C++看起来好一些，但当你用它时，你会发现会死的更惨。&quot;
    };
    int i;
    for (i = 0; i &lt; 5; i++)
    {
        printf(&quot;%s\n&quot;, p1[i]);
    }
    return 0;
}
</code></pre>
<p>结果如下：</p>
<pre><code>//Consequence 07
人生苦短，我用Python。
PHP是世界上最好的语言！
One more thing...
一个好的程序员应该是那种过单行线都要往两边看的人。
C语言很容易让你犯错误；C++看起来好一些，但当你用它时，你会发现会死的更惨。
</code></pre>
<p>这样是不是比二维数组来的更加直接更加通俗呢？</p>
<h3 id="数组指针">数组指针</h3>
<p><code>()</code>和<code>[]</code>在优先级里面属于<strong>同级</strong>，那么就按照<strong>先后顺序</strong>进行。</p>
<p><code>int(*p2)</code>将<code>p2</code>定义为<strong>指针</strong>， 后面跟随着一个5个元素的<strong>数组</strong>，<code>p2</code>就指向这个数组。因此，数组指针是一个<strong>指针</strong>，它指向的是一个数组。</p>
<p>但是，如果想对数组指针初始化的时候，千万要小心，比如：</p>
<pre><code class="language-c">//Example 08
#include &lt;stdio.h&gt;
int main(void)
{
    int(*p2)[5] = {1, 2, 3, 4, 5};
    int i;
    for (i = 0; i &lt; 5; i++)
    {
        printf(&quot;%d\n&quot;, *(p2 + i));
    }
    return 0;
}
</code></pre>
<p>Visual Studio 2019报出以下的错误：</p>
<pre><code>//Error and Warning in Example 08
错误(活动)	E0146	初始值设定项值太多
错误	C2440	“初始化”: 无法从“initializer list”转换为“int (*)[5]”
警告	C4477	“printf”: 格式字符串“%d”需要类型“int”的参数，但可变参数 1 拥有了类型“int *”
</code></pre>
<p>这其实是一个非常典型的错误使用指针的案例，编译器提示说这里有一个<strong>整数</strong>赋值给<strong>指针变量</strong>的问题，因为<code>p2</code>归根结底还是指针，所以应该给它传递一个<strong>地址</strong>才行，更改一下：</p>
<pre><code class="language-c">//Example 08 V2
#include &lt;stdio.h&gt;
int main(void)
{
    int temp[5] = {1, 2, 3, 4, 5};
    int(*p2)[5] = temp;
    int i;
    for (i = 0; i &lt; 5; i++)
    {
        printf(&quot;%d\n&quot;, *(p2 + i));
    }
    return 0;
}
</code></pre>
<pre><code>//Error and Warning in Example 08 V2
错误(活动)	E0144	&quot;int *&quot; 类型的值不能用于初始化 &quot;int (*)[5]&quot; 类型的实体
错误	C2440	“初始化”: 无法从“int [5]”转换为“int (*)[5]”
警告	C4477	“printf”: 格式字符串“%d”需要类型“int”的参数，但可变参数 1 拥有了类型“int *”
</code></pre>
<p>可是怎么还是有问题呢？</p>
<p>我们回顾一下，指针是如何指向数组的。</p>
<pre><code class="language-c">int temp[5] = {1, 2, 3, 4, 5};
int* p = temp;
</code></pre>
<p>我们原本以为，指针<code>p</code>是指向数组的指针，但是实际上<strong>并不是</strong>。仔细想想就会发现，这个指针实际上是指向的数组的<strong>第一个元素</strong>，而不是指向数组。因为数组里面的元素在内存中都是挨着个儿存放的，因此只需要知道第一个元素的地址，就可以访问到后面的所有元素。</p>
<p>但是，这么来看的话，指针<code>p</code>指向的就是一个<strong>整型变量</strong>的指针，并不是指向<strong>数组</strong>的指针。而刚刚我们用的数组指针，才是指向数组的指针。因此，应该将<strong>数组的地址</strong>传递给数组指针，而不是将第一个元素的地址传入，尽管它们值相同，但是<strong>含义</strong>确实不一样：</p>
<pre><code class="language-c">//Example 08 V3
//Example 08 V2
#include &lt;stdio.h&gt;
int main(void)
{
    int temp[5] = {1, 2, 3, 4, 5};
    int(*p2)[5] = &amp;temp;//此处取地址
    int i;
    for (i = 0; i &lt; 5; i++)
    {
        printf(&quot;%d\n&quot;, *(*p2 + i));
    }
    return 0;
}
</code></pre>
<p>程序运行如下：</p>
<pre><code>//Consequence 08
1
2
3
4
5
</code></pre>
<h2 id="指针和二维数组">指针和二维数组</h2>
<p>在上一节<a href="http://www.techzone.ltd/post/CArray/">《C语言之数组》</a>我们讲过<strong>二维数组</strong>的概念，并且我们也知道，C语言的二维数组其实在内存中也是<strong>线性存放</strong>的。</p>
<p>假设我们定义了：<code>int array[4][5]</code></p>
<h3 id="array">array</h3>
<p>array作为数组的名称，显然应该表示的是数组的<strong>首地址</strong>。由于二维数组实际上就是一维数组的<strong>线性拓展</strong>，因此array应该就是指的<code>指向包含5个元素的数组的指针</code>。</p>
<p>如果你用<code>sizeof()</code>去测试<code>array</code>和<code>array+1</code>的话，就可以测试出来这样的结论。</p>
<h3 id="array1">*(array+1)</h3>
<p>首先从刚刚的问题我们可以得出，<code>array+1</code>同样也是指的<code>指向包含5个元素的数组的指针</code>，因此<code>*(array+1)</code>就是相当于<code>array[1]</code>，而这刚好相当于<code>array[1][0]</code>的数组名。因此<code>*(array+1)</code>就是指第二行子数组的第一个元素的地址。</p>
<h3 id="array12">*(*(array+1)+2)</h3>
<p>有了刚刚的结论，我们就不难推理出，这个实际上就是<code>array[1][2]</code>。是不是感觉非常简单呢？</p>
<p>总结一下，就是下面的这些结论，记住就好，理解那当然更好：</p>
<pre><code class="language-c">*(array + i) == array[i]
*(*(array + i) + j) == array[i][j]
*(*(*(array + i) + j) + k) == array[i][j][k]
...
</code></pre>
<h2 id="数组指针和二维数组">数组指针和二维数组</h2>
<p>我们在上一节里面讲过，在初始化二维数组的时候是可以偷懒的：</p>
<pre><code class="language-C">int array[][3] = {
    {1, 2, 3},
    {4, 5, 6}
};
</code></pre>
<p>刚刚我们又说过，定义一个数组指针是这样的：</p>
<pre><code class="language-c">int(*p)[3];
</code></pre>
<p>那么组合起来是什么意思呢？</p>
<pre><code class="language-c">int(*p)[3] = array;
</code></pre>
<p>通过刚刚的说明，我们可以知道，<code>array</code>是指向一个3个元素的数组的<strong>指针</strong>，所以这里完全可以将<code>array</code>的值赋值给<code>p</code>。</p>
<p>其实C语言的指针非常灵活，同样的代码用不同的角度去解读，就可以有不同的应用。</p>
<p>那么如何使用指针来访问二维数组呢？没错，就是使用<strong>数组指针</strong>：</p>
<pre><code class="language-c">//Example 09
#include &lt;stdio.h&gt;
int main(void)
{
    int array[3][4] = {
        {0, 1, 2, 3},
        {4, 5, 6, 7},
        {8, 9, 10, 11}
    };
    int(*p)[4];
    int i, j;
    p = array;
    for (i = 0, i &lt; 3, i++)
    {
        for (j = 0, j &lt; 4, j++)
        {
            printf(&quot;%2d &quot;, *(*(p+i) + j)); 
        }
        printf(&quot;\n&quot;);
    }
    return 0;
}
</code></pre>
<p>运行结果：</p>
<pre><code>//Consequence 09
0 1 2 3 
4 5 6 7 
8 9 10 11 
</code></pre>
<h1 id="void指针">void指针</h1>
<p><code>void</code>实际上是<code>无类型</code>的意思。如果你尝试用它来定义一个变量，编译器肯定会<strong>报错</strong>，因为不同类型所占用的内存有可能<strong>不一样</strong>。但是如果定义的是一个指针，那就没问题。<code>void</code>类型中指针可以指向<strong>任何一个类型</strong>的数据，也就是说，任何类型的指针都可以赋值给<code>void</code>指针。</p>
<p>将任何类型的指针转换为<code>void</code>是没有问题的。但是如果你要反过来，那就需要<strong>强制类型转换</strong>。此外，不要对<code>void</code>指针<strong>直接解引用</strong>，因为编译器其实并不知道<code>void</code>指针会存放什么样的类型。</p>
<pre><code class="language-c">//Example 10
#include &lt;stdio.h&gt;
int main(void)
{
    int num = 1024;
    int* pi = &amp;num;
    char* ps = &quot;TechZone&quot;;
    void* pv;
    
    pv = pi;
    printf(&quot;pi:%p,pv:%p\n&quot;, pi, pv);
    printf(&quot;*pv:%d\n&quot;, *pv);
    
    pv = ps;
    printf(&quot;ps:%p,pv:%p\n&quot;, ps, pv);
    printf(&quot;*pv:%s\n&quot;, *pv);
}
</code></pre>
<p>这样会报错：</p>
<pre><code>//Error in Example 10
错误	C2100	非法的间接寻址
错误	C2100	非法的间接寻址
</code></pre>
<p>如果一定要这么做，那么可以用<strong>强制类型转换</strong>：</p>
<pre><code class="language-c">//Example 10 V2
#include &lt;stdio.h&gt;
int main(void)
{
    int num = 1024;
    int* pi = &amp;num;
    char* ps = &quot;TechZone&quot;;
    void* pv;

    pv = pi;
    printf(&quot;pi:%p,pv:%p\n&quot;, pi, pv);
    printf(&quot;*pv:%d\n&quot;, *(int*)pv);

    pv = ps;
    printf(&quot;ps:%p,pv:%p\n&quot;, ps, pv);
    printf(&quot;*pv:%s\n&quot;, pv);
}
</code></pre>
<p>当然，使用void指针一定要小心，由于void指针几乎可以<strong>通吃</strong>所有类型，所以间接使得不同类型的指针转换变得合法，如果代码中存在不合理的转换，编译器也不会报错。</p>
<p>因此，void指针能不用则不用，后面讲函数的时候，还可以解锁更多新的玩法。</p>
<h1 id="null指针">NULL指针</h1>
<p>在C语言中，如果一个指针不指向任何数据，那么就称之为<strong>空指针</strong>，用<strong>NULL</strong>来表示。NULL其实是一个宏定义：</p>
<pre><code class="language-c">#define NULL ((void *)0)
</code></pre>
<p>在大部分的操作系统中，地址0通常是一个<strong>不被使用</strong>的地址，所以如果一个指针指向NULL，就意味着不指向任何东西。为什么一个指针要指向NULL呢？</p>
<p>其实这反而是一种比较指的推荐的<strong>编程风格</strong>——当你暂时还不知道该指向哪儿的时候，就让它指向NULL，以后不会有太多的麻烦，比如：</p>
<pre><code class="language-c">//Example 11
#include &lt;stdio.h&gt;
int main(void)
{
    int* p1;
    int* p2 = NULL;
    printf(&quot;%d\n&quot;, *p1);
    printf(&quot;%d\n&quot;, *p2);
    return 0;
}
</code></pre>
<p>第一个指针未被初始化。在有的编译器里面，这样未初始化的变量就会被赋予<strong>随机值</strong>。这样指针被称为<strong>迷途指针</strong>，<strong>野指针</strong>或者<strong>悬空指针</strong>。如果后面的代码对这类指针解引用，而这个地址又刚好是合法的话，那么就会产生莫名其妙的结果，甚至导致程序的崩溃。因此养成良好的习惯，在暂时不清楚的情况下使用NULL，可以节省大量的后期调试的时间。</p>
<h1 id="指向指针的指针">指向指针的指针</h1>
<p>开始套娃了。其实只要你理解了指针的概念，也就没什么大不了的。</p>
<pre><code class="language-c">//Example 12
#include &lt;stdio.h&gt;
int main(void)
{
    int num = 1;
    int* p = &amp;num;
    int** pp = &amp;p;
    
    printf(&quot;num: %d\n&quot;, num);
    printf(&quot;*p: %d\n&quot;, *p);
    printf(&quot;**p: %d\n&quot;, **pp);
    printf(&quot;&amp;p: %p, pp: %p\n&quot;, &amp;p, pp);
    printf(&quot;&amp;num: %p, p: %p, *pp: %p\n&quot;, &amp;num, p, *pp);
    return 0;
}
</code></pre>
<p>程序结果如下：</p>
<pre><code>//Consequence 12
num: 1
*p: 1
**p: 1
&amp;p: 004FF960, pp: 004FF960
&amp;num: 004FF96C, p: 004FF96C, *pp: 004FF96C
</code></pre>
<p>当然你也可以无限地套娃，一直指下去。不过这样会让代码可读性变得<strong>很差</strong>，过段时间可能你自己都看不懂你写的代码了。</p>
<h1 id="指针数组和指向指针的指针">指针数组和指向指针的指针</h1>
<p>那么，指向指针的指针有什么用呢？</p>
<p>它可不是为了去创造混乱代码，在一个经典的实例里面，就可以体会到它的用处：</p>
<pre><code class="language-c">char* Books[] = {
    &quot;《C专家编程》&quot;,
    &quot;《C和指针》&quot;,
    &quot;《C的陷阱与缺陷》&quot;,
    &quot;《C Primer Plus》&quot;,
    &quot;《Python基础教程（第三版）》&quot;
};
</code></pre>
<p>然后我们需要将这些书进行分类。我们发现，其中有一本是写Python的，其他都是C语言的。这时候指向指针的指针就派上用场了。首先，我们刚刚定义了一个指针数组，也就是说，里面的所有元素的类型<strong>都是指针</strong>，而数组名却又可以用指针的形式来<strong>访问</strong>，因此就可以使用<strong>指向指针的指针</strong>来指向指针数组：</p>
<pre><code class="language-c">...
char** Python;
char** CLang[4];

Python = &amp;Books[5];
CLang[0] = &amp;Books[0];
CLang[1] = &amp;Books[1];
CLang[2] = &amp;Books[2];
CLang[3] = &amp;Books[3];
...
</code></pre>
<p>因为字符串的取地址值实际上就是其<strong>首地址</strong>，也就是一个<strong>指向字符指针的指针</strong>，所以可以这样赋值。</p>
<p>这样，我们就利用指向指针的指针完成了对书籍的分类，这样既避免了浪费多余的内存，而且当其中的书名要修改，只需要改一次即可，代码的灵活性和安全性都得到了提升。</p>
<h1 id="常量和指针">常量和指针</h1>
<p>常量，在我们目前的认知里面，应该是这样的：</p>
<pre><code>520, 'a'
</code></pre>
<p>或者是这样的：</p>
<pre><code class="language-c">#define MAX 1000
#define B 'b'
</code></pre>
<p>常量和变量最大的区别，就是前者<strong>不能够被修改</strong>，后者可以。那么在C语言中，可以将变量变成像具有常量一样的特性，利用<code>const</code>即可。</p>
<pre><code class="language-c">const int max = 1000;
const char a = 'a';
</code></pre>
<p>在<code>const</code>关键字的作用下，变量就会<strong>失去</strong>本来具有的可修改的特性，变成“只读”的属性。</p>
<h1 id="指向常量的指针">指向常量的指针</h1>
<p>强大的指针当然也是可以指向被<code>const</code>修饰过的变量，但这就意味着<strong>不能通过</strong>指针来修改它所引用的值。总结一下，就是以下4点：</p>
<blockquote>
<ol>
<li>指针可以修改为指向不同的变量</li>
<li>指针可以修改为指向不同的常量</li>
<li>可以通过解引用来读取指针指向的数据</li>
<li>不可以通过解引用来修改指针指向的数据</li>
</ol>
</blockquote>
<h1 id="常量指针">常量指针</h1>
<h2 id="指向非常量的常量指针">指向非常量的常量指针</h2>
<p>指针本身作为一种<strong>变量</strong>，也是可以修改的。因此，指针也是可以被<code>const</code>修饰的，只不过位置稍稍<strong>发生了点变化</strong>：</p>
<pre><code class="language-c">...
int* const p = &amp;num;
...
</code></pre>
<p>这样的指针有如下的特性：</p>
<blockquote>
<ol>
<li>指针自身不能够被修改</li>
<li>指针指向的值可以被修改</li>
</ol>
</blockquote>
<h2 id="指向常量的常量指针">指向常量的常量指针</h2>
<p>在定义普通变量的时候也用<code>const</code>修饰，就得到了这样的指针。不过由于限制太多，一般很少用到：</p>
<pre><code class="language-c">...
int num = 100;
const int cnum = 200;
const int* const p = &amp;cnum;
...
</code></pre>
<hr>
<p>这期博客就到此结束了，没学会的反复咀嚼，学会了的自己去实战，相信你的C语言编程能力会越来越强。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[积分变限函数的求导方法]]></title>
        <id>https://harriswilde.github.io/post/P-CkgTjqZ</id>
        <link href="https://harriswilde.github.io/post/P-CkgTjqZ">
        </link>
        <updated>2020-01-01T14:24:10.000Z</updated>
        <content type="html"><![CDATA[<p>所谓<strong>积分变限函数</strong>，就是<s>能够将你所学知识变现的函数</s> 在积分的上下限中加入了一个函数。由于函数的值在自变量不同的时候也不同，因此这个上下限也是不定的，故曰此名。</p>
<p>那么，这样的积分函数是不是就没法求了呢？就这么点难度怎么可能难得住咱们勤劳有智慧的人们呢？下面就来看看，这种阴险狡诈的积分函数到底怎么求。</p>
<hr>
<p>积分变限函数一般分为3种：<strong>仅上限为函数</strong>、<strong>仅下限为函数</strong>和<strong>上下限都为函数</strong>。</p>
<p>我们挨个来看看。</p>
<h1 id="仅上限为函数">仅上限为函数</h1>
<p>这种情况下，只需要把上限函数带入到被积函数里面去即可。如：</p>
<p class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>y</mi><mo>=</mo><msubsup><mo>∫</mo><mi>a</mi><mrow><mi>f</mi><mo>(</mo><mi>x</mi><mo>)</mo></mrow></msubsup><mi>g</mi><mo>(</mo><mi>t</mi><mo>)</mo><mtext> </mtext><mi mathvariant="normal">d</mi><mi>t</mi><mo>⇒</mo><msup><mi>y</mi><mo mathvariant="normal">′</mo></msup><mo>=</mo><mi>g</mi><mo fence="false">(</mo><mi>f</mi><mo>(</mo><mi>x</mi><mo>)</mo><mo fence="false">)</mo><mtext> </mtext><mi mathvariant="normal">d</mi><msup><mi>f</mi><mo mathvariant="normal">′</mo></msup><mo>(</mo><mi>x</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">y=\int_{a}^{f(x)} g(t)\,{\rm d}t\Rightarrow y^\prime=g\big(f(x)\big)\,{\rm d}f^\prime(x)
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">y</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:2.54985em;vertical-align:-0.9119499999999999em;"></span><span class="mop"><span class="mop op-symbol large-op" style="margin-right:0.44445em;position:relative;top:-0.0011249999999999316em;">∫</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.6379000000000001em;"><span style="top:-1.7880500000000001em;margin-left:-0.44445em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">a</span></span></span></span><span style="top:-3.8129em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.10764em;">f</span><span class="mopen mtight">(</span><span class="mord mathdefault mtight">x</span><span class="mclose mtight">)</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.9119499999999999em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="mopen">(</span><span class="mord mathdefault">t</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord"><span class="mord mathrm">d</span></span></span><span class="mord mathdefault">t</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">⇒</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.996332em;vertical-align:-0.19444em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03588em;">y</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.801892em;"><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">′</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1.20001em;vertical-align:-0.35001em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="mord"><span class="delimsizing size1">(</span></span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mopen">(</span><span class="mord mathdefault">x</span><span class="mclose">)</span><span class="mord"><span class="delimsizing size1">)</span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord"><span class="mord mathrm">d</span></span></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.801892em;"><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">′</span></span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord mathdefault">x</span><span class="mclose">)</span></span></span></span></span></p>
<p>比如像下面这个函数，咱们来试试：</p>
<p class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mtable><mtr><mtd><mstyle scriptlevel="0" displaystyle="true"><mi>y</mi></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="true"><mrow><mrow></mrow><mo>=</mo><msubsup><mo>∫</mo><mn>1</mn><msup><mi>x</mi><mn>2</mn></msup></msubsup><msup><mi>e</mi><msup><mi>t</mi><mn>2</mn></msup></msup><mi mathvariant="normal">d</mi><mi>t</mi></mrow></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="true"><mrow><mo>⇒</mo><msup><mi>y</mi><mo mathvariant="normal">′</mo></msup></mrow></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="true"><mrow><mrow></mrow><mo>=</mo><msup><mi>e</mi><mrow><mo>(</mo><msup><mi>x</mi><mn>2</mn></msup><msup><mo>)</mo><mn>2</mn></msup></mrow></msup><mi mathvariant="normal">d</mi><msup><mi>x</mi><mn>2</mn></msup><mo>=</mo><mn>2</mn><mi>x</mi><mo>⋅</mo><msup><mi>e</mi><msup><mi>x</mi><mn>4</mn></msup></msup></mrow></mstyle></mtd></mtr></mtable><annotation encoding="application/x-tex">\begin{aligned}
y&amp;=\int^{x^2}_1 e^{t^2}{\rm d}t\\
\Rightarrow y^\prime&amp;=e^{(x^2)^2}{\rm d}x^2=2x\cdot e^{x^4}
\end{aligned}
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:4.64569em;vertical-align:-2.072845em;"></span><span class="mord"><span class="mtable"><span class="col-align-r"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:2.572845em;"><span style="top:-4.572845em;"><span class="pstrut" style="height:3.7368200000000003em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03588em;">y</span></span></span><span style="top:-2.3239750000000003em;"><span class="pstrut" style="height:3.7368200000000003em;"></span><span class="mord"><span class="mrel">⇒</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03588em;">y</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.801892em;"><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">′</span></span></span></span></span></span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:2.072845em;"><span></span></span></span></span></span><span class="col-align-l"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:2.572845em;"><span style="top:-4.572845em;"><span class="pstrut" style="height:3.7368200000000003em;"></span><span class="mord"><span class="mord"></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mop"><span class="mop op-symbol large-op" style="margin-right:0.44445em;position:relative;top:-0.0011249999999999316em;">∫</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.7368200000000003em;"><span style="top:-1.7880500000000001em;margin-left:-0.44445em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span><span style="top:-3.8129000000000004em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight"><span class="mord mathdefault mtight">x</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8913142857142857em;"><span style="top:-2.931em;margin-right:0.07142857142857144em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.9119499999999999em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault">e</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:1.0369199999999998em;"><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight"><span class="mord mathdefault mtight">t</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8913142857142857em;"><span style="top:-2.931em;margin-right:0.07142857142857144em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span><span class="mord"><span class="mord"><span class="mord mathrm">d</span></span></span><span class="mord mathdefault">t</span></span></span><span style="top:-2.3239750000000003em;"><span class="pstrut" style="height:3.7368200000000003em;"></span><span class="mord"><span class="mord"></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mord"><span class="mord mathdefault">e</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:1.0369199999999998em;"><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mopen mtight">(</span><span class="mord mtight"><span class="mord mathdefault mtight">x</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8913142857142857em;"><span style="top:-2.931em;margin-right:0.07142857142857144em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mclose mtight"><span class="mclose mtight">)</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8913142857142857em;"><span style="top:-2.931em;margin-right:0.07142857142857144em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span><span class="mord"><span class="mord"><span class="mord mathrm">d</span></span></span><span class="mord"><span class="mord mathdefault">x</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8641079999999999em;"><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mord">2</span><span class="mord mathdefault">x</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">⋅</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord"><span class="mord mathdefault">e</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:1.0369199999999998em;"><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight"><span class="mord mathdefault mtight">x</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8913142857142857em;"><span style="top:-2.931em;margin-right:0.07142857142857144em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight">4</span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:2.072845em;"><span></span></span></span></span></span></span></span></span></span></span></span></p>
<h1 id="仅下限为函数">仅下限为函数</h1>
<p>这种情况我们就需要通过添加负号来转换成刚刚我们学的形式，再使用刚刚的方法来解决就可以了。</p>
<p class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>y</mi><mo>=</mo><msubsup><mo>∫</mo><mrow><mi>f</mi><mo>(</mo><mi>x</mi><mo>)</mo></mrow><mi>a</mi></msubsup><mi>g</mi><mo>(</mo><mi>t</mi><mo>)</mo><mtext> </mtext><mi mathvariant="normal">d</mi><mi>t</mi><mo>⇒</mo><mi>y</mi><mo>=</mo><mo>−</mo><msubsup><mo>∫</mo><mi>a</mi><mrow><mi>f</mi><mo>(</mo><mi>x</mi><mo>)</mo></mrow></msubsup><mi>g</mi><mo>(</mo><mi>t</mi><mo>)</mo><mtext> </mtext><mi mathvariant="normal">d</mi><mi>t</mi></mrow><annotation encoding="application/x-tex">y=\int^a_{f(x)}g(t)\,{\rm d}t\Rightarrow y=-\int^{f(x)}_a g(t)\,{\rm d}t
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">y</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:2.501242em;vertical-align:-1.0869499999999999em;"></span><span class="mop"><span class="mop op-symbol large-op" style="margin-right:0.44445em;position:relative;top:-0.0011249999999999316em;">∫</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.414292em;"><span style="top:-1.7880500000000004em;margin-left:-0.44445em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.10764em;">f</span><span class="mopen mtight">(</span><span class="mord mathdefault mtight">x</span><span class="mclose mtight">)</span></span></span></span><span style="top:-3.8129000000000004em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">a</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.0869499999999999em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="mopen">(</span><span class="mord mathdefault">t</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord"><span class="mord mathrm">d</span></span></span><span class="mord mathdefault">t</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">⇒</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">y</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:2.54985em;vertical-align:-0.9119499999999999em;"></span><span class="mord">−</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mop"><span class="mop op-symbol large-op" style="margin-right:0.44445em;position:relative;top:-0.0011249999999999316em;">∫</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.6379000000000001em;"><span style="top:-1.7880500000000001em;margin-left:-0.44445em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">a</span></span></span><span style="top:-3.8129em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.10764em;">f</span><span class="mopen mtight">(</span><span class="mord mathdefault mtight">x</span><span class="mclose mtight">)</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.9119499999999999em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="mopen">(</span><span class="mord mathdefault">t</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord"><span class="mord mathrm">d</span></span></span><span class="mord mathdefault">t</span></span></span></span></span></p>
<p>然后就可以用我们刚刚介绍的方法来进行计算啦：</p>
<p class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><msup><mi>y</mi><mo mathvariant="normal">′</mo></msup><mo>=</mo><mo>−</mo><mi>g</mi><mo fence="false">(</mo><mi>f</mi><mo>(</mo><mi>x</mi><mo>)</mo><mo fence="false">)</mo><mo>⋅</mo><msup><mi>f</mi><mo mathvariant="normal">′</mo></msup><mo>(</mo><mi>x</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">y^{\prime}=-g\big(f(x)\big)\cdot f^\prime(x)
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.996332em;vertical-align:-0.19444em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03588em;">y</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.801892em;"><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">′</span></span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1.20001em;vertical-align:-0.35001em;"></span><span class="mord">−</span><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="mord"><span class="delimsizing size1">(</span></span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mopen">(</span><span class="mord mathdefault">x</span><span class="mclose">)</span><span class="mord"><span class="delimsizing size1">)</span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">⋅</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1.051892em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.801892em;"><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">′</span></span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord mathdefault">x</span><span class="mclose">)</span></span></span></span></span></p>
<p>举个栗子：</p>
<p class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mtable><mtr><mtd><mstyle scriptlevel="0" displaystyle="true"><mi>y</mi></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="true"><mrow><mrow></mrow><mo>=</mo><msubsup><mo>∫</mo><mi>x</mi><mn>0</mn></msubsup><msup><mi>e</mi><mi>t</mi></msup><mi>cos</mi><mo>⁡</mo><mn>3</mn><mi>t</mi><mtext> </mtext><mi mathvariant="normal">d</mi><mi>t</mi></mrow></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="true"><mrow><mo>⟹</mo><mi>y</mi></mrow></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="true"><mrow><mrow></mrow><mo>=</mo><mo>−</mo><msubsup><mo>∫</mo><mn>0</mn><mi>x</mi></msubsup><msup><mi>e</mi><mi>t</mi></msup><mi>cos</mi><mo>⁡</mo><mn>3</mn><mi>t</mi><mtext> </mtext><mi mathvariant="normal">d</mi><mi>t</mi></mrow></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="true"><mrow><mo>⟹</mo><msup><mi>y</mi><mo mathvariant="normal">′</mo></msup></mrow></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="true"><mrow><mrow></mrow><mo>=</mo><mo>−</mo><msup><mi>e</mi><mi>x</mi></msup><mi>cos</mi><mo>⁡</mo><mn>3</mn><mi>x</mi><mtext> </mtext><mi mathvariant="normal">d</mi><mi>x</mi></mrow></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="true"><mrow></mrow></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="true"><mrow><mrow></mrow><mo>=</mo><mo>−</mo><msup><mi>e</mi><mi>x</mi></msup><mi>cos</mi><mo>⁡</mo><mn>3</mn><mi>x</mi></mrow></mstyle></mtd></mtr></mtable><annotation encoding="application/x-tex">\begin{aligned}
 y&amp;=\int^0_x e^t\cos 3t\,{\rm d}t\\
\Longrightarrow y&amp;=-\int^x_0 e^t\cos 3t\,{\rm d}t\\
\Longrightarrow y^\prime &amp; =-e^x\cos 3x\,{\rm d}x\\
&amp;=-e^x\cos 3x\\
\end{aligned}
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:8.4022em;vertical-align:-3.9510999999999994em;"></span><span class="mord"><span class="mtable"><span class="col-align-r"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:4.4511em;"><span style="top:-6.4511em;"><span class="pstrut" style="height:3.5640080000000003em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03588em;">y</span></span></span><span style="top:-3.824858em;"><span class="pstrut" style="height:3.5640080000000003em;"></span><span class="mord"><span class="mrel">⟹</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">y</span></span></span><span style="top:-1.7729080000000006em;"><span class="pstrut" style="height:3.5640080000000003em;"></span><span class="mord"><span class="mrel">⟹</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03588em;">y</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.801892em;"><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">′</span></span></span></span></span></span></span></span></span></span><span style="top:-0.27290800000000104em;"><span class="pstrut" style="height:3.5640080000000003em;"></span><span class="mord"></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:3.9510999999999994em;"><span></span></span></span></span></span><span class="col-align-l"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:4.4511em;"><span style="top:-6.4511em;"><span class="pstrut" style="height:3.5640080000000003em;"></span><span class="mord"><span class="mord"></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mop"><span class="mop op-symbol large-op" style="margin-right:0.44445em;position:relative;top:-0.0011249999999999316em;">∫</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.5640080000000003em;"><span style="top:-1.7880500000000001em;margin-left:-0.44445em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">x</span></span></span><span style="top:-3.812900000000001em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.9119499999999999em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault">e</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.843556em;"><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">t</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mop">cos</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">3</span><span class="mord mathdefault">t</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord"><span class="mord mathrm">d</span></span></span><span class="mord mathdefault">t</span></span></span><span style="top:-3.824858em;"><span class="pstrut" style="height:3.5640080000000003em;"></span><span class="mord"><span class="mord"></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mord">−</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mop"><span class="mop op-symbol large-op" style="margin-right:0.44445em;position:relative;top:-0.0011249999999999316em;">∫</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.414292em;"><span style="top:-1.7880500000000001em;margin-left:-0.44445em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">0</span></span></span><span style="top:-3.8129000000000004em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">x</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.9119499999999999em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault">e</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.843556em;"><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">t</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mop">cos</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">3</span><span class="mord mathdefault">t</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord"><span class="mord mathrm">d</span></span></span><span class="mord mathdefault">t</span></span></span><span style="top:-1.7729080000000006em;"><span class="pstrut" style="height:3.5640080000000003em;"></span><span class="mord"><span class="mord"></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mord">−</span><span class="mord"><span class="mord mathdefault">e</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.7143919999999999em;"><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">x</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mop">cos</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">3</span><span class="mord mathdefault">x</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord"><span class="mord mathrm">d</span></span></span><span class="mord mathdefault">x</span></span></span><span style="top:-0.27290800000000104em;"><span class="pstrut" style="height:3.5640080000000003em;"></span><span class="mord"><span class="mord"></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mord">−</span><span class="mord"><span class="mord mathdefault">e</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.7143919999999999em;"><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">x</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mop">cos</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">3</span><span class="mord mathdefault">x</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:3.9510999999999994em;"><span></span></span></span></span></span></span></span></span></span></span></span></p>
<h1 id="上下限均为函数">上下限均为函数</h1>
<p>这种情况，需要将其分为两个积分来求导，像下面这样：</p>
<p class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mtable><mtr><mtd><mstyle scriptlevel="0" displaystyle="true"><mrow></mrow></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="true"><mrow><mrow></mrow><mi>y</mi><mo>=</mo><msubsup><mo>∫</mo><mrow><mi>h</mi><mo>(</mo><mi>x</mi><mo>)</mo></mrow><mrow><mi>g</mi><mo>(</mo><mi>x</mi><mo>)</mo></mrow></msubsup><mi>f</mi><mo>(</mo><mi>t</mi><mo>)</mo><mtext> </mtext><mi mathvariant="normal">d</mi><mi>t</mi></mrow></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="true"><mo>⟹</mo></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="true"><mrow><mrow></mrow><mi>y</mi><mo>=</mo><msubsup><mo>∫</mo><mn>0</mn><mrow><mi>g</mi><mo>(</mo><mi>x</mi><mo>)</mo></mrow></msubsup><mi>f</mi><mo>(</mo><mi>t</mi><mo>)</mo><mtext> </mtext><mi mathvariant="normal">d</mi><mi>t</mi><mo>+</mo><msubsup><mo>∫</mo><mrow><mi>h</mi><mo>(</mo><mi>x</mi><mo>)</mo></mrow><mn>0</mn></msubsup><mi>f</mi><mo>(</mo><mi>t</mi><mo>)</mo><mtext> </mtext><mi mathvariant="normal">d</mi><mi>t</mi></mrow></mstyle></mtd></mtr></mtable><annotation encoding="application/x-tex">\begin{aligned}
&amp; y=\int^{g(x)}_{h(x)}f(t)\,{\rm d}t \\
\Longrightarrow &amp; y=\int^{g(x)}_0f(t)\,{\rm d}t +\int^0_{h(x)}f(t)\,{\rm d}t \\
\end{aligned}
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:6.049700000000001em;vertical-align:-2.774850000000001em;"></span><span class="mord"><span class="mtable"><span class="col-align-r"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:3.2748500000000003em;"><span style="top:-5.27485em;"><span class="pstrut" style="height:3.6379em;"></span><span class="mord"></span></span><span style="top:-2.249999999999999em;"><span class="pstrut" style="height:3.6379em;"></span><span class="mord"><span class="mrel">⟹</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:2.774850000000001em;"><span></span></span></span></span></span><span class="col-align-l"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:3.2748500000000003em;"><span style="top:-5.27485em;"><span class="pstrut" style="height:3.6379em;"></span><span class="mord"><span class="mord"></span><span class="mord mathdefault" style="margin-right:0.03588em;">y</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mop"><span class="mop op-symbol large-op" style="margin-right:0.44445em;position:relative;top:-0.0011249999999999316em;">∫</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.6379000000000004em;"><span style="top:-1.7880500000000004em;margin-left:-0.44445em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">h</span><span class="mopen mtight">(</span><span class="mord mathdefault mtight">x</span><span class="mclose mtight">)</span></span></span></span><span style="top:-3.8129000000000004em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.03588em;">g</span><span class="mopen mtight">(</span><span class="mord mathdefault mtight">x</span><span class="mclose mtight">)</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.0869499999999999em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mopen">(</span><span class="mord mathdefault">t</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord"><span class="mord mathrm">d</span></span></span><span class="mord mathdefault">t</span></span></span><span style="top:-2.249999999999999em;"><span class="pstrut" style="height:3.6379em;"></span><span class="mord"><span class="mord"></span><span class="mord mathdefault" style="margin-right:0.03588em;">y</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mop"><span class="mop op-symbol large-op" style="margin-right:0.44445em;position:relative;top:-0.0011249999999999316em;">∫</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.6379000000000004em;"><span style="top:-1.7880500000000001em;margin-left:-0.44445em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">0</span></span></span><span style="top:-3.8129000000000004em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.03588em;">g</span><span class="mopen mtight">(</span><span class="mord mathdefault mtight">x</span><span class="mclose mtight">)</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.9119499999999999em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mopen">(</span><span class="mord mathdefault">t</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord"><span class="mord mathrm">d</span></span></span><span class="mord mathdefault">t</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mop"><span class="mop op-symbol large-op" style="margin-right:0.44445em;position:relative;top:-0.0011249999999999316em;">∫</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.5640080000000003em;"><span style="top:-1.7880500000000004em;margin-left:-0.44445em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">h</span><span class="mopen mtight">(</span><span class="mord mathdefault mtight">x</span><span class="mclose mtight">)</span></span></span></span><span style="top:-3.8129000000000004em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.0869499999999999em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mopen">(</span><span class="mord mathdefault">t</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord"><span class="mord mathrm">d</span></span></span><span class="mord mathdefault">t</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:2.774850000000001em;"><span></span></span></span></span></span></span></span></span></span></span></span></p>
<p>分界点视具体情况而定。接下来使用负号：</p>
<p class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mtable><mtr><mtd><mstyle scriptlevel="0" displaystyle="true"><mrow></mrow></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="true"><mrow><mrow></mrow><mi>y</mi><mo>=</mo><msubsup><mo>∫</mo><mn>0</mn><mrow><mi>g</mi><mo>(</mo><mi>x</mi><mo>)</mo></mrow></msubsup><mi>f</mi><mo>(</mo><mi>t</mi><mo>)</mo><mtext> </mtext><mi mathvariant="normal">d</mi><mi>t</mi><mo>+</mo><msubsup><mo>∫</mo><mrow><mi>h</mi><mo>(</mo><mi>x</mi><mo>)</mo></mrow><mn>0</mn></msubsup><mi>f</mi><mo>(</mo><mi>t</mi><mo>)</mo><mtext> </mtext><mi mathvariant="normal">d</mi><mi>t</mi></mrow></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="true"><mo>⟹</mo></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="true"><mrow><mrow></mrow><mi>y</mi><mo>=</mo><msubsup><mo>∫</mo><mn>0</mn><mrow><mi>g</mi><mo>(</mo><mi>x</mi><mo>)</mo></mrow></msubsup><mi>f</mi><mo>(</mo><mi>t</mi><mo>)</mo><mtext> </mtext><mi mathvariant="normal">d</mi><mi>t</mi><mo>−</mo><msubsup><mo>∫</mo><mn>0</mn><mrow><mi>h</mi><mo>(</mo><mi>x</mi><mo>)</mo></mrow></msubsup><mi>f</mi><mo>(</mo><mi>t</mi><mo>)</mo><mtext> </mtext><mi mathvariant="normal">d</mi><mi>t</mi></mrow></mstyle></mtd></mtr></mtable><annotation encoding="application/x-tex">\begin{aligned}
&amp; y=\int^{g(x)}_0f(t)\,{\rm d}t +\int^0_{h(x)}f(t)\,{\rm d}t\\
\Longrightarrow &amp; y=\int^{g(x)}_0f(t)\,{\rm d}t -\int^{h(x)}_0f(t)\,{\rm d}t\\
\end{aligned}
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:5.874700000000001em;vertical-align:-2.6873500000000003em;"></span><span class="mord"><span class="mtable"><span class="col-align-r"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:3.1873500000000003em;"><span style="top:-5.18735em;"><span class="pstrut" style="height:3.6379em;"></span><span class="mord"></span></span><span style="top:-2.1624999999999996em;"><span class="pstrut" style="height:3.6379em;"></span><span class="mord"><span class="mrel">⟹</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:2.6873500000000003em;"><span></span></span></span></span></span><span class="col-align-l"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:3.1873500000000003em;"><span style="top:-5.18735em;"><span class="pstrut" style="height:3.6379em;"></span><span class="mord"><span class="mord"></span><span class="mord mathdefault" style="margin-right:0.03588em;">y</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mop"><span class="mop op-symbol large-op" style="margin-right:0.44445em;position:relative;top:-0.0011249999999999316em;">∫</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.6379000000000004em;"><span style="top:-1.7880500000000001em;margin-left:-0.44445em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">0</span></span></span><span style="top:-3.8129000000000004em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.03588em;">g</span><span class="mopen mtight">(</span><span class="mord mathdefault mtight">x</span><span class="mclose mtight">)</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.9119499999999999em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mopen">(</span><span class="mord mathdefault">t</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord"><span class="mord mathrm">d</span></span></span><span class="mord mathdefault">t</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mop"><span class="mop op-symbol large-op" style="margin-right:0.44445em;position:relative;top:-0.0011249999999999316em;">∫</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.5640080000000003em;"><span style="top:-1.7880500000000004em;margin-left:-0.44445em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">h</span><span class="mopen mtight">(</span><span class="mord mathdefault mtight">x</span><span class="mclose mtight">)</span></span></span></span><span style="top:-3.8129000000000004em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.0869499999999999em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mopen">(</span><span class="mord mathdefault">t</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord"><span class="mord mathrm">d</span></span></span><span class="mord mathdefault">t</span></span></span><span style="top:-2.1624999999999996em;"><span class="pstrut" style="height:3.6379em;"></span><span class="mord"><span class="mord"></span><span class="mord mathdefault" style="margin-right:0.03588em;">y</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mop"><span class="mop op-symbol large-op" style="margin-right:0.44445em;position:relative;top:-0.0011249999999999316em;">∫</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.6379000000000004em;"><span style="top:-1.7880500000000001em;margin-left:-0.44445em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">0</span></span></span><span style="top:-3.8129000000000004em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.03588em;">g</span><span class="mopen mtight">(</span><span class="mord mathdefault mtight">x</span><span class="mclose mtight">)</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.9119499999999999em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mopen">(</span><span class="mord mathdefault">t</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord"><span class="mord mathrm">d</span></span></span><span class="mord mathdefault">t</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mop"><span class="mop op-symbol large-op" style="margin-right:0.44445em;position:relative;top:-0.0011249999999999316em;">∫</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.6379000000000004em;"><span style="top:-1.7880500000000001em;margin-left:-0.44445em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">0</span></span></span><span style="top:-3.8129000000000004em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">h</span><span class="mopen mtight">(</span><span class="mord mathdefault mtight">x</span><span class="mclose mtight">)</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.9119499999999999em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mopen">(</span><span class="mord mathdefault">t</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord"><span class="mord mathrm">d</span></span></span><span class="mord mathdefault">t</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:2.6873500000000003em;"><span></span></span></span></span></span></span></span></span></span></span></span></p>
<p>当然，其实这种类型，有公式可以套，也可以自己推导哦：</p>
<p class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mtable><mtr><mtd><mstyle scriptlevel="0" displaystyle="true"><msup><mi>y</mi><mo mathvariant="normal">′</mo></msup></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="true"><mrow><mrow></mrow><mo>=</mo><msup><mrow><mo fence="true">(</mo><msubsup><mo>∫</mo><mrow><mi>h</mi><mo>(</mo><mi>x</mi><mo>)</mo></mrow><mrow><mi>g</mi><mo>(</mo><mi>x</mi><mo>)</mo></mrow></msubsup><mi>f</mi><mo>(</mo><mi>t</mi><mo>)</mo><mtext> </mtext><mi mathvariant="normal">d</mi><mi>t</mi><mo fence="true">)</mo></mrow><mo mathvariant="normal">′</mo></msup></mrow></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="true"><mrow></mrow></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="true"><mrow><mrow></mrow><mo>=</mo><mi>f</mi><mo fence="false">(</mo><mi>g</mi><mo>(</mo><mi>x</mi><mo>)</mo><mo fence="false">)</mo><mo>⋅</mo><msup><mi>g</mi><mo mathvariant="normal">′</mo></msup><mo>(</mo><mi>x</mi><mo>)</mo><mo>−</mo><mi>f</mi><mo fence="false">(</mo><mi>h</mi><mo>(</mo><mi>x</mi><mo>)</mo><mo fence="false">)</mo><mo>⋅</mo><msup><mi>h</mi><mo mathvariant="normal">′</mo></msup><mo>(</mo><mi>x</mi><mo>)</mo></mrow></mstyle></mtd></mtr></mtable><annotation encoding="application/x-tex">\begin{aligned}
y^\prime
&amp;=\left(\int^{g(x)}_{h(x)}f(t)\,{\rm d}t\right)^\prime\\
&amp;=f\big(g(x)\big)\cdot g^\prime(x)-f\big(h(x)\big)\cdot h^\prime(x)\\
\end{aligned}
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:4.951822em;vertical-align:-2.225911em;"></span><span class="mord"><span class="mtable"><span class="col-align-r"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:2.725911em;"><span style="top:-4.725911em;"><span class="pstrut" style="height:3.891792em;"></span><span class="mord"><span class="mord"><span class="mord mathdefault" style="margin-right:0.03588em;">y</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.801892em;"><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">′</span></span></span></span></span></span></span></span></span></span><span style="top:-2.3258810000000003em;"><span class="pstrut" style="height:3.891792em;"></span><span class="mord"></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:2.225911em;"><span></span></span></span></span></span><span class="col-align-l"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:2.725911em;"><span style="top:-4.725911em;"><span class="pstrut" style="height:3.891792em;"></span><span class="mord"><span class="mord"></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="minner"><span class="minner"><span class="mopen delimcenter" style="top:0em;"><span class="delimsizing size4">(</span></span><span class="mop"><span class="mop op-symbol large-op" style="margin-right:0.44445em;position:relative;top:-0.0011249999999999316em;">∫</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.6379000000000004em;"><span style="top:-1.7880500000000004em;margin-left:-0.44445em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">h</span><span class="mopen mtight">(</span><span class="mord mathdefault mtight">x</span><span class="mclose mtight">)</span></span></span></span><span style="top:-3.8129000000000004em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.03588em;">g</span><span class="mopen mtight">(</span><span class="mord mathdefault mtight">x</span><span class="mclose mtight">)</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.0869499999999999em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mopen">(</span><span class="mord mathdefault">t</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord"><span class="mord mathrm">d</span></span></span><span class="mord mathdefault">t</span><span class="mclose delimcenter" style="top:0em;"><span class="delimsizing size4">)</span></span></span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:1.8917920000000001em;"><span style="top:-4.2029000000000005em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">′</span></span></span></span></span></span></span></span></span></span><span style="top:-2.3258810000000003em;"><span class="pstrut" style="height:3.891792em;"></span><span class="mord"><span class="mord"></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mord"><span class="delimsizing size1">(</span></span><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="mopen">(</span><span class="mord mathdefault">x</span><span class="mclose">)</span><span class="mord"><span class="delimsizing size1">)</span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">⋅</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.801892em;"><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">′</span></span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord mathdefault">x</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mord"><span class="delimsizing size1">(</span></span><span class="mord mathdefault">h</span><span class="mopen">(</span><span class="mord mathdefault">x</span><span class="mclose">)</span><span class="mord"><span class="delimsizing size1">)</span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">⋅</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord"><span class="mord mathdefault">h</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.801892em;"><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">′</span></span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord mathdefault">x</span><span class="mclose">)</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:2.225911em;"><span></span></span></span></span></span></span></span></span></span></span></span></p>
<hr>
<p>其实这样的题目看起来复杂，实际上只要掌握了技巧和方法，解决就是分分钟的事情了！这节的内容非常简单，相信你很快就能够掌握。</p>
]]></content>
    </entry>
</feed>