<!DOCTYPE html>
<html>
  <head>
    <meta charset="UTF-8"/>
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
<title>失传的结构体打包艺术 | TechZone</title>
<meta name="keywords" content="TechZone">
<meta name="description" content="HarrisWilde祝诸君元旦快乐🎉">
<link rel="shortcut icon" href="https://harriswilde.github.io/favicon.ico?v=1581949743403">
<link rel="stylesheet" href="https://harriswilde.github.io/styles/main.css">

<link rel="stylesheet" href="/media/css/pisces.css">

<link rel="stylesheet" href="/media/fonts/font-awesome.css">
<link href="//fonts.googleapis.com/css?family=Monda:300,300italic,400,400italic,700,700italic|Roboto Slab:300,300italic,400,400italic,700,700italic|Rosario:300,300italic,400,400italic,700,700italic|PT Mono:300,300italic,400,400italic,700,700italic&subset=latin,latin-ext" rel="stylesheet" type="text/css">

<link href="/media/hljs/styles/prism.css" rel="stylesheet">  
<script src="/media/hljs/highlight.js"></script>

<script src="https://cdn.jsdelivr.net/npm/velocity-animate@1.5.0/velocity.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/velocity-animate@1.5.0/velocity.ui.min.js"></script>

<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.11.1/dist/katex.min.css" integrity="sha384-zB1R0rpPzHqg7Kpt0Aljp8JPLqbXI3bhnPWROx27a9N0Ll6ZP/+DiW/UqRcLbRjq" crossorigin="anonymous">
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.11.1/dist/katex.min.js" integrity="sha384-y23I5Q6l+B6vatafAwxRu/0oK/79VlbSz7Q9aiSZUvyWYIYsd+qj+o24G5ZU2zJz" crossorigin="anonymous"></script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.11.1/dist/contrib/auto-render.min.js" integrity="sha384-kWPLUVMOks5AQFrykwIup5lo0m3iMkkHrD0uJ4H5cjeGihAutqP0yW0J6dpFiVkI" crossorigin="anonymous"
    onload="renderMathInElement(document.body);"></script>
    <meta name="description" content="失传的结构体打包艺术" />
    <meta name="keywords" content="C,C++,数据结构" />
    <meta name="theme-color" content="#222222"/>
  </head>
  <body>
    <div class="head-top-line"></div>
    <div class="header-box">
      
<div class=" pisces">
  <header class="header bg-color ">
    <div class="blog-header box-shadow-wrapper bg-color " id="header">
      <div class="nav-toggle" id="nav_toggle">
        <div class="toggle-box">
          <div class="line line-top"></div>
          <div class="line line-center"></div>
          <div class="line line-bottom"></div>
        </div>
      </div>
      <div class="site-meta">       
        <div class="site-title">
          
            <a href="/" class="brand">
              <span>TechZone</span>
            </a>  
          
        </div>
        
          <p class="subtitle">HarrisWilde的官方个人博客</p>
        
      </div>
      <nav class="site-nav" id="site_nav">
        <ul id="nav_ul">
          
            <li class="nav-item ">
              
                <a href="/">
                  <i class="fa fa-home"></i> 首页
                </a>
              
            </li>
          
            <li class="nav-item ">
              
                <a href="/archives">
                  <i class="fa fa-archive"></i> 归档
                </a>
              
            </li>
          
            <li class="nav-item ">
              
                <a href="/tags">
                  <i class="fa fa-tags"></i> 分类
                </a>
              
            </li>
          
            <li class="nav-item ">
              
                <a href="https://www.jianshu.com/u/766d2f134900" target="_blank">
                  <i class="fa fa-globe"></i> 简书
                </a>
              
            </li>
          
          <li class="nav-item">
            <a>
              <i class="fa fa-search"></i> 搜索
            </a>
          </li>
        </ul>
      </nav>
    </div>
  </header>
</div>

<script type="text/javascript"> 
 
  let showNav = true;

  let navToggle = document.querySelector('#nav_toggle'),
  siteNav = document.querySelector('#site_nav');
  
  function navClick() {
    let sideBar = document.querySelector('.sidebar');
    let navUl = document.querySelector('#nav_ul');
    navToggle.classList.toggle('nav-toggle-active');
    siteNav.classList.toggle('nav-menu-active');
    if (siteNav.classList.contains('nav-menu-active')) {
      siteNav.style = "height: " + (navUl.children.length * 42) +"px !important";
    } else {
      siteNav.style = "";
    }
  }

  navToggle.addEventListener('click',navClick);  
</script>
    </div>
    <div class="main-continer">
      
      <div class="section-layout pisces ">
        <div class="section-layout-wrapper">
          

<div class="sidebar">
    <div class="sidebar-box box-shadow-wrapper bg-color right-motion" id="sidebar">
      
        <div class="post-list-sidebar">
          <div class="sidebar-title">
            <span id="tocSideBar" class="sidebar-title-item sidebar-title-active">文章目录</span>
            <span id="metaSideBar" class="sidebar-title-item">站点概览</span>
          </div>
        </div>
      
      <div class="sidebar-body pisces" id="sidebar_body">
        
          <div class="post-side-meta" id="post_side_meta">
            
<div class="sidebar-wrapper box-shadow-wrapper bg-color">
  <div class="sidebar-item">
    <img class="site-author-image right-motion" src="https://harriswilde.github.io/images/avatar.png"/>
    <p class="site-author-name">TechZone</p>
    <p class="site-description right-motion">2020，共同进步！</p>
  </div>
  <div class="sidebar-item side-item-stat right-motion">
    <div class="sidebar-item-box">
      <a href="/archives/">
        
        <span class="site-item-stat-count">26</span>
        <span class="site-item-stat-name">文章</span>
      </a>
    </div>
    <div class="sidebar-item-box">
      <a href="">
        <span class="site-item-stat-count">7</span>
        <span class="site-item-stat-name">分类</span>
      </a>
    </div>
    <div class="sidebar-item-box">
      <a href="/tags/">
        <span class="site-item-stat-count">7</span>
        <span class="site-item-stat-name">标签</span>
      </a>
    </div>
  </div>
  
    
      <div class="sidebar-item">
        <span class="site-item-rss">
            <i class="fa fa-rss"></i>
            <a href="https://harriswilde.github.io/atom.xml" target="_blank">RSS</a>
        </span>
      </div>
    
  
  


</div>
          </div>
          <div class="post-toc sidebar-body-active" id="post_toc" style="opacity: 1;">
            <div class="toc-box right-motion">
  <div class="toc-wrapper auto-number auto" id="toc_wrapper">
    <ul class="markdownIt-TOC">
<li><a href="#%E8%B0%81%E5%BA%94%E9%98%85%E8%AF%BB%E6%9C%AC%E6%96%87">谁应阅读本文</a></li>
<li><a href="#%E7%BC%98%E4%BD%95%E5%86%99%E4%BD%9C%E6%9C%AC%E6%96%87">缘何写作本文</a></li>
<li><a href="#%E5%AF%B9%E9%BD%90%E8%A6%81%E6%B1%82">对齐要求</a></li>
<li><a href="#%E5%A1%AB%E5%85%85">填充</a></li>
<li><a href="#%E7%BB%93%E6%9E%84%E4%BD%93%E7%9A%84%E5%AF%B9%E9%BD%90%E5%92%8C%E5%A1%AB%E5%85%85">结构体的对齐和填充</a></li>
<li><a href="#%E7%BB%93%E6%9E%84%E4%BD%93%E6%88%90%E5%91%98%E9%87%8D%E6%8E%92">结构体成员重排</a></li>
<li><a href="#%E6%A3%98%E6%89%8B%E7%9A%84%E6%A0%87%E9%87%8F%E6%A1%88%E4%BE%8B">棘手的标量案例</a></li>
<li><a href="#%E5%8F%AF%E8%AF%BB%E6%80%A7%E4%B8%8E%E7%BC%93%E5%AD%98%E5%B1%80%E9%83%A8%E6%80%A7">可读性与缓存局部性</a></li>
<li><a href="#%E5%85%B6%E4%BB%96%E6%89%93%E5%8C%85%E6%8A%80%E6%9C%AF">其他打包技术</a></li>
<li><a href="#%E5%B7%A5%E5%85%B7">工具</a></li>
<li><a href="#%E8%AF%81%E6%98%8E%E5%92%8C%E4%BE%8B%E5%A4%96">证明和例外</a></li>
</ul>

  </div>
</div>

<script>

let lastTop = 0, lList = [], hList = [], postBody, lastIndex = -1; 
let active = 'active-show', activeClass = 'active-current';
let tocWrapper = document.querySelector('#toc_wrapper');
let tocContent = tocWrapper.children[0];
let autoNumber = tocWrapper&&tocWrapper.classList.contains('auto-number');

function addTocNumber(elem, deep) {
  if (!elem) {
    return;
  }
  let prop = elem.__proto__;

  if (prop === HTMLUListElement.prototype) {
    for (let i = 0; i < elem.children.length; i++) {
      addTocNumber(elem.children[i], deep + (i + 1) + '.');
    }
  } else if (prop === HTMLLIElement.prototype) {
    // 保存li元素
    lList.push(elem);
    for (let i = 0; i < elem.children.length; i++) {
      let cur = elem.children[i];
      if (cur.__proto__ === HTMLAnchorElement.prototype) {
        if (autoNumber) {
          cur.text =  deep + ' ' + cur.text;
        }
      } else if (cur.__proto__ === HTMLUListElement.prototype) {
        addTocNumber(cur, deep);
      }
    }
  }
}


document.addEventListener('scroll', function(e) {
  if (lList.length <= 0) {
    return;
  }
  let scrollTop = document.scrollingElement.scrollTop;
  let dir;

  if (lastTop - scrollTop > 0) {
    dir = 'up';
  } else {
    dir = 'down';
  }

  lastTop = scrollTop;
  if (scrollTop <= 0) {
    if (lastIndex >= 0 && lastIndex < hList.length) {
      lList[lastIndex].classList.remove(activeClass);
    }
    return;
  }

  let current = 0, hasFind = false;
  for (let i = 0; i < hList.length; i++) {
    if (hList[i].offsetTop > scrollTop) {
      current = i;
      hasFind = true;
      break;
    }
  }
  if (!hasFind && scrollTop > lList[lList.length - 1].offsetTop) {
    current = hList.length - 1;
  } else {
    current--;
  }
  if (dir === 'down') {
    if (current > lastIndex) {
      addActiveClass(current);
      removeActiveClass(lastIndex) 
      lastIndex = current;
      removeParentActiveClass();
      lList[current] && addActiveLiElemment(lList[current].parentElement,tocContent);
    }
  } else {
    if (current < lastIndex) {
      addActiveClass(current);
      removeActiveClass(lastIndex);
      lastIndex = current;
      removeParentActiveClass();
      lList[current] && addActiveLiElemment(lList[current].parentElement,tocContent);
    }
  }
});

function removeParentActiveClass() {
  let parents = tocContent.querySelectorAll('.'+active)
  parents.forEach(function(elem) {
    elem.classList.remove(active);
  });
}

function addActiveClass(index) {
  if (index >= 0 && index < hList.length) {
    lList[index].classList.add(activeClass);
  }
}

function removeActiveClass(index) {
  if (index >= 0 && index < hList.length) {
    lList[index].classList.remove(activeClass);
  }
}

function addActiveLiElemment(elem, parent) {
  if (!elem || elem === parent) {
    return;
  } else {
    if (elem.__proto__ === HTMLLIElement.prototype) {
      elem.classList.add(active);
    }
    addActiveLiElemment(elem.parentElement, parent);
  }
}

function showToc() {
  if (tocWrapper) {
    postBody = document.querySelector('#post_body');
    for (let i = 0; i < postBody.children.length; i++) {
      if (postBody.children[i].__proto__ === HTMLHeadingElement.prototype) {
        hList.push(postBody.children[i]);
      }
    }
    if (tocWrapper.classList.contains('compress')) {
        tocContent.classList.add('closed');
    } else if (tocWrapper.classList.contains('no_compress')){
      tocContent.classList.add('expanded');
    } else {
      if (hList.length > 10) {
        active = 'active-hidden'
        tocContent.classList.add('closed');
      } else {
        tocContent.classList.add('expanded');
      }
    }
  }
}
addTocNumber(tocContent, '');

window.addEventListener('load', function() {
  showToc();
  document.querySelector('#sidebar').style='display: block;';
  tocWrapper.classList.add('toc-active');
  setTimeout(function() {
    if ("createEvent" in document) {
      let evt = document.createEvent("HTMLEvents");
      evt.initEvent("scroll", false, true);
      document.dispatchEvent(evt);
    }
    else {
      document.fireEvent("scroll");
    }
  }, 500)
})

</script>
          </div>
        
      </div>
    </div>
</div>
<script>
  const SIDEBAR_TITLE_ACTIVE = 'sidebar-title-active';
  const SIDEBAR_BODY_ACTIVE = 'sidebar-body-active';
  const SLIDE_UP_IN = 'slide-up-in';

  let sidebar = document.querySelector('#sidebar'),
  tocSideBar = document.querySelector('#tocSideBar'),
  metaSideBar = document.querySelector('#metaSideBar'),
  postToc = document.querySelector('#post_toc'),
  postSiteMeta = document.querySelector('#post_side_meta'),
  sidebarTitle = document.querySelector('.sidebar-title'),
  sidebarBody = document.querySelector('#sidebar_body');

  tocSideBar && tocSideBar.addEventListener('click', (e) => {
    toggleSidebar(e);
  });

  metaSideBar && metaSideBar.addEventListener('click', (e) => {
    toggleSidebar(e);
  });

  function toggleSidebar(e) {
    let currentTitle = document.querySelector("."+SIDEBAR_TITLE_ACTIVE);
    if (currentTitle == e.srcElement) {
      return ;
    }
    let current, showElement, hideElement;
    if (e.srcElement == metaSideBar) {
      showElement = postSiteMeta;
      hideElement = postToc;
    } else if (e.srcElement == tocSideBar){
      showElement = postToc;
      hideElement = postSiteMeta;
    }
    currentTitle.classList.remove(SIDEBAR_TITLE_ACTIVE);
    e.srcElement.classList.add(SIDEBAR_TITLE_ACTIVE);

    window.Velocity(hideElement, 'stop');
    window.Velocity(hideElement, 'transition.slideUpOut', {
      display: 'none',
      duration: 200,
      complete: function () {
        window.Velocity(showElement, 'transition.slideDownIn', {
          duration: 200
        });
      }
    })
    hideElement.classList.remove(SIDEBAR_BODY_ACTIVE);
    showElement.classList.add(SIDEBAR_BODY_ACTIVE);
  }

  postToc.addEventListener('transitionend', function() {
    this.classList.remove(SLIDE_UP_IN);
  });


  if (sidebarBody.classList.contains('pisces') || sidebarBody.classList.contains('gemini')) {
    let hasFix = false;
    let scrollEl = document.querySelector('.main-continer');
    let limitTop = document.querySelector('#nav_ul').children.length * 42 + 162;
    window.addEventListener('scroll', function(e) {
    if (document.scrollingElement.scrollTop >= limitTop) {
      if (!hasFix) {
        sidebar.classList.add('sidebar-fixed');
        hasFix = true;
      }
    } else {
      if (hasFix) {
        sidebar.classList.remove('sidebar-fixed');
        hasFix = false;
      }
    }
  });
  }
  
</script>
          <div class="section-box box-shadow-wrapper">
            <div class="section bg-color post post-page">
              <div class="article-box">
    <header class="post-header">
  <h1 class="post-title">
    <a class="post-title-link" href="https://harriswilde.github.io/post/qb0i5L7tn/">
      失传的结构体打包艺术
    </a>
  </h1>
  <div class="post-meta">
    
    <span class="meta-item pc-show">
      <i class="fa fa-calendar-o"></i>
      <span>发布于</span>
      <span>2020-02-17</span>
    </span>
    
      <span class="meta-item">
        <span class="post-meta-divider pc-show">|</span>
        <i class="fa fa-folder-o"></i>
        <span class="pc-show">分类于</span>
        
          
            <a href="https://harriswilde.github.io/tag/VC6KZQgdc/">
              <span>C</span>
            </a>、
          
        
          
            <a href="https://harriswilde.github.io/tag/wPpzBFBxL/">
              <span>C++</span>
            </a>、
          
        
          
            <a href="https://harriswilde.github.io/tag/DFrZZfISm/">
              <span>数据结构</span>
            </a>
          
        
      </span>
      <span class="post-meta-divider">|</span>
    
    <span class="meta-item">
      <i class="fa fa-clock-o"></i>
      <span>20分钟</span>
    </span>
    <span class="meta-item">
      <span class="post-meta-divider">|</span>
      <i class="fa fa-file-word-o"></i>
      <span>5423<span class="pc-show">字数</span></span>
    </span>
  </div>
</header>
</div>
              <div class="post-body next-md-body" id="post_body">
                <blockquote>
<p>《失传的结构体打包艺术》(中文版)<br>
转载自：<a href="https://github.com/ludx/The-Lost-Art-of-C-Structure-Packing">https://github.com/ludx/The-Lost-Art-of-C-Structure-Packing</a><br>
作者：Eric S. Raymond<br>
原文链接：<a href="http://www.catb.org/esr/structure-packing/">http://www.catb.org/esr/structure-packing/</a></p>
</blockquote>
<!-- more -->
<h1 id="谁应阅读本文">谁应阅读本文</h1>
<p>本文探讨如何通过手工重新打包C结构体声明，来减小内存空间占用。你需要掌握基本的C语言知识，以理解本文所讲述的内容。</p>
<p>如果你在内存容量受限的嵌入式系统中写程序，或者编写操作系统内核代码，就有必要了解这项技术。如果数据集巨大，应用时常逼近内存极限，这项技术会有所帮助。倘若你非常非常关心如何最大限度地减少处理器缓存段（cache-line）未命中情况的发生，这项技术也有所裨益。</p>
<p>最后，理解这项技术是通往其他C语言艰深话题的门径。若不掌握，就算不上高级C程序员。当你自己也能写出这样的文档，并且有能力明智地评价它之后，才称得上C语言大师。</p>
<h1 id="缘何写作本文">缘何写作本文</h1>
<p>2013年底，我大量应用了一项C语言优化技术，这项技术是我早在二十余年前就已掌握的，但彼时之后，鲜有使用。</p>
<p>我需要减少一个程序对内存空间的占用，它使用了上千（有时甚至几十万）C结构体实例。这个程序是cvs-fast-export，在将其应用于大规模软件仓库时，程序会出现内存耗尽错误。</p>
<p>通过精心调整结构成体员的顺序，可以在这种情况下大幅减少内存占用。其效果显著——在上述案例中，可以减少40%的内存空间。程序应用于更大的软件仓库，也不会因内存耗尽而崩溃。</p>
<p>但随着工作展开，我意识到这项技术在近些年几乎已被遗忘。Web搜索证实了我的想法，现今的C程序员们似乎已不再谈论这些话题，至少从搜索引擎中看不到。维基百科有些条目涉及这一主题，但未曾有人完整阐述。</p>
<p>事出有因。计算机科学课程（正确地）引导人们远离微观优化，转而寻求更理想的算法。计算成本一路走低，令压榨内存的必要性变得越来越低。旧日里，黑客们通过在陌生的硬件架构中跌跌撞撞学习——如今已不多见。</p>
<p>然而这项技术在关键时刻仍颇具价值，并且只要内存容量有限，价值就始终存在。本文意在节省C程序员重新发掘这项技术所需的时间，让他们有精力关注更重要任务。</p>
<h1 id="对齐要求">对齐要求</h1>
<p>首先需要了解的是，对于现代处理器，C编译器在内存中放置基本C数据类型的方式受到约束，以令内存的访问速度更快。</p>
<p>在x86或ARM处理器中，基本C数据类型通常并不存储于内存中的随机字节地址。实际情况是，除char外，所有其他类型都有“对齐要求”：char可起始于任意字节地址，2字节的short必须从偶数字节地址开始，4字节的int或float必须从能被4整除的地址开始，8比特的long和double必须从能被8整除的地址开始。无论signed（有符号）还是unsigned（无符号）都不受影响。</p>
<p>用行话来说，x86和ARM上的基本C类型是“自对齐（self-aligned）”的。关于指针，无论32位（4字节）还是64位（8字节）也都是自对齐的。</p>
<p>自对齐可令访问速度更快，因为它有利于生成单指令（single-instruction）存取这些类型的数据。另一方面，如若没有对齐约束，可能最终不得不通过两个或更多指令访问跨越机器字边界的数据。字符数据是种特殊情况，因其始终处在单一机器字中，所以无论存取何处的字符数据，开销都是一致的。这也就是它不需要对齐的原因。</p>
<p>我提到“现代处理器”，是因为有些老平台强迫C程序违反对齐规则（例如，为int指针分配一个奇怪的地址并试图使用它），不仅令速度减慢，还会导致非法指令错误。例如Sun SPARC芯片就有这种问题。事实上，如果你下定决心，并恰当地在处理器中设置标志位（e18），在x86平台上，也能引发这种错误。</p>
<p>另外，自对齐并非唯一规则。纵观历史，有些处理器，由其是那些缺乏桶式移位器（Barrel shifter）的处理器限制更多。如果你从事嵌入式系统领域编程，有可能掉进这些潜伏于草丛之中的陷阱。小心这种可能。</p>
<p>你还可以通过pragma指令（通常为<code>#pragma pack</code>）强迫编译器不采用处理器惯用的对齐规则。但请别随意运用这种方式，因为它强制生成开销更大、速度更慢的代码。通常，采用我在下文介绍的方式，可以节省相同或相近的内存。</p>
<p>使用#pragma pack的唯一理由是——假如你需让C语言的数据分布，与某种位级别的硬件或协议完全匹配（例如内存映射硬件端口），而违反通用对齐规则又不可避免。如果你处于这种困境，且不了解我所讲述的内容，那你已深陷泥潭，祝君好运。</p>
<h1 id="填充">填充</h1>
<p>我们来看一个关于变量在内存中分布的简单案例。思考形式如下的一系列变量声明，它们处在一个C模块的顶层。</p>
<pre><code class="language-C">char *p;
char c;
int x;
</code></pre>
<p>假如你对数据对齐一无所知，也许以为这3个变量将在内存中占据一段连续空间。也就是说，在32位系统上，一个4字节指针之后紧跟着1字节的char，其后又紧跟着4字节int。在64位系统中，唯一的区别在于指针将占用8字节。</p>
<p>然而实际情况（在x86、ARM或其他采用自对齐类型的平台上）如下。存储p需要自对齐的4或8字节空间，这取决于机器字的大小。这是指针对齐——极其严格。</p>
<p>c紧随其后，但接下来x的4字节对齐要求，将强制在分布中生成了一段空白，仿佛在这段代码中插入了第四个变量，如下所示。</p>
<pre><code class="language-C">char *p;      /* 4 or 8 bytes */
char c;       /* 1 byte */
char pad[3];  /* 3 bytes */
int x;        /* 4 bytes */
</code></pre>
<p>字符数组<code>pad[3]</code>意味着在这个结构体中，有3个字节的空间被浪费掉了。老派术语将其称之为“废液（slop）”。</p>
<p>如果x为2字节short：</p>
<pre><code class="language-C">char *p;
char c;
short x;
</code></pre>
<p>在这个例子中，实际分布将会是：</p>
<pre><code class="language-C">char *p;      /* 4 or 8 bytes */
char c;       /* 1 byte */
char pad[1];  /* 1 byte */
short x;      /* 2 bytes */
</code></pre>
<p>另一方面，如果x为64位系统中的long：</p>
<pre><code class="language-C">char *p;
char c;
long x;
</code></pre>
<p>我们将得到：</p>
<pre><code class="language-C">char *p;     /* 8 bytes */
char c;      /* 1 byte */
char pad[7]; /* 7 bytes */
long x;      /* 8 bytes */
</code></pre>
<p>若你一路仔细读下来，现在可能会思索，何不首先声明较短的变量？</p>
<pre><code class="language-C">char c;
char *p;
int x;
</code></pre>
<p>假如实际内存分布可以写成下面这样：</p>
<pre><code class="language-C">char c;
char pad1[M];
char *p;
char pad2[N];
int x;
</code></pre>
<p>那<code>M</code>与<code>N</code>分别为几何？</p>
<p>首先，在此例中，<code>N</code>将为0，<code>x</code>的地址紧随<code>p</code>之后，能确保是与指针对齐的，因为指针的对齐要求总比int严格。</p>
<p><code>M</code>的值就不易预测了。编译器若是恰好将<code>c</code>映射为机器字的最后一个字节，那么下一个字节（<code>p</code>的第一个字节）将恰好由此开始，并恰好与指针对齐。这种情况下，<code>M</code>将为0。</p>
<p>不过更有可能的情况是，<code>c</code>将被映射为机器字的首字节。于是乎<code>M</code>将会用于填充，以使<code>p</code>指针对齐——32位系统中为3字节，64位系统中为7字节。</p>
<p>中间情况也有可能发生。M的值有可能在0到7之间（32位系统为0到3），因为char可以从机器字的任何位置起始。</p>
<p>倘若你希望这些变量占用的空间更少，那么可以交换<code>x</code>与<code>c</code>的次序。</p>
<pre><code class="language-C">char *p;     /* 8 bytes */
long x;      /* 8 bytes */
char c;      /* 1 byte */
</code></pre>
<p>通常，对于C代码中的少数标量变量（scalar variable），采用调换声明次序的方式能节省几个有限的字节，效果不算明显。而将这种技术应用于非标量变量（nonscalar variable）——尤其是结构体，则要有趣多了。</p>
<p>在讲述这部分内容前，我们先对标量数组做个说明。在具有自对齐类型的平台上，char、short、int、long和指针数组都没有内部填充，每个成员都与下一个成员自动对齐。</p>
<p>在下一节我们将会看到，这种情况对结构体数组并不适用。</p>
<h1 id="结构体的对齐和填充">结构体的对齐和填充</h1>
<p>通常情况下，结构体实例以其最宽的标量成员为基准进行对齐。编译器之所以如此，是因为此乃确保所有成员自对齐，实现快速访问最简便的方法。</p>
<p>此外，在C语言中，结构体的地址，与其第一个成员的地址一致——不存在头填充（leading padding）。小心：在C++中，与结构体相似的类，可能会打破这条规则！（是否真的如此，要看基类和虚拟成员函数是如何实现的，与不同的编译器也有关联。）</p>
<p>假如你对此有疑惑，ANSI C提供了一个<code>offsetof()</code>宏，可用于读取结构体成员位移。</p>
<p>考虑这个结构体：</p>
<pre><code class="language-C">struct foo1 {
    char *p;
    char c;
    long x;
};
</code></pre>
<p>假定处在64位系统中，任何<code>struct fool</code>的实例都采用8字节对齐。不出所料，其内存分布将会像下面这样：</p>
<pre><code class="language-C">struct foo1 {
    char *p;     /* 8 bytes */
    char c;      /* 1 byte */
    char pad[7]; /* 7 bytes */
    long x;      /* 8 bytes */
};
</code></pre>
<p>看起来仿佛与这些类型的变量单独声明别无二致。但假如我们将<code>c</code>放在首位，就会发现情况并非如此。</p>
<pre><code class="language-C">struct foo2 {
    char c;      /* 1 byte */
    char pad[7]; /* 7 bytes */
    char *p;     /* 8 bytes */
    long x;      /* 8 bytes */
};
</code></pre>
<p>如果成员是互不关联的变量，<code>c</code>便可能从任意位置起始，<code>pad</code>的大小则不再固定。因为<code>struct foo2</code>的指针需要与其最宽的成员为基准对齐，这变得不再可能。现在<code>c</code>需要指针对齐，接下来填充的7个字节被锁定了。</p>
<p>现在，我们来谈谈结构体的尾填充（trailing padding）。为了解释它，需要引入一个基本概念，我将其称为结构体的“跨步地址（stride address）”。它是在结构体数据之后，与结构体对齐一致的首个地址。</p>
<p>结构体尾填充的通用法则是：编译器将会对结构体进行尾填充，直至它的跨步地址。这条法则决定了<code>sizeof()</code>的返回值。</p>
<p>考虑64位x86或ARM系统中的这个例子：</p>
<pre><code class="language-C">struct foo3 {
    char *p;     /* 8 bytes */
    char c;      /* 1 byte */
};

struct foo3 singleton;
struct foo3 quad[4];
</code></pre>
<p>你以为<code>sizeof(struct foo3)</code>的值是9，但实际是16。它的跨步地址是<code>(&amp;p)[2]</code>。于是，在<code>quad</code>数组中，每个成员都有7字节的尾填充，因为下个结构体的首个成员需要在８字节边界上对齐。内存分布就好像这个结构是这样声明的：</p>
<pre><code class="language-C">struct foo3 {
    char *p;     /* 8 bytes */
    char c;      /* 1 byte */
    char pad[7];
};
</code></pre>
<p>作为对比，思考下面的例子：</p>
<pre><code class="language-C">struct foo4 {
    short s;     /* 2 bytes */
    char c;      /* 1 byte */
};
</code></pre>
<p>因为<code>s</code>只需要2字节对齐，跨步地址仅在<code>c</code>的1字节之后，整个<code>struct foo4</code>也只需要1字节的尾填充。形式如下：</p>
<pre><code class="language-C">struct foo4 {
    short s;     /* 2 bytes */
    char c;      /* 1 byte */
    char pad[1];
};
</code></pre>
<p><code>sizeof(struct foo4)</code>的返回值将为4。</p>
<p>现在我们考虑位域（bitfields）。利用位域，你能声明比字符宽度更小的成员，低至１位，例如：</p>
<pre><code class="language-C">struct foo5 {
    short s;
    char c;
    int flip:1;
    int nybble:4;
    int septet:7;
};
</code></pre>
<p>关于位域需要了解的是，它们是由字（或字节）层面的掩码和移位指令实现的。从编译器的角度来看，<code>struct foo5</code>中的位域就像２字节、16位的字符数组，只用到了其中12位。为了使结构体的长度是其最宽成员长度<code>sizeof(short)</code>的整数倍，接下来进行了填充。</p>
<pre><code class="language-C">struct foo5 {
    short s;       /* 2 bytes */
    char c;        /* 1 byte */
    int flip:1;    /* total 1 bit */
    int nybble:4;  /* total 5 bits */
    int septet:7;  /* total 12 bits */
    int pad1:4;    /* total 16 bits = 2 bytes */
    char pad2;     /* 1 byte */
};
</code></pre>
<p>这是最后一个重要细节：如果你的结构体中含有结构体成员，内层结构体也要和最长的标量有相同的对齐。假如你写下了这段代码：</p>
<pre><code class="language-C">struct foo6 {
    char c;
    struct foo5 {
        char *p;
        short x;
    } inner;
};
</code></pre>
<p>内层结构体成员<code>char *p</code>强迫外层结构体与内层结构体指针对齐一致。在64位系统中，实际的内存分布将类似这样：</p>
<pre><code class="language-C">struct foo6 {
    char c;           /* 1 byte */
    char pad1[7];     /* 7 bytes */
    struct foo6_inner {
        char *p;      /* 8 bytes */
        short x;      /* 2 bytes */
        char pad2[6]; /* 6 bytes */
    } inner;
};
</code></pre>
<p>它启示我们，能通过重新打包节省空间。24个字节中，有13个为填充，浪费了超过50%的空间！</p>
<h1 id="结构体成员重排">结构体成员重排</h1>
<p>理解了编译器在结构体中间和尾部插入填充的原因与方式后，我们来看看如何榨出这些废液。此即结构体打包的技艺。</p>
<p>首先注意，废液只存在于两处。其一是较大的数据类型（需要更严格的对齐）跟在较小的数据类型之后。其二是结构体自然结束的位置在跨步地址之前，这里需要填充，以使下个结构体能正确地对齐。</p>
<p>消除废液最简单的方式，是按对齐值递减重新对结构体成员排序。即让所有指针对齐成员排在最前面，因为在64位系统中它们占用8字节；然后是4字节的int；再然后是2字节的short，最后是字符。</p>
<p>因此，以简单的链表结构体为例：</p>
<pre><code class="language-C">struct foo7 {
    char c;
    struct foo7 *p;
    short x;
};
</code></pre>
<p>将隐含的废液写明，形式如下：</p>
<pre><code class="language-C">struct foo7 {
    char c;         /* 1 byte */
    char pad1[7];   /* 7 bytes */
    struct foo7 *p; /* 8 bytes */
    short x;        /* 2 bytes */
    char pad2[6];   /* 6 bytes */
};
</code></pre>
<p>总共是24字节。如果按长度重排，我们得到：</p>
<pre><code class="language-C">struct foo8 {
    struct foo8 *p;
    short x;
    char c;
};
</code></pre>
<p>考虑到自对齐，我们看到所有数据域之间都不需填充。因为有较严对齐要求（更长）成员的跨步地址对不太严对齐要求的（更短）成员来说，总是合法的对齐地址。重打包过的结构体只需要尾填充：</p>
<pre><code class="language-C">struct foo8 {
    struct foo8 *p; /* 8 bytes */
    short x;        /* 2 bytes */
    char c;         /* 1 byte */
    char pad[5];    /* 5 bytes */
};
</code></pre>
<p>重新打包将空间降为16字节。也许看起来不算很多，但假如这个链表的长度有20万呢？将会积少成多。</p>
<p>注意，重新打包不能确保在所有情况下都能节省空间。将这项技术应用于更靠前<code>struct foo6</code>的那个例子，我们得到：</p>
<pre><code class="language-C">struct foo9 {
    struct foo9_inner {
        char *p;      /* 8 bytes */
        int x;        /* 4 bytes */
    } inner;
    char c;           /* 1 byte */
};
</code></pre>
<p>将填充写明：</p>
<pre><code class="language-C">struct foo9 {
    struct foo9_inner {
        char *p;      /* 8 bytes */
        int x;        /* 4 bytes */
        char pad[4];  /* 4 bytes */
    } inner;
    char c;           /* 1 byte */
    char pad[7];      /* 7 bytes */
};
</code></pre>
<p>结果还是24字节，因为<code>c</code>无法作为内层结构体的尾填充。要想节省空间，你需要得新设计数据结构。</p>
<h1 id="棘手的标量案例">棘手的标量案例</h1>
<p>只有在符号调试器能显示枚举类型的名称而非原始整型数字时，使用枚举来代替<code>#define</code>才是个好办法。然而，尽管枚举必定与某种整型兼容，但Ｃ标准却没有指明究竟是何种底层整型。</p>
<p>请当心，重打包结构体时，枚举型变量通常是int，这与编译器相关；但也可能是short、long、甚至默认为char。编译器可能会有progma预处理指令或命令行选项指定枚举的尺寸。</p>
<p><code>long double</code>是个类似的故障点。有些C平台以80位实现，有些是128位，还有些80位平台将其填充到96或128位。</p>
<p>以上两种情况，最好用<code>sizeof()</code>来检查存储尺寸。</p>
<p>最后，在x86 Linux系统中，double有时会破自对齐规则的例；在结构体内，8字节的double可能只要求4字节对齐，而在结构体外，独立的double变量又是8字节自对齐。这与编译器和选项有关。</p>
<h1 id="可读性与缓存局部性">可读性与缓存局部性</h1>
<p>尽管按尺寸重排是最简单的消除废液的方式，却不一定是正确的方式。还有两个问题需要考量：可读性与缓存局部性。</p>
<p>程序不仅与计算机交流，还与其他人交流。甚至（尤其是！）交流的对象只有将来你自己时，代码可读性依然重要。</p>
<p>笨拙地、机械地重排结构体可能有损可读性。倘若有可能，最好这样重排成员：将语义相关的数据放在一起，形成连贯的组。最理想的情况是，结构体的设计应与程序的设计相通。</p>
<p>当程序频繁访问某一结构体或其一部分时，若能将其放入一个缓存段，对提高性能颇有帮助。缓存段是这样的内存块——当处理器获取内存中的任何单个地址时，会把整块数据都取出来。　在64位x86上，一个缓存段为64字节，它开始于自对齐的地址。其他平台通常为32字节。</p>
<p>为保持可读性所做的工作（将相关和同时访问的数据放在临近位置）也会提高缓存段的局部性。这些都是需要明智地重排，并对数据的存取模式了然于心的原因。</p>
<p>如果代码从多个线程并发访问同一结构体，还存在第三个问题：缓存段弹跳（cache line bouncing）。为了尽量减少昂贵的总线通信，应当这样安排数据——在一个更紧凑的循环里，从一个缓存段中读数据，而向另一个写入数据。</p>
<p>是的，某些时候，这种做法与前文将相关数据放入与缓存段长度相同块的做法矛盾。多线程的确是个难题。缓存段弹跳和其他多线程优化问题是很高级的话题，值得单独为它们写份指导。这里我所能做的，只是让你了解有这些问题存在。</p>
<h1 id="其他打包技术">其他打包技术</h1>
<p>在为结构体瘦身时，重排序与其他技术结合在一起效果最好。例如结构体中有几个布尔标志，可以考虑将其压缩成1位的位域，然后把它们打包放在原本可能成为废液的地方。</p>
<p>你可能会有一点儿存取时间的损失，但只要将工作集合压缩得足够小，那点损失可以靠避免缓存未命中补偿。</p>
<p>更通用的原则是，选择能把数据类型缩短的方法。以cvs-fast-export为例，我使用的一个压缩方法是：利用RCS和CVS在1982年前还不存在这个事实，我弃用了64位的Unix<code>time_t</code>（在1970年开始为零），转而用了一个32位的、从1982-01-01T00:00:00开始的偏移量；这样日期会覆盖到2118年。（注意：若使用这类技巧，要用边界条件检查以防讨厌的Bug！）</p>
<p>这不仅减小了结构体的可见尺寸，还可以消除废液和/或创造额外的机会来进行重新排序。这种良性串连的效果不难被触发。</p>
<p>最冒险的打包方法是使用union。假如你知道结构体中的某些域永远不会跟另一些域共同使用，可以考虑用union共享它们存储空间。不过请特别小心并用回归测试验证。因为如果分析出现一丁点儿错误，就会引发从程序崩溃到微妙数据损坏（这种情况糟得多）间的各种错误。</p>
<h1 id="工具">工具</h1>
<p>clang编译器有个Wpadded选项，可以生成有关对齐和填充的信息。</p>
<p>还有个叫pahole的工具，我自己没用过，但据说口碑很好。该工具与编译器协同工作，生成关于结构体填充、对齐和缓存段边界报告。</p>
<h1 id="证明和例外">证明和例外</h1>
<p>读者可以下载一段程序源代码<a href="http://www.catb.org/esr/structure-packing/packtest.c">packtest.c</a>，验证上文有关标量和结构体尺寸的结论。</p>
<p>如果你仔细检查各种编译器、选项和罕见硬件的稀奇组合，会发现我前面提到的部分规则存在例外。越早期的处理器设计例外越常见。</p>
<p>理解这些规则的第二个层次是，知其何时及如何会被打破。在我学习它们的日子里（1980年代早期），我们把不理解这些规则的人称为“所有机器都是VAX综合症”的牺牲品。记住，世上所有电脑并非都是PC。</p>

              </div>
              <div class="post-footer">
  <ul class="post-copyright">
    <li class="post-copyright-author">
      <strong>本文作者：</strong>
      TechZone
    </li>
    <li class="post-copyright-link">
      <strong>本文链接：</strong>
      <a href="https://harriswilde.github.io/post/qb0i5L7tn/" title="失传的结构体打包艺术">失传的结构体打包艺术</a>
    </li>
    <li class="post-copyright-license">
      <strong>版权声明： </strong>
      本博客所有文章除特别声明外，转载请注明出处！
    </li>
  </ul>
  <div class="tags">
    
      <a href="https://harriswilde.github.io/tag/VC6KZQgdc/"># C</a>
    
      <a href="https://harriswilde.github.io/tag/wPpzBFBxL/"># C++</a>
    
      <a href="https://harriswilde.github.io/tag/DFrZZfISm/"># 数据结构</a>
    
  </div>
  <div class="nav">
    <div class="nav-prev">
      
        <i class="fa fa-chevron-left"></i>
        <a class="nav-pc-next" title="C语言之结构体（上）" href="https://harriswilde.github.io/post/M4QwK7i-6/">C语言之结构体（上）</a class="nav-pc-next">
        <a class="nav-mobile-prev" title="C语言之结构体（上）" href="https://harriswilde.github.io/post/M4QwK7i-6/">上一篇</a>
      
    </div>
    <div class="nav-next">
      
        <a class="nav-pc-next" title="The Lost Art of Structure Packing" href="https://harriswilde.github.io/post/LUjp1bkYi/">The Lost Art of Structure Packing</a>
        <a class="nav-mobile-next" title="The Lost Art of Structure Packing" href="https://harriswilde.github.io/post/LUjp1bkYi/">下一篇</a>
        <i class="fa fa-chevron-right"></i>
      
    </div>
  </div>
</div>
              
            </div>
          </div>
        </div>
      </div>
      <div class="footer-box">
  <footer class="footer">
    <div class="copyright">
      © 2019-2020 | TechZone
    </div>
    <div class="poweredby">
      Powered by HarrisWilde
    </div>
  </footer>
  
  
  <div class="pisces back-to-top" id="back_to_top">
    <i class="fa fa-arrow-up"></i>
    
    <span class="scrollpercent">
      <span id="back_to_top_text">0</span>%
    </span>
    
  </div>
  
  
  
</div>
<script>

  let sideBarOpen = 'sidebar-open';
  let body = document.body;
  let back2Top = document.querySelector('#back_to_top'),
  back2TopText = document.querySelector('#back_to_top_text'),
  drawerBox = document.querySelector('#drawer_box'),
  rightSideBar = document.querySelector('.sidebar'),
  viewport = document.querySelector('body');

  function scrollAnimation(currentY, targetY) {
   
    let needScrollTop = targetY - currentY
    let _currentY = currentY
    setTimeout(() => {
      const dist = Math.ceil(needScrollTop / 10)
      _currentY += dist
      window.scrollTo(_currentY, currentY)
      if (needScrollTop > 10 || needScrollTop < -10) {
        scrollAnimation(_currentY, targetY)
      } else {
        window.scrollTo(_currentY, targetY)
      }
    }, 1)
  }

  back2Top.addEventListener("click", function(e) {
    scrollAnimation(document.scrollingElement.scrollTop, 0);
    e.stopPropagation();
    return false;
  });
  
  window.addEventListener('scroll', function(e) {
    let percent = document.scrollingElement.scrollTop / (document.scrollingElement.scrollHeight - document.scrollingElement.clientHeight) * 100;
    if (percent > 1 && !back2Top.classList.contains('back-top-active')) {
      back2Top.classList.add('back-top-active');
    }
    if (percent == 0) {
      back2Top.classList.remove('back-top-active');
    }
    if (back2TopText) {
      back2TopText.textContent = Math.floor(percent);
    }
  });

  
  let hasCacu = false;
  window.onresize = function() {
    if (window.width > 991) {
      calcuHeight();
    } else {
      hasCacu = false;
    }
  }

  function calcuHeight() {
    // 动态调整站点概览高度
    if (!hasCacu && back2Top.classList.contains('pisces') || back2Top.classList.contains('gemini')) {
      let sideBar = document.querySelector('.sidebar');
      let navUl = document.querySelector('#site_nav');
      sideBar.style = 'margin-top:' + (navUl.offsetHeight + navUl.offsetTop + 15) + 'px;';
      hasCacu = true;
    }
  }
  calcuHeight();
  
  let open = false, MOTION_TIME = 300, RIGHT_MOVE_DIS = '320px';

  if (drawerBox) {
    let rightMotions = document.querySelectorAll('.right-motion');
    let right = drawerBox.classList.contains('right');

    let transitionDir = right ? "transition.slideRightIn" : "transition.slideLeftIn";

    let openProp, closeProp;
    if (right) {
      openProp = {
        paddingRight: RIGHT_MOVE_DIS 
      };
      closeProp = {
        paddingRight: '0px'
      };
    } else {
      openProp = {
        paddingLeft: RIGHT_MOVE_DIS 
      };
      closeProp = {
        paddingLeft: '0px'
      };
    }

    drawerBox.onclick = function() {
      open = !open;
      window.Velocity(rightSideBar, 'stop');
      window.Velocity(viewport, 'stop');
      window.Velocity(rightMotions, 'stop');
      if (open) {
        window.Velocity(rightSideBar, {
          width: RIGHT_MOVE_DIS
        }, {
          duration: MOTION_TIME,
          begin: function() {
            window.Velocity(rightMotions, transitionDir,{ });
          }
        })
        window.Velocity(viewport, openProp,{
          duration: MOTION_TIME
        });
      } else {
        window.Velocity(rightSideBar, {
          width: '0px'
        }, {
          duration: MOTION_TIME,
          begin: function() {
            window.Velocity(rightMotions, {
              opacity: 0
            });
          }
        })
        window.Velocity(viewport, closeProp ,{
          duration: MOTION_TIME
        });
      }
      for (let i = 0; i < drawerBox.children.length; i++) {
        drawerBox.children[i].classList.toggle('muse-line');
      }
      drawerBox.classList.toggle(sideBarOpen);
    }
  }

  // 代码高亮
  hljs.initHighlightingOnLoad();
</script>
    </div>
  </body>
  <script src="/media/js/motion.js"></script>
</html>