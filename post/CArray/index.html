<html>
      <head>
        <meta name="viewport" content="width=device-width,minimum-scale=1,maximum-scale=1,initial-scale=1,user-scalable=no" />
        <meta charset="utf-8">
        <meta name="referrer" content="never">
        <title>C语言之数组 | TechZone</title>
        <link rel="stylesheet" href="https://cdn.staticfile.org/KaTeX/0.11.1/katex.min.css">
        <script src="https://cdn.bootcss.com/jquery/3.4.1/jquery.min.js"></script>
        <link rel="stylesheet" href="https://harriswilde.github.io/styles/main.css">
          <script src="https://harriswilde.github.io/media/scripts/mdui.min.js"></script>
        <link rel="stylesheet" href="https://at.alicdn.com/t/font_1306644_jwtuc2zzbrd.css">
        <link href="https://fonts.googleapis.com/css?family=Dancing+Script|Ma+Shan+Zheng&display=swap" rel="stylesheet">
        <script src="https://cdn.bootcss.com/highlight.js/9.15.10/highlight.min.js"></script>
        <script src="https://harriswilde.github.io/media/scripts/script.js"></script>
        <script >hljs.initHighlightingOnLoad();</script>
        

<script async src="https://www.googletagmanager.com/gtag/js?id=UA-155133482-1"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());
  gtag('config', 'UA-155133482-1');
</script>

    </head>
    <body class="mdui-theme-primary-purple mdui-theme-accent-purple">
        <header class="index-img mdui-m-b-3"  style="background-image: url(https://s2.ax1x.com/2019/12/11/QrWPz9.jpg);" >
                          <button class="mdui-btn  mdui-btn-icon mdui-btn-dense mdui-color-theme-500 mdui-ripple yinying mdui-m-t-1 mdui-m-l-1" mdui-menu="{target: '#demo-attr-cascade'}"><i class="mdui-icon material-icons">&#xe5d2;</i></button>
                <ul class="mdui-menu" id="demo-attr-cascade">
                
                        <li class="mdui-menu-item">
                          <a href="/" class="mdui-ripple">我的首页</a>
                        </li>
                
                        <li class="mdui-menu-item">
                          <a href="/archives" class="mdui-ripple">文章归档</a>
                        </li>
                
                        <li class="mdui-menu-item">
                          <a href="/tags" class="mdui-ripple">标签分类</a>
                        </li>
                
                        <li class="mdui-menu-item">
                          <a href="/post/about" class="mdui-ripple">关于作者</a>
                        </li>
                
                        <li class="mdui-menu-item">
                          <a href="https://www.jianshu.com/u/766d2f134900" class="mdui-ripple">我的简书</a>
                        </li>
                
                      </ul>

        </header>
        <div class="mdui-container post">
                <div class="mdui-row">
                        <div class="mdui-col-md-8 mdui-col-offset-md-2 ">
                         <article class="mdui-shadow-10 mdui-p-a-2 post-list">
                           <div class="mdui-typo-display-1 mdui-m-b-3">C语言之数组</div>
                           <a  class="index-list-biaoqian ">2019-12-07</a>
                           <div class="mdui-typo mdui-m-t-3 post-neirong"><h2 id="techzoneharris">——TechZone(Harris)</h2>
<hr>
<p>学完了前面几种基础语法之后，你可能会渐渐发现，现有的数据的记录方式，已经无法很好地解决我们接下来要解决的问题。比如有一天，老师找你计算一下全班同学的平均成绩。那么你就会开始思考如何存储全班的成绩。按照之前学习的知识，我们可以定义<code>a1</code> <code>a2</code> <code>a3</code> <code>……</code>。但是，这样未免也太麻烦了，如果要记录全省人民的身高数据呢？如果下个学期班里学生人数有变化呢？</p>
<p>你会发现，种种原因，导致了我们编写的程序很繁杂，不够灵活。那么这样，编程也就没有太大的必要了。好在，C语言提供了一种存储数据的方式，叫做<strong>数组</strong>。</p>
<hr>
<p>数组，就是存放一堆<strong>同类型</strong>的数据的容器。比如刚刚的例子，我们要存储学生的成绩，这时候数组就可以大显神威了。</p>
<h3 id="定义一维数组">定义一维数组</h3>
<p>定义一维数组的方法很简单，只需要指定元素的类型和存放的数量即可。</p>
<p><code>类型 数组名[元素个数]</code></p>
<p>比如：</p>
<pre><code class="language-c">int Score1[50];//定义一个叫Score1的整型数组，有50个元素
float Score2[30];//定义一个叫Score2的浮点型数组，有30个元素
double Score3[20];//定义一个叫Score3的双精度浮点型数组，有20个元素
char Str[10];//定义一个叫Str的字符型数组，有10个元素
</code></pre>
<p>数组一旦被定义，在其生命周期内，就<strong>不可能被改变</strong>(其实是在内存中开辟了一段连续的空间了)。</p>
<h3 id="访问数组">访问数组</h3>
<p>访问数组的方法和定义有点类似，但是如果混淆了的话，那可就不是什么好事了。</p>
<p><code>数组名[下标]</code></p>
<p>方括号里面的，实际上是指的数组的<strong>下标</strong>，也可以叫<strong>索引</strong>。需要注意的是，下标的计数是从<code>0</code>开始的，最大的下标是<code>(元素个数-1)</code>。也就是说，如果我<code>int Score[10]</code>之后，那么我想访问第一个元素，就是这样<code>Score[0]</code>，如果要访问最后一个元素，就是<code>Score[9]</code>。</p>
<p>之前看到过一个段子，大概意思是说程序员数数都喜欢从0开始数。如果你是刚刚接触编程，那么你也要开始习惯从0开始计数的这种思路。</p>
<p>其实，并不是C语言才开始有数组，FORTRAN语言就有数组了。但是下标从0开始计数这种方式，是从C语言才开始有的。当时开发C语言编译器的人们就想让编译器能够更加简单，如果从0开始，那么编译器实际上能够少做很多事情，于是就多了这么一个设定。随着计算机科学的发展，后面出现的优秀的语言也越来越多。但是我们所说的&quot;C-Like”语言，也就是参照C语言来开发的语言，也都继承了C语言这一“优良传统”，因此就有了程序员数数是从0开始的这么一种说法。</p>
<p>讲到这里，想必大家也就会明白之前为什么我们在循环的时候，初始值都是设定为0的了。像这样：</p>
<pre><code class="language-c">for (i = 0; i &lt; 10; i++)
{
    ...
}
</code></pre>
<p>而不是像这样写(当然也没错)：</p>
<pre><code class="language-c">for (i = 1; i &lt;= 10; i++)
{
    ...
}
</code></pre>
<p>这就是因为，我们在使用循环的时候，经常会配合数组一起来使用，那么我们循环设置成和数组下标的计数方法一样，有利于我们使用数组。</p>
<p>还是回到我们最初的那个问题，存储班里面学生的成绩，然后计算出平均值：</p>
<pre><code class="language-c">//Example 01
#include &lt;stdio.h&gt;
int main(void)
{
    int s[10];//假定我们班上有10个人
    int i;
    double sum = 0;
    for (i = 0; i &lt; 10; i++)
    {
        printf(&quot;请输入第 %d 位同学的成绩：&quot;, i + 1);
            scanf(&quot;%d&quot;, &amp;s[i]);
        sum += s[i];
    }
    printf(&quot;成绩录入完毕，该次考试的平均分是：%.2f\n&quot;, sum/10);
    return 0;
}
</code></pre>
<p>程序实现如下：</p>
<pre><code>//Consequence 01
请输入第 1 位同学的成绩：80
请输入第 2 位同学的成绩：90
请输入第 3 位同学的成绩：70
请输入第 4 位同学的成绩：66
请输入第 5 位同学的成绩：77
请输入第 6 位同学的成绩：54
请输入第 7 位同学的成绩：67
请输入第 8 位同学的成绩：86
请输入第 9 位同学的成绩：78
请输入第 10 位同学的成绩：65
成绩录入完毕，该次考试的平均分是：73.30
</code></pre>
<h3 id="数组的初始化">数组的初始化</h3>
<p>在定义数组的时候同时对其<strong>各个元素</strong>进行赋值，称为数组的初始化。在刚刚的代码中，我们定义了数组，但却没有在定义的时候就初始化，而是在循环中进行赋值。那么初始化数组一般有下面几种方法：</p>
<ol>
<li>
<p>将数组中所有的元素初始化为0，可以这么写：</p>
<pre><code class="language-c">int a[10] = {0};
</code></pre>
</li>
<li>
<p>如果要赋予不同的值，用逗号分开即可：</p>
<pre><code class="language-c">int a[5] = {1, 2, 3, 4, 5};
</code></pre>
</li>
<li>
<p>给部分元素赋值，剩下的自动初始化为0：</p>
<pre><code class="language-c">int a[10] = {1, 2 ,3};//剩下的全部为0
</code></pre>
</li>
<li>
<p>也可以偷懒只给出每个元素的值，让编译器自己判断数组长度：</p>
<pre><code class="language-c">int a[] = {1, 2, 3, 4, 5};
</code></pre>
</li>
<li>
<p>C99中增加了一种特性，指定元素进行赋值，剩下的自动初始化为0。也就是说，可以针对不连续的几个元素赋值：</p>
<pre><code class="language-c">int a[10] = { [3] = 3, [5] = 5, [8] = 8 };//编译的时候记得加上-std=c99选项
</code></pre>
</li>
</ol>
<p>那可能你会说了，”你刚刚提到的一个问题还没解决呢！要是班里的人数变了怎么办呢？“</p>
<p>没错，我们现在就来解决下这个问题。</p>
<h3 id="可变长数组">可变长数组</h3>
<p>在C99标准推出之前，要求定义数组的时候，数组的维度必须是<strong>常量表达式</strong>或者<strong>const常量</strong>，但是C99标准中，支持了变量定义数组，那么，我们就可以将第一次的代码改成这样：</p>
<pre><code class="language-c">//Example 02
#include &lt;stdio.h&gt;
int main(void)
{
    int Member;
    printf(&quot;请输入班级人数：&quot;);
    scanf(&quot;%d&quot;, &amp;Member);
    int s[Member];//使用用户输入的值来确定数组的大小
    int i;
    float sum = 0;
    for (i = 0; i &lt; Member; i++)
    {
        printf(&quot;请输入第 %d 位同学的成绩：&quot;, i + 1);
            scanf(&quot;%d&quot;, &amp;s[i]);
        sum += s[i];
    }
    printf(&quot;成绩录入完毕，该次考试的平均分是：%.2f\n&quot;, sum/Menber);
    return 0;
}
</code></pre>
<p>这样，在开始存储成绩之前，先让使用者告诉程序班里有多少学生，该开辟多大的数组，然后就完美解决了人数变动的问题。</p>
<p>注意，这里的”可变长数组“是指的数组在程序运行的时候才<strong>确定长度</strong>，也就是说每一次运行都不一定一样。但是数组一旦被创建，在其生命周期内就不会再改变了，这是数组的<strong>根本特性</strong>。</p>
<p>但是，如果有的同学使用的是Visual Studio的话，是不支持C99的这个特性的(我也不知道为什么巨硬不支持，明明这么好的特性)，那么就只能使用<strong>动态分配</strong>的方法来创建数组。放在这里来讲的话有些超纲，后面会讲到。</p>
<h3 id="字符型数组">字符型数组</h3>
<p>还记得之前说过，C语言是没有字符串这种类型的。那么C语言处理字符串有两种方法：<strong>字符串常量</strong>和<strong>字符型数组</strong>。字符串常量是指用<strong>双引号</strong>括起来的字符串，一旦确定下来就<strong>无法改变</strong>。一般我们会更多地倾向于使用更加灵活的<strong>字符型数组</strong>。这样，数组中的每一个元素表示一个字符，当然还要多一位来表示<code>\0</code>。</p>
<p>那么接下来就讲讲字符串的一些方法，因为字符串实在是太重要了。</p>
<h4 id="获取字符串的长度">获取字符串的长度</h4>
<p>计算字符串的长度使用<code>strlen</code>函数（这是长度，不是尺寸）,这个函数包含在<code>string.h</code>中</p>
<pre><code class="language-c">#include &lt;string.h&gt;
...
size_t strlen ( const char * str );
</code></pre>
<p>这个方法是不包含字符串末尾的<code>\0</code>的。且看下面的例子：</p>
<pre><code class="language-c">//Example 03
#include &lt;stdio.h&gt;
#include &lt;string.h&gt;
int main(void)
{
    char str[] = &quot;I love Clang!&quot;;
    printf(&quot;sizeof str = %d\n&quot;, sizeof(str));
    printf(&quot;strlen str = %u\n&quot;, strlen(str));
    return 0;
}
</code></pre>
<p>运行结果如下：</p>
<pre><code>//Consequence 03
sizeof str = 14
strlen str = 13
</code></pre>
<p>除了验证不包含<code>\0</code>以外，我们还可以看到，<code>strlen</code>函数返回的是<code>size_t</code>而不是<code>int</code>。<code>size_t</code>被定义在<code>stddef.h</code>中，实际上就是<strong>无符号整型</strong>。</p>
<h4 id="复制字符串">复制字符串</h4>
<p>估计在第一次见到这个词的时候，你的大脑浮现出来的就是使用赋值符号<code>=</code>，但是，这是<strong>错的</strong>……</p>
<p>字符串的复制应该使用<code>strcpy</code>和<code>strncpy</code>来实现。</p>
<pre><code class="language-c">#include &lt;string.h&gt;
...
char *strcpy (char *dest, const char *src);
char *strncpy (char *dest, const char *src, size_t n);
</code></pre>
<p>不多废话，且看下面的例子：</p>
<pre><code class="language-c">//Example 04
#include &lt;stdio.h&gt;
#include &lt;string.h&gt;
int main(void)
{
	char str1[] = &quot;Original String&quot;;
	char str2[] = &quot;New String&quot;;
	char str3[100];
	strcpy(str1, str2);
	strcpy(str3, &quot;Successfully Copied&quot;);
	printf(&quot;\
str1: %s\n\
str2: %s\n\
str3: %s\n&quot;, \
		str1, str2, str3);
	return 0;
}
</code></pre>
<p>运行结果如下：</p>
<pre><code>//Consequence 04
str1: New String
str2: New String
str3: Successfully Copied
</code></pre>
<p>但是其实这个程序是<strong>有缺陷</strong>的。</p>
<p>我们可以看到，两个数组的长度其实<strong>不一样</strong>，我们现在是把短的复制到长的里面，那么不会有问题。如果上面的<code>str1</code>和<code>str2</code>对调一下，那么就极有可能出问题，这就是我们等会儿要讲的<strong>数组越界</strong>问题。</p>
<p>那么如何解决复制时的这个隐式bug呢？</p>
<p><strong>使用strncpy方法来复制</strong></p>
<p>如果超出的字符不是很多，那么程序有可能能够成功地运行。但是如果两者悬殊的话，那编译运行之后，程序会报<code>Segmentation fault</code>。</p>
<p>因此在复制的时候，我们应该确保不越界，在复制之后不溢出。那么使用<code>strncpy</code>函数，由于增加了一个参数来指定<strong>复制的字符个数</strong>，我们在编写代码的时候就可以规避这样的问题。</p>
<p>举个例子：</p>
<pre><code class="language-c">//Example 05
#include &lt;stdio.h&gt;
#include &lt;string.h&gt;
int main(void)
{
    char str1[] = &quot;TechZone was made by HarrisWilde&quot;;
    char str2[40];
    strncpy(str2, str1, 8);
    str2[8] = '\0';
    printf(&quot;%s\n&quot;, str2);
    return 0;
}
</code></pre>
<p>结果如下：</p>
<pre><code>//Consequence 05
TechZone
</code></pre>
<p>有一个地方要格外小心，<code>strncpy</code>函数<strong>并不会</strong>在字符串的末尾添加<code>\0</code>，因此在使用的时候要注意加上。</p>
<h4 id="连接字符串">连接字符串</h4>
<p>如果你想把一个字符串拼接到另一个后面的话，就可以使用<code>strcat</code>和<code>strncat</code>两个函数来实现。</p>
<pre><code class="language-c">#include &lt;string.h&gt;
...
char *strcat (char *dest, const char *src);
char *strncat (char *dest, const char *src, size_t n);
</code></pre>
<p>可以看到，这个函数的用法和上面复制字符串的用法完全相同，<code>strncat</code>也就是比<code>strcat</code>多了一个指定复制长度的参数罢了。</p>
<p>需要注意的是，这个函数<strong>会</strong>自动在末尾追加一个<code>\0</code>，这和复制不一样，要特别注意区分。</p>
<h4 id="比较字符串">比较字符串</h4>
<p>比较两个字符串，也和上面的一样，有两个类似的函数，<code>strcmp</code>和<code>strncmp</code>。</p>
<pre><code class="language-c">#include &lt;string.h&gt;
...
char *strcmp (char *dest, const char *src);
char *strncmp (char *dest, const char *src, size_t n);
</code></pre>
<p>采用这套函数来比较两个字符串是否相同的时候，如果两个字符串完全一致，那么返回的值为<code>0</code>。这个函数的原理是，从第一个字符开始，依次对比两个字符串中每个字符的ASCII，如果第一个字符串的ASCII小于第二个字符串对应的字符，那么返回一个小于<code>0</code>的数值（通常是<code>-1</code>），如果大于，那就会返回一个大于<code>0</code>的值（通常是<code>1</code>）。</p>
<p><code>strncmp</code>则是增加了一个参数，可以用来仅比较前面n个元素。</p>
<pre><code class="language-c">//Example 06
#include &lt;stdio.h&gt;
#include &lt;string.h&gt;
int main(void)
{
    char str1[10] = &quot;TechZone&quot;;
    char str2[20] = &quot;TechZone&quot;;
    if (!strcmp(str1, str2))
    {
        printf(&quot;Same!\n&quot;);
    }
    else
    {
        printf(&quot;Different!\n&quot;);
    }
    return 0;
}
</code></pre>
<p>运行结果为：</p>
<pre><code>//Consequence 06
Same!
</code></pre>
<h3 id="多维数组">多维数组</h3>
<p>有时候，使用数组来存储还是不够方便，比如，老师让你做一个全班全部科目的成绩的分析。如果利用我们刚刚所学习的数组知识，你可能会这么写：</p>
<pre><code class="language-c">//Example 07
#include &lt;stdio.h&gt;
int main(void)
{
    int chinese[50];
    int math[50];
    int English[50];
    int science[50];
    ...
}
</code></pre>
<p>但是如果我们使用二维数组的话，那么只需要定义一次就行了。</p>
<p>假设我们有6科。</p>
<p>那么就这样：</p>
<pre><code class="language-c">//Example 07 V2
#include &lt;stdio.h&gt;
int main(void)
{
    int score[6][50];
    ...
}
</code></pre>
<p>这其实就像一个表格一样，二维数组通常也被称为<strong>矩阵</strong>（matrix），将二维数组写成行和列的表示形式，可以形象地帮我们解决一些问题。</p>
<p>访问二维数组也和普通的数组一样，也是从<code>0</code>开始计数的，只不过下标随着维度的变化会增加罢了（比如二维数组就有2个下标）。</p>
<h4 id="二维数组的初始化">二维数组的初始化</h4>
<ol>
<li>
<p>二维数组在内存中是<strong>线性存放</strong>的，因此可以将所有的数据写在一个大括号内：</p>
<pre><code class="language-c">int a[2][3] = {1, 2, 3, 4, 5, 6};
</code></pre>
<p>这样就是先将第一行的三个元素初始化，然后再初始化第二行的元素。</p>
</li>
<li>
<p>为了更直观地表达我们可以这么写：</p>
<pre><code class="language-c">int a[2][3] = {
    {1, 2, 3},
    {4, 5, 6}
};
</code></pre>
</li>
<li>
<p>二维数组也可以仅对<strong>部分元素</strong>赋值：</p>
<pre><code class="language-c">int a[2][3] = {{1}, {4}};
</code></pre>
<p>这样写只是对各行的第一列元素赋值，其余的全部为0.</p>
</li>
<li>
<p>如果希望全部为0，那么可以这么写：</p>
<pre><code class="language-c">int a[2][3] = {0};
</code></pre>
</li>
<li>
<p>C99中增加的指定赋值的特性，这里也可以适用。其余未被操作的元素为<code>0</code>。</p>
<pre><code class="language-c">int a[2][3] = {[0][0] = 1, [1][2] = 6};
</code></pre>
</li>
<li>
<p>二维数组也可以偷懒，但是<strong>只有第一维度</strong>的元素个数可以不写，其他的都要写上：</p>
<pre><code class="language-c">int a[][3] = {
    {1, 2, 3},
    {4, 5, 6}
};
</code></pre>
</li>
</ol>
<h3 id="数组越界">数组越界</h3>
<p>我们刚刚说过了，我们在写程序的时候，尽量要把越界的情况通过代码的努力来规避。那么，可能有的小伙伴比较感兴趣，如果越界了，会发生什么呢？</p>
<p>那好，咱们就来试试。</p>
<pre><code class="language-c">//Example 08
#include &lt;stdio.h&gt;

void f();

int main(void)
{
    f();
    return 0;
}

void f()
{
    int a[10];
    a[10] = 0;//这里我们写到了一个不存在的下标里面
}
</code></pre>
<p>我们来跑一下这个程序。</p>
<p>笔者使用的Visual Studio 2019给出了以下的错误提示：</p>
<pre><code>//Consequence 08
Run-Time Check Failure #2 - Stack around the variable 'a' was corrupted.
</code></pre>
<p>它发现了我在写入一个<strong>错误的地址</strong>。并且还给了我两个<strong>warning</strong>：</p>
<pre><code>警告	C6201	索引“10”超出了“0”至“9”的有效范围(对于可能在堆栈中分配的缓冲区“a”)。
警告	C6386	写入到“a”时缓冲区溢出: 可写大小为“40”个字节，但可能写入了“44”个字节。	
</code></pre>
<p>如果我们像普通程序员一样，不管代码warning，直接强制执行，试试会发生什么。</p>
<p>为了更直观体现，我们把代码改成这样：</p>
<pre><code class="language-c">//Example 08
#include &lt;stdio.h&gt;

void f();

int main(void)
{
    f();
    printf(&quot;Here\n&quot;);//我们加了这句，如果函数正常执行完毕了，就可以看到这个语句的输出
    return 0;
}

void f()
{
    int a[10];
    a[10] = 0;
}
</code></pre>
<p>还是出现了这句：</p>
<pre><code>Run-Time Check Failure #2 - Stack around the variable 'a' was corrupted.
</code></pre>
<p>控制台上面没有看到<code>Here</code>的输出，说明函数还没有执行完，程序就已经<strong>崩溃</strong>了，根本没办法执行到输出。</p>
<p>但是，为什么编译器没有给我<strong>error</strong>，而是给了我<strong>warning</strong>呢？</p>
<p>有的编译器可能连warning都没有。</p>
<p>实际上，我们在对<code>a[10]</code>写入的时候，其实是<strong>成功</strong>了的。只不过我们把<code>a[10]</code>写在了一个<strong>不该写的地方</strong>（实际上就是这段数组内存的后面），干扰到了其他东西的运行，程序就有可能会崩溃。如果后面的内存为空或者是没有被回收的垃圾内存，那么就没关系，但是如果是有用的内存，出问题就很正常了。</p>
<p>有时候我们写了一个程序，可能这次运行没问题，下一次运行就出错，或者是在我的电脑上可以，在你的电脑上就不行了等等，都有可能是数组越界，或者是我们后面要学的指针出错了。我们作为创造代码的人，有责任通过代码上的设计，来规避这样的问题，避免程序的崩溃。</p>
<h3 id="长度为0的数组">长度为0的数组？</h3>
<p>有的同学可能会异想天开，说，我可不可以定义一个长度为0的数组呢？</p>
<p>类似于这样：</p>
<pre><code class="language-c">int a[0];
</code></pre>
<p>答案是，完全没问题！</p>
<p>不信的话可以去试试，编译可以通过的，只不过这样的数组不存在任何意义，因为没有符合要求的下标。我们说，最大的下标就是元素个数-1，那么<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>0</mn><mo>−</mo><mn>1</mn><mo>=</mo><mo>−</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">0-1=-1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.72777em;vertical-align:-0.08333em;"></span><span class="mord">0</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.72777em;vertical-align:-0.08333em;"></span><span class="mord">−</span><span class="mord">1</span></span></span></span>，-1显然不是一个合法的下标。所以这样的操作可行，但是没有任何意义。</p>
<p>好了，本节内容就到这里了，希望你能够从中有所收获哦！</p>
</div>
                              <div class="mdui-divider mdui-m-t-3"></div>
                              <div class="mdui-row-xs-2 mdui-m-t-2">
  <div class="mdui-col"> </div>
 <div class="mdui-col"><div class="mdui-text-right "><a href="https://harriswilde.github.io/post/GreatRandom">杂谈·一个神一般的随机算法</a></div> </div>
                                </div>
                                <div class="mdui-divider mdui-m-t-2"></div>
   
 <script src="https://harriswilde.github.io/media/scripts/Valine.min.js"></script>
 <div class="comment"></div>

<script>
      new Valine({
            el: '.comment',



            path: window.location.pathname,
            pageSize: 30,
            avatar:'mm', 
       })

    </script> 
<script>
    if(window.location.hash){
        var checkExist = setInterval(function() {
           if ($(window.location.hash).length) {
              $('html, body').animate({scrollTop: $(window.location.hash).offset().top-90}, 1000);
              clearInterval(checkExist);
           }
        }, 100);
    }
</script>
                         </article>
                 <div class="toc-container mdui-float-right">
                <ul class="markdownIt-TOC">
<li>
<ul>
<li><a href="#techzoneharris">——TechZone(Harris)</a>
<ul>
<li><a href="#%E5%AE%9A%E4%B9%89%E4%B8%80%E7%BB%B4%E6%95%B0%E7%BB%84">定义一维数组</a></li>
<li><a href="#%E8%AE%BF%E9%97%AE%E6%95%B0%E7%BB%84">访问数组</a></li>
<li><a href="#%E6%95%B0%E7%BB%84%E7%9A%84%E5%88%9D%E5%A7%8B%E5%8C%96">数组的初始化</a></li>
<li><a href="#%E5%8F%AF%E5%8F%98%E9%95%BF%E6%95%B0%E7%BB%84">可变长数组</a></li>
<li><a href="#%E5%AD%97%E7%AC%A6%E5%9E%8B%E6%95%B0%E7%BB%84">字符型数组</a>
<ul>
<li><a href="#%E8%8E%B7%E5%8F%96%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9A%84%E9%95%BF%E5%BA%A6">获取字符串的长度</a></li>
<li><a href="#%E5%A4%8D%E5%88%B6%E5%AD%97%E7%AC%A6%E4%B8%B2">复制字符串</a></li>
<li><a href="#%E8%BF%9E%E6%8E%A5%E5%AD%97%E7%AC%A6%E4%B8%B2">连接字符串</a></li>
<li><a href="#%E6%AF%94%E8%BE%83%E5%AD%97%E7%AC%A6%E4%B8%B2">比较字符串</a></li>
</ul>
</li>
<li><a href="#%E5%A4%9A%E7%BB%B4%E6%95%B0%E7%BB%84">多维数组</a>
<ul>
<li><a href="#%E4%BA%8C%E7%BB%B4%E6%95%B0%E7%BB%84%E7%9A%84%E5%88%9D%E5%A7%8B%E5%8C%96">二维数组的初始化</a></li>
</ul>
</li>
<li><a href="#%E6%95%B0%E7%BB%84%E8%B6%8A%E7%95%8C">数组越界</a></li>
<li><a href="#%E9%95%BF%E5%BA%A6%E4%B8%BA0%E7%9A%84%E6%95%B0%E7%BB%84">长度为0的数组？</a></li>
</ul>
</li>
</ul>
</li>
</ul>

              </div>

                        </div>
                 </div>
          
        </div>
        <script data-no-instant>
    (function ($) {
        $.extend({
            adamsOverload: function () {
                $.viewImage({
                    'target'  : '.post-neirong img',
                    'exclude' : '.vsmile-icons img , .song-links-item img',
                    'delay'   : 300
                });
            }
        });
    })(jQuery);
    jQuery.adamsOverload();
</script>
        <footer class="footer mdui-m-t-5 mdui-text-center">
               <nav class="social-links">
                      <ul>
                      
                            
                           
                            
                           
                            
                           
                            
                           
                            
                           
                            
                           
                            
                           
                            
                           
                            
                           
                            
                           
                            
                           
                            
                           
                      </ul>
                    </nav>
                    <div class="copyright">
                      <p>Powered by HarrisWilde <br/> Theme by HarrisWilde × Shanbufun</a></p>
                  </div>
              </footer>
    </body>
</html>