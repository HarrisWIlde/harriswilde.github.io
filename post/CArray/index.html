<!DOCTYPE html>
<html>
  <head>
    <meta charset="UTF-8"/>
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
<meta name="keywords" content="TechZone">
<meta name="description" content="HarrisWilde祝诸君元旦快乐🎉">
<meta name="theme-color" content="#222222">
<title>C语言之数组 | TechZone</title>
<link rel="shortcut icon" href="https://harriswilde.github.io/favicon.ico?v=1583830027737">
<link rel="stylesheet" href="https://harriswilde.github.io/styles/main.css">

<link rel="stylesheet" href="/media/css/pisces.css">

<link rel="stylesheet" href="/media/fonts/font-awesome.css">
<link href="//fonts.googleapis.com/css?family=Monda:300,300italic,400,400italic,700,700italic|Roboto Slab:300,300italic,400,400italic,700,700italic|Rosario:300,300italic,400,400italic,700,700italic|PT Mono:300,300italic,400,400italic,700,700italic&subset=latin,latin-ext" rel="stylesheet" type="text/css">

<link href="/media/hljs/styles/prism.css" rel="stylesheet">  

<script src="/media/hljs/highlight.js"></script>
<script src="https://cdn.jsdelivr.net/npm/velocity-animate@1.5.0/velocity.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/velocity-animate@1.5.0/velocity.ui.min.js"></script>
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.11.1/dist/katex.min.css" integrity="sha384-zB1R0rpPzHqg7Kpt0Aljp8JPLqbXI3bhnPWROx27a9N0Ll6ZP/+DiW/UqRcLbRjq" crossorigin="anonymous">
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.11.1/dist/katex.min.js" integrity="sha384-y23I5Q6l+B6vatafAwxRu/0oK/79VlbSz7Q9aiSZUvyWYIYsd+qj+o24G5ZU2zJz" crossorigin="anonymous"></script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.11.1/dist/contrib/auto-render.min.js" integrity="sha384-kWPLUVMOks5AQFrykwIup5lo0m3iMkkHrD0uJ4H5cjeGihAutqP0yW0J6dpFiVkI" crossorigin="anonymous"
    onload="renderMathInElement(document.body);"></script>

    <meta name="description" content="C语言之数组" />
    <meta name="keywords" content="C,数据结构" />
  </head>
  <body>
    <div class="head-top-line"></div>
    <div class="header-box">
      
<div class=" pisces">
  <header class="header bg-color ">
    <div class="blog-header box-shadow-wrapper bg-color " id="header">
      <div class="nav-toggle" id="nav_toggle">
        <div class="toggle-box">
          <div class="line line-top"></div>
          <div class="line line-center"></div>
          <div class="line line-bottom"></div>
        </div>
      </div>
      <div class="site-meta">       
        <div class="site-title">
          
            <a href="/" class="brand">
              <span>TechZone</span>
            </a>  
          
        </div>
        
          <p class="subtitle">HarrisWilde的官方个人博客</p>
        
      </div>
      <nav class="site-nav" id="site_nav">
        <ul id="nav_ul">
          
            <li class="nav-item ">
              
              
                <a href="/" target="_self">
                  <i class="fa fa-home"></i> 首页
                </a>
              
            </li>
          
            <li class="nav-item ">
              
              
                <a href="/archives" target="_self">
                  <i class="fa fa-archive"></i> 归档
                </a>
              
            </li>
          
            <li class="nav-item ">
              
              
                <a href="/tags" target="_self">
                  <i class="fa fa-tags"></i> 分类
                </a>
              
            </li>
          
            <li class="nav-item ">
              
              
                <a href="https://www.jianshu.com/u/766d2f134900" target="_blank">
                  <i class="fa fa-globe"></i> 简书
                </a>
              
            </li>
          
          <li class="nav-item">
            <a>
              <i class="fa fa-search"></i> 搜索
            </a>
          </li>
        </ul>
      </nav>
    </div>
  </header>
</div>

<script type="text/javascript"> 
 
  let showNav = true;

  let navToggle = document.querySelector('#nav_toggle'),
  siteNav = document.querySelector('#site_nav');
  
  function navClick() {
    let sideBar = document.querySelector('.sidebar');
    let navUl = document.querySelector('#nav_ul');
    navToggle.classList.toggle('nav-toggle-active');
    siteNav.classList.toggle('nav-menu-active');
    if (siteNav.classList.contains('nav-menu-active')) {
      siteNav.style = "height: " + (navUl.children.length * 42) +"px !important";
    } else {
      siteNav.style = "";
    }
  }

  navToggle.addEventListener('click',navClick);  
</script>
    </div>
    <div class="main-continer">
      
      <div class="section-layout pisces ">
        <div class="section-layout-wrapper">
          

<div class="sidebar">
  
    <div class="sidebar-box box-shadow-wrapper bg-color right-motion" id="sidebar">
      
        <div class="post-list-sidebar">
          <div class="sidebar-title">
            <span id="tocSideBar" class="sidebar-title-item sidebar-title-active">文章目录</span>
            <span id="metaSideBar" class="sidebar-title-item">站点概览</span>
          </div>
        </div>
      
      <div class="sidebar-body pisces" id="sidebar_body">
        
          
            <div class="post-side-meta" id="post_side_meta">
              
<div class="sidebar-wrapper box-shadow-wrapper bg-color">
  <div class="sidebar-item">
    <img class="site-author-image right-motion" src="https://harriswilde.github.io/images/avatar.png"/>
    <p class="site-author-name">TechZone</p>
    <p class="site-description right-motion">2020，共同进步！</p>
  </div>
  <div class="sidebar-item side-item-stat right-motion">
    <div class="sidebar-item-box">
      <a href="/archives/">
        
        <span class="site-item-stat-count">29</span>
        <span class="site-item-stat-name">文章</span>
      </a>
    </div>
    <div class="sidebar-item-box">
      <a href="">
        <span class="site-item-stat-count">9</span>
        <span class="site-item-stat-name">分类</span>
      </a>
    </div>
    <div class="sidebar-item-box">
      <a href="/tags/">
        <span class="site-item-stat-count">9</span>
        <span class="site-item-stat-name">标签</span>
      </a>
    </div>
  </div>
  
    
      <div class="sidebar-item">
        <span class="site-item-rss">
            <i class="fa fa-rss"></i>
            <a href="https://harriswilde.github.io/atom.xml" target="_blank">RSS</a>
        </span>
      </div>
    
  
  


</div>
            </div>
            <div class="post-toc sidebar-body-active" id="post_toc" style="opacity: 1;">
              <div class="toc-box right-motion">
  <div class="toc-wrapper auto-number auto" id="toc_wrapper">
    <ul class="markdownIt-TOC">
<li><a href="#%E5%AE%9A%E4%B9%89%E4%B8%80%E7%BB%B4%E6%95%B0%E7%BB%84">定义一维数组</a></li>
<li><a href="#%E8%AE%BF%E9%97%AE%E6%95%B0%E7%BB%84">访问数组</a></li>
<li><a href="#%E6%95%B0%E7%BB%84%E7%9A%84%E5%88%9D%E5%A7%8B%E5%8C%96">数组的初始化</a></li>
<li><a href="#%E5%8F%AF%E5%8F%98%E9%95%BF%E6%95%B0%E7%BB%84">可变长数组</a></li>
<li><a href="#%E5%AD%97%E7%AC%A6%E5%9E%8B%E6%95%B0%E7%BB%84">字符型数组</a>
<ul>
<li><a href="#%E8%8E%B7%E5%8F%96%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9A%84%E9%95%BF%E5%BA%A6">获取字符串的长度</a></li>
<li><a href="#%E5%A4%8D%E5%88%B6%E5%AD%97%E7%AC%A6%E4%B8%B2">复制字符串</a></li>
<li><a href="#%E8%BF%9E%E6%8E%A5%E5%AD%97%E7%AC%A6%E4%B8%B2">连接字符串</a></li>
<li><a href="#%E6%AF%94%E8%BE%83%E5%AD%97%E7%AC%A6%E4%B8%B2">比较字符串</a></li>
</ul>
</li>
<li><a href="#%E5%A4%9A%E7%BB%B4%E6%95%B0%E7%BB%84">多维数组</a>
<ul>
<li><a href="#%E4%BA%8C%E7%BB%B4%E6%95%B0%E7%BB%84%E7%9A%84%E5%88%9D%E5%A7%8B%E5%8C%96">二维数组的初始化</a></li>
</ul>
</li>
<li><a href="#%E6%95%B0%E7%BB%84%E8%B6%8A%E7%95%8C">数组越界</a></li>
<li><a href="#%E9%95%BF%E5%BA%A6%E4%B8%BA0%E7%9A%84%E6%95%B0%E7%BB%84">长度为0的数组？</a></li>
</ul>

  </div>
</div>

<script>

let lastTop = 0, lList = [], hList = [], postBody, lastIndex = -1; 
let active = 'active-show', activeClass = 'active-current';
let tocWrapper = document.querySelector('#toc_wrapper');
let tocContent = tocWrapper.children[0];
let autoNumber = tocWrapper&&tocWrapper.classList.contains('auto-number');

function addTocNumber(elem, deep) {
  if (!elem) {
    return;
  }
  let prop = elem.__proto__;

  if (prop === HTMLUListElement.prototype) {
    for (let i = 0; i < elem.children.length; i++) {
      addTocNumber(elem.children[i], deep + (i + 1) + '.');
    }
  } else if (prop === HTMLLIElement.prototype) {
    // 保存li元素
    lList.push(elem);
    for (let i = 0; i < elem.children.length; i++) {
      let cur = elem.children[i];
      if (cur.__proto__ === HTMLAnchorElement.prototype) {
        if (autoNumber) {
          cur.text =  deep + ' ' + cur.text;
        }
      } else if (cur.__proto__ === HTMLUListElement.prototype) {
        addTocNumber(cur, deep);
      }
    }
  }
}


document.addEventListener('scroll', function(e) {
  if (lList.length <= 0) {
    return;
  }
  let scrollTop = document.scrollingElement.scrollTop + 10;
  let dir;

  if (lastTop - scrollTop > 0) {
    dir = 'up';
  } else {
    dir = 'down';
  }

  lastTop = scrollTop;
  if (scrollTop <= 0) {
    if (lastIndex >= 0 && lastIndex < hList.length) {
      lList[lastIndex].classList.remove(activeClass);
    }
    return;
  }

  let current = 0, hasFind = false;
  for (let i = 0; i < hList.length; i++) {
    if (hList[i].offsetTop > scrollTop) {
      current = i;
      hasFind = true;
      break;
    }
  }
  if (!hasFind && scrollTop > lList[lList.length - 1].offsetTop) {
    current = hList.length - 1;
  } else {
    current--;
  }
  if (dir === 'down') {
    if (current > lastIndex) {
      addActiveClass(current);
      removeActiveClass(lastIndex) 
      lastIndex = current;
      removeParentActiveClass();
      lList[current] && addActiveLiElemment(lList[current].parentElement,tocContent);
    }
  } else {
    if (current < lastIndex) {
      addActiveClass(current);
      removeActiveClass(lastIndex);
      lastIndex = current;
      removeParentActiveClass();
      lList[current] && addActiveLiElemment(lList[current].parentElement,tocContent);
    }
  }
});

function removeParentActiveClass() {
  let parents = tocContent.querySelectorAll('.'+active)
  parents.forEach(function(elem) {
    elem.classList.remove(active);
  });
}

function addActiveClass(index) {
  if (index >= 0 && index < hList.length) {
    lList[index].classList.add(activeClass);
  }
}

function removeActiveClass(index) {
  if (index >= 0 && index < hList.length) {
    lList[index].classList.remove(activeClass);
  }
}

function addActiveLiElemment(elem, parent) {
  if (!elem || elem === parent) {
    return;
  } else {
    if (elem.__proto__ === HTMLLIElement.prototype) {
      elem.classList.add(active);
    }
    addActiveLiElemment(elem.parentElement, parent);
  }
}

function showToc() {
  if (tocWrapper) {
    postBody = document.querySelector('#post_body');
    for (let i = 0; i < postBody.children.length; i++) {
      if (postBody.children[i].__proto__ === HTMLHeadingElement.prototype) {
        hList.push(postBody.children[i]);
      }
    }
    if (tocWrapper.classList.contains('compress')) {
        tocContent.classList.add('closed');
    } else if (tocWrapper.classList.contains('no_compress')){
      tocContent.classList.add('expanded');
    } else {
      if (hList.length > 10) {
        active = 'active-hidden'
        tocContent.classList.add('closed');
      } else {
        tocContent.classList.add('expanded');
      }
    }
  }
}
addTocNumber(tocContent, '');

window.addEventListener('load', function() {
  showToc();
  document.querySelector('#sidebar').style='display: block;';
  tocWrapper.classList.add('toc-active');
  setTimeout(function() {
    if ("createEvent" in document) {
      let evt = document.createEvent("HTMLEvents");
      evt.initEvent("scroll", false, true);
      document.dispatchEvent(evt);
    }
    else {
      document.fireEvent("scroll");
    }
  }, 500)
})

</script>
            </div>
          
        
      </div>
    </div>
  
</div>
<script>
  const SIDEBAR_TITLE_ACTIVE = 'sidebar-title-active';
  const SIDEBAR_BODY_ACTIVE = 'sidebar-body-active';
  const SLIDE_UP_IN = 'slide-up-in';

  let sidebar = document.querySelector('#sidebar'),
  tocSideBar = document.querySelector('#tocSideBar'),
  metaSideBar = document.querySelector('#metaSideBar'),
  postToc = document.querySelector('#post_toc'),
  postSiteMeta = document.querySelector('#post_side_meta'),
  sidebarTitle = document.querySelector('.sidebar-title'),
  sidebarBody = document.querySelector('#sidebar_body');

  tocSideBar && tocSideBar.addEventListener('click', (e) => {
    toggleSidebar(e);
  });

  metaSideBar && metaSideBar.addEventListener('click', (e) => {
    toggleSidebar(e);
  });

  function toggleSidebar(e) {
    let currentTitle = document.querySelector("."+SIDEBAR_TITLE_ACTIVE);
    if (currentTitle == e.srcElement) {
      return ;
    }
    let current, showElement, hideElement;
    if (e.srcElement == metaSideBar) {
      showElement = postSiteMeta;
      hideElement = postToc;
    } else if (e.srcElement == tocSideBar){
      showElement = postToc;
      hideElement = postSiteMeta;
    }
    currentTitle.classList.remove(SIDEBAR_TITLE_ACTIVE);
    e.srcElement.classList.add(SIDEBAR_TITLE_ACTIVE);

    window.Velocity(hideElement, 'stop');
    window.Velocity(hideElement, 'transition.slideUpOut', {
      display: 'none',
      duration: 200,
      complete: function () {
        window.Velocity(showElement, 'transition.slideDownIn', {
          duration: 200
        });
      }
    })
    hideElement.classList.remove(SIDEBAR_BODY_ACTIVE);
    showElement.classList.add(SIDEBAR_BODY_ACTIVE);
  }

  postToc && postToc.addEventListener('transitionend', function() {
    this.classList.remove(SLIDE_UP_IN);
  });

  if (sidebarBody) {
    if (sidebarBody.classList.contains('pisces') || sidebarBody.classList.contains('gemini')) {
      let hasFix = false;
      let scrollEl = document.querySelector('.main-continer');
      let limitTop = document.querySelector('#nav_ul').children.length * 42 + 162;
      window.addEventListener('scroll', function(e) {
        if (document.scrollingElement.scrollTop >= limitTop) {
          if (!hasFix) {
            sidebar.classList.add('sidebar-fixed');
            hasFix = true;
          }
        } else {
          if (hasFix) {
            sidebar.classList.remove('sidebar-fixed');
            hasFix = false;
          }
        }
      });
    }
  }
  
</script>
          <div class="section-box box-shadow-wrapper">
            <div class="section bg-color post post-page">
              <header class="post-header">
  <h1 class="post-title">
    <a class="post-title-link" href="https://harriswilde.github.io/post/CArray/">
      C语言之数组
    </a>
  </h1>
  <div class="post-meta">
    
    <span class="meta-item pc-show">
      <i class="fa fa-calendar-o"></i>
      <span>发布于</span>
      <span>2019-12-07</span>
      <span class="post-meta-divider pc-show">|</span>
    </span>
    
      <span class="meta-item">
        <i class="fa fa-folder-o"></i>
        <span class="pc-show">分类于</span>
        
          
            <a href="https://harriswilde.github.io/tag/VC6KZQgdc/">
              <span>C</span>
            </a>、
          
        
          
            <a href="https://harriswilde.github.io/tag/DFrZZfISm/">
              <span>数据结构</span>
            </a>
          
        
      </span>
      <span class="post-meta-divider">|</span>
    
    <span class="meta-item">
      <i class="fa fa-clock-o"></i>
      <span>18分钟</span>
    </span>
    <span class="meta-item">
      <span class="post-meta-divider">|</span>
      <i class="fa fa-file-word-o"></i>
      <span>4617<span class="pc-show">字数</span></span>
    </span>
    
      <span id="/post/CArray/" class="meta-item pc-show leancloud_visitors">
        <span class="post-meta-divider">|</span>
        <i class="fa fa-eye"></i>
        <span>浏览量：<span class="leancloud-visitors-count" ></span></span>
      </span>
    
  </div>
</header>
              <div class="post-body next-md-body" id="post_body">
                <p>学完了前面几种基础语法之后，你可能会渐渐发现，现有的数据的记录方式，已经无法很好地解决我们接下来要解决的问题。比如有一天，老师找你计算一下全班同学的平均成绩。那么你就会开始思考如何存储全班的成绩。按照之前学习的知识，我们可以定义<code>a1</code> <code>a2</code> <code>a3</code> <code>……</code>。但是，这样未免也太麻烦了，如果要记录全省人民的身高数据呢？如果下个学期班里学生人数有变化呢？</p>
<p>你会发现，种种原因，导致了我们编写的程序很繁杂，不够灵活。那么这样，编程也就没有太大的必要了。好在，C语言提供了一种存储数据的方式，叫做<strong>数组</strong>。</p>
<hr>
<p>数组，就是存放一堆<strong>同类型</strong>的数据的容器。比如刚刚的例子，我们要存储学生的成绩，这时候数组就可以大显神威了。</p>
<h1 id="定义一维数组">定义一维数组</h1>
<p>定义一维数组的方法很简单，只需要指定元素的类型和存放的数量即可。</p>
<p><code>类型 数组名[元素个数]</code></p>
<p>比如：</p>
<pre><code class="language-c">int Score1[50];//定义一个叫Score1的整型数组，有50个元素
float Score2[30];//定义一个叫Score2的浮点型数组，有30个元素
double Score3[20];//定义一个叫Score3的双精度浮点型数组，有20个元素
char Str[10];//定义一个叫Str的字符型数组，有10个元素
</code></pre>
<p>数组一旦被定义，在其生命周期内，就<strong>不可能被改变</strong>(其实是在内存中开辟了一段连续的空间了)。</p>
<h1 id="访问数组">访问数组</h1>
<p>访问数组的方法和定义有点类似，但是如果混淆了的话，那可就不是什么好事了。</p>
<p><code>数组名[下标]</code></p>
<p>方括号里面的，实际上是指的数组的<strong>下标</strong>，也可以叫<strong>索引</strong>。需要注意的是，下标的计数是从<code>0</code>开始的，最大的下标是<code>(元素个数-1)</code>。也就是说，如果我<code>int Score[10]</code>之后，那么我想访问第一个元素，就是这样<code>Score[0]</code>，如果要访问最后一个元素，就是<code>Score[9]</code>。</p>
<p>之前看到过一个段子，大概意思是说程序员数数都喜欢从0开始数。如果你是刚刚接触编程，那么你也要开始习惯从0开始计数的这种思路。</p>
<p>其实，并不是C语言才开始有数组，FORTRAN语言就有数组了。但是下标从0开始计数这种方式，是从C语言才开始有的。当时开发C语言编译器的人们就想让编译器能够更加简单，如果从0开始，那么编译器实际上能够少做很多事情，于是就多了这么一个设定。随着计算机科学的发展，后面出现的优秀的语言也越来越多。但是我们所说的&quot;C-Like”语言，也就是参照C语言来开发的语言，也都继承了C语言这一“优良传统”，因此就有了程序员数数是从0开始的这么一种说法。</p>
<p>讲到这里，想必大家也就会明白之前为什么我们在循环的时候，初始值都是设定为0的了。像这样：</p>
<pre><code class="language-c">for (i = 0; i &lt; 10; i++)
{
    ...
}
</code></pre>
<p>而不是像这样写(当然也没错)：</p>
<pre><code class="language-c">for (i = 1; i &lt;= 10; i++)
{
    ...
}
</code></pre>
<p>这就是因为，我们在使用循环的时候，经常会配合数组一起来使用，那么我们循环设置成和数组下标的计数方法一样，有利于我们使用数组。</p>
<p>还是回到我们最初的那个问题，存储班里面学生的成绩，然后计算出平均值：</p>
<pre><code class="language-c">//Example 01
#include &lt;stdio.h&gt;
int main(void)
{
    int s[10];//假定我们班上有10个人
    int i;
    double sum = 0;
    for (i = 0; i &lt; 10; i++)
    {
        printf(&quot;请输入第 %d 位同学的成绩：&quot;, i + 1);
            scanf(&quot;%d&quot;, &amp;s[i]);
        sum += s[i];
    }
    printf(&quot;成绩录入完毕，该次考试的平均分是：%.2f\n&quot;, sum/10);
    return 0;
}
</code></pre>
<p>程序实现如下：</p>
<pre><code>//Consequence 01
请输入第 1 位同学的成绩：80
请输入第 2 位同学的成绩：90
请输入第 3 位同学的成绩：70
请输入第 4 位同学的成绩：66
请输入第 5 位同学的成绩：77
请输入第 6 位同学的成绩：54
请输入第 7 位同学的成绩：67
请输入第 8 位同学的成绩：86
请输入第 9 位同学的成绩：78
请输入第 10 位同学的成绩：65
成绩录入完毕，该次考试的平均分是：73.30
</code></pre>
<h1 id="数组的初始化">数组的初始化</h1>
<p>在定义数组的时候同时对其<strong>各个元素</strong>进行赋值，称为数组的初始化。在刚刚的代码中，我们定义了数组，但却没有在定义的时候就初始化，而是在循环中进行赋值。那么初始化数组一般有下面几种方法：</p>
<ol>
<li>
<p>将数组中所有的元素初始化为0，可以这么写：</p>
<pre><code class="language-c">int a[10] = {0};
</code></pre>
</li>
<li>
<p>如果要赋予不同的值，用逗号分开即可：</p>
<pre><code class="language-c">int a[5] = {1, 2, 3, 4, 5};
</code></pre>
</li>
<li>
<p>给部分元素赋值，剩下的自动初始化为0：</p>
<pre><code class="language-c">int a[10] = {1, 2 ,3};//剩下的全部为0
</code></pre>
</li>
<li>
<p>也可以偷懒只给出每个元素的值，让编译器自己判断数组长度：</p>
<pre><code class="language-c">int a[] = {1, 2, 3, 4, 5};
</code></pre>
</li>
<li>
<p>C99中增加了一种特性，指定元素进行赋值，剩下的自动初始化为0。也就是说，可以针对不连续的几个元素赋值：</p>
<pre><code class="language-c">int a[10] = { [3] = 3, [5] = 5, [8] = 8 };//编译的时候记得加上-std=c99选项
</code></pre>
</li>
</ol>
<p>其实，在C语言界，还有一个所谓“口耳相传”的书写习惯，就是：</p>
<pre><code class="language-c">int a[] = {1, 2, 3, 4, 5,};
</code></pre>
<p>在最后一个元素后面加一个逗号。其实这对最终的编译没有任何影响，只不过一些老教材或者说计算机界的先辈们认为，这可以方便后人维护的时候添加元素。加不加逗号都无所谓，只不过习惯于加逗号的，都是在七八十年代就接触过C语言的人，某种意义上来说，这种习惯可以成为一个标签，拿出去 <s>装装逼</s> 也是可以的。</p>
<p>那可能你会说了，”你刚刚提到的一个问题还没解决呢！要是班里的人数变了怎么办呢？“</p>
<p>没错，我们现在就来解决下这个问题。</p>
<h1 id="可变长数组">可变长数组</h1>
<p>在C99标准推出之前，要求定义数组的时候，数组的维度必须是<strong>常量表达式</strong>或者<strong>const常量</strong>，但是C99标准中，支持了变量定义数组，那么，我们就可以将第一次的代码改成这样：</p>
<pre><code class="language-c">//Example 02
#include &lt;stdio.h&gt;
int main(void)
{
    int Member;
    printf(&quot;请输入班级人数：&quot;);
    scanf(&quot;%d&quot;, &amp;Member);
    int s[Member];//使用用户输入的值来确定数组的大小
    int i;
    float sum = 0;
    for (i = 0; i &lt; Member; i++)
    {
        printf(&quot;请输入第 %d 位同学的成绩：&quot;, i + 1);
            scanf(&quot;%d&quot;, &amp;s[i]);
        sum += s[i];
    }
    printf(&quot;成绩录入完毕，该次考试的平均分是：%.2f\n&quot;, sum/Menber);
    return 0;
}
</code></pre>
<p>这样，在开始存储成绩之前，先让使用者告诉程序班里有多少学生，该开辟多大的数组，然后就完美解决了人数变动的问题。</p>
<p>注意，这里的”可变长数组“是指的数组在程序运行的时候才<strong>确定长度</strong>，也就是说每一次运行都不一定一样。但是数组一旦被创建，在其生命周期内就不会再改变了，这是数组的<strong>根本特性</strong>。</p>
<p>但是，如果有的同学使用的是Visual Studio的话，是不支持C99的这个特性的(我也不知道为什么巨硬不支持，明明这么好的特性)，那么就只能使用<strong>动态分配</strong>的方法来创建数组。放在这里来讲的话有些超纲，后面会讲到。</p>
<h1 id="字符型数组">字符型数组</h1>
<p>还记得之前说过，C语言是没有字符串这种类型的。那么C语言处理字符串有两种方法：<strong>字符串常量</strong>和<strong>字符型数组</strong>。字符串常量是指用<strong>双引号</strong>括起来的字符串，一旦确定下来就<strong>无法改变</strong>。一般我们会更多地倾向于使用更加灵活的<strong>字符型数组</strong>。这样，数组中的每一个元素表示一个字符，当然还要多一位来表示<code>\0</code>。</p>
<p>那么接下来就讲讲字符串的一些方法，因为字符串实在是太重要了。</p>
<h2 id="获取字符串的长度">获取字符串的长度</h2>
<p>计算字符串的长度使用<code>strlen</code>函数（这是长度，不是尺寸）,这个函数包含在<code>string.h</code>中</p>
<pre><code class="language-c">#include &lt;string.h&gt;
...
size_t strlen ( const char * str );
</code></pre>
<p>这个方法是不包含字符串末尾的<code>\0</code>的。且看下面的例子：</p>
<pre><code class="language-c">//Example 03
#include &lt;stdio.h&gt;
#include &lt;string.h&gt;
int main(void)
{
    char str[] = &quot;I love Clang!&quot;;
    printf(&quot;sizeof str = %d\n&quot;, sizeof(str));
    printf(&quot;strlen str = %u\n&quot;, strlen(str));
    return 0;
}
</code></pre>
<p>运行结果如下：</p>
<pre><code>//Consequence 03
sizeof str = 14
strlen str = 13
</code></pre>
<p>除了验证不包含<code>\0</code>以外，我们还可以看到，<code>strlen</code>函数返回的是<code>size_t</code>而不是<code>int</code>。<code>size_t</code>被定义在<code>stddef.h</code>中，实际上就是<strong>无符号整型</strong>。</p>
<h2 id="复制字符串">复制字符串</h2>
<p>估计在第一次见到这个词的时候，你的大脑浮现出来的就是使用赋值符号<code>=</code>，但是，这是<strong>错的</strong>……</p>
<p>字符串的复制应该使用<code>strcpy</code>和<code>strncpy</code>来实现。</p>
<pre><code class="language-c">#include &lt;string.h&gt;
...
char *strcpy (char *dest, const char *src);
char *strncpy (char *dest, const char *src, size_t n);
</code></pre>
<p>不多废话，且看下面的例子：</p>
<pre><code class="language-c">//Example 04
#include &lt;stdio.h&gt;
#include &lt;string.h&gt;
int main(void)
{
	char str1[] = &quot;Original String&quot;;
	char str2[] = &quot;New String&quot;;
	char str3[100];
	strcpy(str1, str2);
	strcpy(str3, &quot;Successfully Copied&quot;);
	printf(&quot;\
str1: %s\n\
str2: %s\n\
str3: %s\n&quot;, \
		str1, str2, str3);
	return 0;
}
</code></pre>
<p>运行结果如下：</p>
<pre><code>//Consequence 04
str1: New String
str2: New String
str3: Successfully Copied
</code></pre>
<p>但是其实这个程序是<strong>有缺陷</strong>的。</p>
<p>我们可以看到，两个数组的长度其实<strong>不一样</strong>，我们现在是把短的复制到长的里面，那么不会有问题。如果上面的<code>str1</code>和<code>str2</code>对调一下，那么就极有可能出问题，这就是我们等会儿要讲的<strong>数组越界</strong>问题。</p>
<p>那么如何解决复制时的这个隐式bug呢？</p>
<p><strong>使用strncpy方法来复制</strong></p>
<p>如果超出的字符不是很多，那么程序有可能能够成功地运行。但是如果两者悬殊的话，那编译运行之后，程序会报<code>Segmentation fault</code>。</p>
<p>因此在复制的时候，我们应该确保不越界，在复制之后不溢出。那么使用<code>strncpy</code>函数，由于增加了一个参数来指定<strong>复制的字符个数</strong>，我们在编写代码的时候就可以规避这样的问题。</p>
<p>举个例子：</p>
<pre><code class="language-c">//Example 05
#include &lt;stdio.h&gt;
#include &lt;string.h&gt;
int main(void)
{
    char str1[] = &quot;TechZone was made by HarrisWilde&quot;;
    char str2[40];
    strncpy(str2, str1, 8);
    str2[8] = '\0';
    printf(&quot;%s\n&quot;, str2);
    return 0;
}
</code></pre>
<p>结果如下：</p>
<pre><code>//Consequence 05
TechZone
</code></pre>
<p>有一个地方要格外小心，<code>strncpy</code>函数<strong>并不会</strong>在字符串的末尾添加<code>\0</code>，因此在使用的时候要注意加上。</p>
<h2 id="连接字符串">连接字符串</h2>
<p>如果你想把一个字符串拼接到另一个后面的话，就可以使用<code>strcat</code>和<code>strncat</code>两个函数来实现。</p>
<pre><code class="language-c">#include &lt;string.h&gt;
...
char *strcat (char *dest, const char *src);
char *strncat (char *dest, const char *src, size_t n);
</code></pre>
<p>可以看到，这个函数的用法和上面复制字符串的用法完全相同，<code>strncat</code>也就是比<code>strcat</code>多了一个指定复制长度的参数罢了。</p>
<p>需要注意的是，这个函数<strong>会</strong>自动在末尾追加一个<code>\0</code>，这和复制不一样，要特别注意区分。</p>
<h2 id="比较字符串">比较字符串</h2>
<p>比较两个字符串，也和上面的一样，有两个类似的函数，<code>strcmp</code>和<code>strncmp</code>。</p>
<pre><code class="language-c">#include &lt;string.h&gt;
...
char *strcmp (char *dest, const char *src);
char *strncmp (char *dest, const char *src, size_t n);
</code></pre>
<p>采用这套函数来比较两个字符串是否相同的时候，如果两个字符串完全一致，那么返回的值为<code>0</code>。这个函数的原理是，从第一个字符开始，依次对比两个字符串中每个字符的ASCII，如果第一个字符串的ASCII小于第二个字符串对应的字符，那么返回一个小于<code>0</code>的数值（通常是<code>-1</code>），如果大于，那就会返回一个大于<code>0</code>的值（通常是<code>1</code>）。</p>
<p><code>strncmp</code>则是增加了一个参数，可以用来仅比较前面n个元素。</p>
<pre><code class="language-c">//Example 06
#include &lt;stdio.h&gt;
#include &lt;string.h&gt;
int main(void)
{
    char str1[10] = &quot;TechZone&quot;;
    char str2[20] = &quot;TechZone&quot;;
    if (!strcmp(str1, str2))
    {
        printf(&quot;Same!\n&quot;);
    }
    else
    {
        printf(&quot;Different!\n&quot;);
    }
    return 0;
}
</code></pre>
<p>运行结果为：</p>
<pre><code>//Consequence 06
Same!
</code></pre>
<h1 id="多维数组">多维数组</h1>
<p>有时候，使用数组来存储还是不够方便，比如，老师让你做一个全班全部科目的成绩的分析。如果利用我们刚刚所学习的数组知识，你可能会这么写：</p>
<pre><code class="language-c">//Example 07
#include &lt;stdio.h&gt;
int main(void)
{
    int chinese[50];
    int math[50];
    int English[50];
    int science[50];
    ...
}
</code></pre>
<p>但是如果我们使用二维数组的话，那么只需要定义一次就行了。</p>
<p>假设我们有6科。</p>
<p>那么就这样：</p>
<pre><code class="language-c">//Example 07 V2
#include &lt;stdio.h&gt;
int main(void)
{
    int score[6][50];
    ...
}
</code></pre>
<p>这其实就像一个表格一样，二维数组通常也被称为<strong>矩阵</strong>（matrix），将二维数组写成行和列的表示形式，可以形象地帮我们解决一些问题。</p>
<p>访问二维数组也和普通的数组一样，也是从<code>0</code>开始计数的，只不过下标随着维度的变化会增加罢了（比如二维数组就有2个下标）。</p>
<h2 id="二维数组的初始化">二维数组的初始化</h2>
<ol>
<li>
<p>二维数组在内存中是<strong>线性存放</strong>的，因此可以将所有的数据写在一个大括号内：</p>
<pre><code class="language-c">int a[2][3] = {1, 2, 3, 4, 5, 6};
</code></pre>
<p>这样就是先将第一行的三个元素初始化，然后再初始化第二行的元素。</p>
</li>
<li>
<p>为了更直观地表达我们可以这么写：</p>
<pre><code class="language-c">int a[2][3] = {
    {1, 2, 3},
    {4, 5, 6}
};
</code></pre>
</li>
<li>
<p>二维数组也可以仅对<strong>部分元素</strong>赋值：</p>
<pre><code class="language-c">int a[2][3] = {{1}, {4}};
</code></pre>
<p>这样写只是对各行的第一列元素赋值，其余的全部为0.</p>
</li>
<li>
<p>如果希望全部为0，那么可以这么写：</p>
<pre><code class="language-c">int a[2][3] = {0};
</code></pre>
</li>
<li>
<p>C99中增加的指定赋值的特性，这里也可以适用。其余未被操作的元素为<code>0</code>。</p>
<pre><code class="language-c">int a[2][3] = {[0][0] = 1, [1][2] = 6};
</code></pre>
</li>
<li>
<p>二维数组也可以偷懒，但是<strong>只有第一维度</strong>的元素个数可以不写，其他的都要写上：</p>
<pre><code class="language-c">int a[][3] = {
    {1, 2, 3},
    {4, 5, 6}
};
</code></pre>
</li>
</ol>
<h1 id="数组越界">数组越界</h1>
<p>我们刚刚说过了，我们在写程序的时候，尽量要把越界的情况通过代码的努力来规避。那么，可能有的小伙伴比较感兴趣，如果越界了，会发生什么呢？</p>
<p>那好，咱们就来试试。</p>
<pre><code class="language-c">//Example 08
#include &lt;stdio.h&gt;

void f();

int main(void)
{
    f();
    return 0;
}

void f()
{
    int a[10];
    a[10] = 0;//这里我们写到了一个不存在的下标里面
}
</code></pre>
<p>我们来跑一下这个程序。</p>
<p>笔者使用的Visual Studio 2019给出了以下的错误提示：</p>
<pre><code>//Consequence 08
Run-Time Check Failure #2 - Stack around the variable 'a' was corrupted.
</code></pre>
<p>它发现了我在写入一个<strong>错误的地址</strong>。并且还给了我两个<strong>warning</strong>：</p>
<pre><code>警告	C6201	索引“10”超出了“0”至“9”的有效范围(对于可能在堆栈中分配的缓冲区“a”)。
警告	C6386	写入到“a”时缓冲区溢出: 可写大小为“40”个字节，但可能写入了“44”个字节。	
</code></pre>
<p>如果我们像普通程序员一样，不管代码warning，直接强制执行，试试会发生什么。</p>
<p>为了更直观体现，我们把代码改成这样：</p>
<pre><code class="language-c">//Example 08
#include &lt;stdio.h&gt;

void f();

int main(void)
{
    f();
    printf(&quot;Here\n&quot;);//我们加了这句，如果函数正常执行完毕了，就可以看到这个语句的输出
    return 0;
}

void f()
{
    int a[10];
    a[10] = 0;
}
</code></pre>
<p>还是出现了这句：</p>
<pre><code>Run-Time Check Failure #2 - Stack around the variable 'a' was corrupted.
</code></pre>
<p>控制台上面没有看到<code>Here</code>的输出，说明函数还没有执行完，程序就已经<strong>崩溃</strong>了，根本没办法执行到输出。</p>
<p>但是，为什么编译器没有给我<strong>error</strong>，而是给了我<strong>warning</strong>呢？</p>
<p>有的编译器可能连warning都没有。</p>
<p>实际上，我们在对<code>a[10]</code>写入的时候，其实是<strong>成功</strong>了的。只不过我们把<code>a[10]</code>写在了一个<strong>不该写的地方</strong>（实际上就是这段数组内存的后面），干扰到了其他东西的运行，程序就有可能会崩溃。如果后面的内存为空或者是没有被回收的垃圾内存，那么就没关系，但是如果是有用的内存，出问题就很正常了。</p>
<p>有时候我们写了一个程序，可能这次运行没问题，下一次运行就出错，或者是在我的电脑上可以，在你的电脑上就不行了等等，都有可能是数组越界，或者是我们后面要学的指针出错了。我们作为创造代码的人，有责任通过代码上的设计，来规避这样的问题，避免程序的崩溃。</p>
<h1 id="长度为0的数组">长度为0的数组？</h1>
<p>有的同学可能会异想天开，说，我可不可以定义一个长度为0的数组呢？</p>
<p>类似于这样：</p>
<pre><code class="language-c">int a[0];
</code></pre>
<p>答案是，完全没问题！</p>
<p>不信的话可以去试试，编译可以通过的，只不过这样的数组不存在任何意义，因为没有符合要求的下标。我们说，最大的下标就是元素个数-1，那么<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>0</mn><mo>−</mo><mn>1</mn><mo>=</mo><mo>−</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">0-1=-1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.72777em;vertical-align:-0.08333em;"></span><span class="mord">0</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.72777em;vertical-align:-0.08333em;"></span><span class="mord">−</span><span class="mord">1</span></span></span></span>，-1显然不是一个合法的下标。所以这样的操作可行，但是没有任何意义。</p>
<p>好了，本节内容就到这里了，希望你能够从中有所收获哦！</p>

              </div>
              <div class="post-footer">
  <ul class="post-copyright">
    <li class="post-copyright-author">
      <strong>本文作者：</strong>
      TechZone
    </li>
    <li class="post-copyright-link">
      <strong>本文链接：</strong>
      <a href="https://harriswilde.github.io/post/CArray/" title="C语言之数组">C语言之数组</a>
    </li>
    <li class="post-copyright-license">
      <strong>版权声明： </strong>
      本博客所有文章除特别声明外，转载请注明出处！
    </li>
  </ul>
  <div class="tags">
    
      <a href="https://harriswilde.github.io/tag/VC6KZQgdc/"># C</a>
    
      <a href="https://harriswilde.github.io/tag/DFrZZfISm/"># 数据结构</a>
    
  </div>
  <div class="nav">
    <div class="nav-prev">
      
        <i class="fa fa-chevron-left"></i>
        <a class="nav-pc-next" title="Python学习开场白" href="https://harriswilde.github.io/post/PythonBeginner/">Python学习开场白</a class="nav-pc-next">
        <a class="nav-mobile-prev" title="Python学习开场白" href="https://harriswilde.github.io/post/PythonBeginner/">上一篇</a>
      
    </div>
    <div class="nav-next">
      
        <a class="nav-pc-next" title="杂谈·一个神一般的随机算法" href="https://harriswilde.github.io/post/GreatRandom/">杂谈·一个神一般的随机算法</a>
        <a class="nav-mobile-next" title="杂谈·一个神一般的随机算法" href="https://harriswilde.github.io/post/GreatRandom/">下一篇</a>
        <i class="fa fa-chevron-right"></i>
      
    </div>
  </div>
</div>
              
                
<script src="https://cdn.jsdelivr.net/npm/valine@1.3.10/dist/Valine.min.js"></script>
<div id="vcomments" style="padding: 10px 0px 0px 0px"></div>
<script>
new Valine({
    el: '#vcomments' ,
    appId: 'aSVp0OY6zw3Kbg9XOVQduoms-9Nh9j0Va',
    appKey: 'gtOCC5WcbcusTKnIBuqh6zaa',
    notify: 'true' === 'true', 
    avatar:'', 
    placeholder: '有错误或更好的建议？告诉我一起学习吧！',
    pageSize: '',
    lang: 'zh-cn',
    visitor: 'true' === 'true',
    highlight: 'true' === 'true',
    avatarForce: 'true' === 'false',
});
</script>
              
            </div>
          </div>
        </div>
      </div>
      <div class="footer-box">
  <footer class="footer">
    <div class="copyright">
      © 2019-2020 TechZone
    </div>
    <div class="poweredby">
      Powered by HarrisWilde
    </div>
  </footer>
  
  
  <div class="pisces back-to-top" id="back_to_top">
    <i class="fa fa-arrow-up"></i>
    
    <span class="scrollpercent">
      <span id="back_to_top_text">0</span>%
    </span>
    
  </div>
  
  
  
</div>
<script>

  let sideBarOpen = 'sidebar-open';
  let body = document.body;
  let back2Top = document.querySelector('#back_to_top'),
  back2TopText = document.querySelector('#back_to_top_text'),
  drawerBox = document.querySelector('#drawer_box'),
  rightSideBar = document.querySelector('.sidebar'),
  viewport = document.querySelector('body');

  function scrollAnimation(currentY, targetY) {
   
    let needScrollTop = targetY - currentY
    let _currentY = currentY
    setTimeout(() => {
      const dist = Math.ceil(needScrollTop / 10)
      _currentY += dist
      window.scrollTo(_currentY, currentY)
      if (needScrollTop > 10 || needScrollTop < -10) {
        scrollAnimation(_currentY, targetY)
      } else {
        window.scrollTo(_currentY, targetY)
      }
    }, 1)
  }

  back2Top.addEventListener("click", function(e) {
    scrollAnimation(document.scrollingElement.scrollTop, 0);
    e.stopPropagation();
    return false;
  });
  
  window.addEventListener('scroll', function(e) {
    let percent = document.scrollingElement.scrollTop / (document.scrollingElement.scrollHeight - document.scrollingElement.clientHeight) * 100;
    if (percent > 1 && !back2Top.classList.contains('back-top-active')) {
      back2Top.classList.add('back-top-active');
    }
    if (percent == 0) {
      back2Top.classList.remove('back-top-active');
    }
    if (back2TopText) {
      back2TopText.textContent = Math.floor(percent);
    }
  });

  
  let hasCacu = false;
  window.onresize = function() {
    if (window.width > 991) {
      calcuHeight();
    } else {
      hasCacu = false;
    }
  }

  function calcuHeight() {
    // 动态调整站点概览高度
    if (!hasCacu && back2Top.classList.contains('pisces') || back2Top.classList.contains('gemini')) {
      let sideBar = document.querySelector('.sidebar');
      let navUl = document.querySelector('#site_nav');
      sideBar.style = 'margin-top:' + (navUl.offsetHeight + navUl.offsetTop + 15) + 'px;';
      hasCacu = true;
    }
  }
  calcuHeight();
  
  let open = false, MOTION_TIME = 300, RIGHT_MOVE_DIS = '320px';

  if (drawerBox) {
    let rightMotions = document.querySelectorAll('.right-motion');
    let right = drawerBox.classList.contains('right');

    let transitionDir = right ? "transition.slideRightIn" : "transition.slideLeftIn";

    let openProp, closeProp;
    if (right) {
      openProp = {
        paddingRight: RIGHT_MOVE_DIS 
      };
      closeProp = {
        paddingRight: '0px'
      };
    } else {
      openProp = {
        paddingLeft: RIGHT_MOVE_DIS 
      };
      closeProp = {
        paddingLeft: '0px'
      };
    }

    drawerBox.onclick = function() {
      open = !open;
      window.Velocity(rightSideBar, 'stop');
      window.Velocity(viewport, 'stop');
      window.Velocity(rightMotions, 'stop');
      if (open) {
        window.Velocity(rightSideBar, {
          width: RIGHT_MOVE_DIS
        }, {
          duration: MOTION_TIME,
          begin: function() {
            window.Velocity(rightMotions, transitionDir,{ });
          }
        })
        window.Velocity(viewport, openProp,{
          duration: MOTION_TIME
        });
      } else {
        window.Velocity(rightSideBar, {
          width: '0px'
        }, {
          duration: MOTION_TIME,
          begin: function() {
            window.Velocity(rightMotions, {
              opacity: 0
            });
          }
        })
        window.Velocity(viewport, closeProp ,{
          duration: MOTION_TIME
        });
      }
      for (let i = 0; i < drawerBox.children.length; i++) {
        drawerBox.children[i].classList.toggle('muse-line');
      }
      drawerBox.classList.toggle(sideBarOpen);
    }
  }

  // 代码高亮
  hljs.initHighlightingOnLoad();

</script>
    </div>
  </body>
  <script src="/media/js/motion.js"></script>
</html>
