<html lang="en">

<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<meta http-equiv="X-UA-Compatible" content="ie=edge">
<title>C语言之函数（中） - TechZone</title>
<link rel="shortcut icon" href="https://harriswilde.github.io/favicon.ico">
<link href="https://cdn.jsdelivr.net/npm/remixicon@2.2.0/fonts/remixicon.css" rel="stylesheet">
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/animate.css@3.7.2/animate.min.css">
<link rel="stylesheet" href="https://harriswilde.github.io/media/css/tailwind.css">
<link rel="stylesheet" href="https://harriswilde.github.io/styles/main.css">
<link rel="alternate" type="application/atom+xml" title="C语言之函数（中） - TechZone - Atom Feed" href="https://harriswilde.github.io/atom.xml">

    

  <meta name="description" content="局部变量和全局变量
局部变量
在我们学习函数之前，我们所理解的变量，只不过是在内存中开辟一个存储数据的位置，并取了个我们好懂的名字而已。因为我们之前写的程序只有一个主函数，因此我们觉得，定义了一个变量，就应该可以随时调用。但是学习了函数之后..." />
  <meta property="og:title" content="C语言之函数（中） - TechZone">
  <meta property="og:description" content="局部变量和全局变量
局部变量
在我们学习函数之前，我们所理解的变量，只不过是在内存中开辟一个存储数据的位置，并取了个我们好懂的名字而已。因为我们之前写的程序只有一个主函数，因此我们觉得，定义了一个变量，就应该可以随时调用。但是学习了函数之后..." />
  <meta property="og:type" content="articles">
  <meta property="og:url" content="https://harriswilde.github.io/post/IKKYqSXMf/" />
  <meta property="og:image" content="https://harriswilde.github.io/images/avatar.png">
  <meta property="og:image:height" content="630">
  <meta property="og:image:width" content="1200">
  <meta name="twitter:title" content="C语言之函数（中） - TechZone">
  <meta name="twitter:description" content="局部变量和全局变量
局部变量
在我们学习函数之前，我们所理解的变量，只不过是在内存中开辟一个存储数据的位置，并取了个我们好懂的名字而已。因为我们之前写的程序只有一个主函数，因此我们觉得，定义了一个变量，就应该可以随时调用。但是学习了函数之后...">
  <meta name="twitter:card" content="summary_large_image">
  <link rel="canonical" href="https://harriswilde.github.io/post/IKKYqSXMf/">

  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe.css">
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/default-skin/default-skin.css">
 
  
    <link rel="stylesheet" href="https://harriswilde.github.io/media/css/prism-tmn.css">
  

  
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.10.0/katex.min.css">
  
</head>

<body>
  <div class="antialiased flex flex-col min-h-screen" id="app">
    <a href="https://harriswilde.github.io" class="fixed top-0 left-0 mt-4 bg-black text-white dark:text-gray-700 dark:bg-yellow-50 dark:hover:bg-black dark:hover:text-white inline-flex p-2 pl-8 hover:text-gray-700 hover:bg-yellow-50 font-bold z-10 transition-fast animated fadeInLeft">
      TechZone
    </a>
    <div class="max-w-4xl w-full mx-auto">
      <div class="shadow-box bg-white dark:bg-gray-600 rounded-lg pt-32 md:pt-64 px-4 md:px-8 pb-8 animated fadeIn mb-8">
        <h1 class="text-5xl font-semibold leading-normal pb-8 mb-8 border-b-8 border-gray-700">
          C语言之函数（中）
        </h1>
        
        <div class="mb-8 flex flex-wrap">
          <div class="text-gray-400 text-sm mr-4">2020-02-06 · 19 min read</div>
          
            <a href="https://harriswilde.github.io/tag/VC6KZQgdc/" class="text-gray-700 text-sm border-b-2 border-dotted border-gray-200 hover:border-gray-600 transition-all duration-100 inline-flex mr-2">
              <i class="ri-hashtag"></i>
              C
            </a>
          
        </div>
        <div class="markdown mb-8" v-pre>
          <h1 id="局部变量和全局变量">局部变量和全局变量</h1>
<h2 id="局部变量">局部变量</h2>
<p>在我们学习函数之前，我们所理解的变量，只不过是在内存中开辟一个存储数据的位置，并取了个我们好懂的名字而已。因为我们之前写的程序只有一个主函数，因此我们觉得，定义了一个变量，就应该可以随时调用。但是学习了函数之后，我们发现，不同函数之间的变量是不能够相互调用的，这又是为什么呢？</p>
<p>比如：</p>
<pre><code class="language-c">//Example 01
#include &lt;stdio.h&gt;
int main(void)
{
    int i = 100;
    printf(&quot;Before i = %d\n&quot;, i);
    for (int i = 0; i &lt;= 10; i++)//再定义一个局部变量i
    {
        printf(&quot;i = %d\n&quot;, i);
    }
    printf(&quot;After i = %d\n&quot;, i);
    return 0;
}
</code></pre>
<p>结果如下：</p>
<pre><code>//Consequence 01
Before i = 100
i = 0
i = 1
i = 2
i = 3
i = 4
i = 5
i = 6
i = 7
i = 8
i = 9
i = 10
After i = 100
</code></pre>
<p>我们可以看到，我们在<code>for</code>函数里和<code>main</code>函数里都有一个<code>i</code>变量，但是我们在<code>for</code>函数里面定义的<code>i</code>却对外层函数不构成影响。</p>
<p>一般来说，变量名应该是不能够重复的。但是，由于我们定义的位置不一样（在不同的函数中），所以变量名重复又变得合法起来。这就是局部变量的特性：<strong>只能在自己的领域里面发挥作用</strong>。</p>
<p>像我们刚刚定义的<code>for</code>一样，C语言允许随处定义变量。也就是说，变量在需要用到的时候再定义。这样也符合我们的思维方式。因为当程序很庞大的时候，没有人愿意翻到顶上去看一个变量的注释。</p>
<h2 id="全局变量">全局变量</h2>
<p>既然有局部变量，那么全局变量也照样不可少。看下面的例子：</p>
<pre><code class="language-c">//Example 02
#include &lt;stdio.h&gt;
void f1(void);
void f2(void);
void f3(void);
int a = 0;//定义一个全局变量

void f1(void)
{
    a++;
}

void f2(void)
{
    a++;
}

void f3(void)
{
    a++;
}

int main(void)
{
    f1();
    f2();
    f3();
    printf(&quot;a = %d\n&quot;, ++a);
    return 0;
}
</code></pre>
<p>运行结果如下：</p>
<pre><code>//Consequence 02
a = 4
</code></pre>
<p>我们发现，全局变量在每一个函数里面的更改都“有效”，也就是说，全局变量是贯穿整个程序始终的。</p>
<p>有的小伙伴可能会好奇，如果全局变量和局部变量重名了，会发生什么呢？</p>
<p>那我们就来试试：</p>
<pre><code class="language-c">//Example 03
#include &lt;stdio.h&gt;
void f(void);
int a, b = 100;
void f(void)
{
    int b;
    a = 50; b = 101;
    printf(&quot;func, a = %d, b = %d\n&quot;, a, b);
}

int main(void)
{
    printf(&quot;Main, a = %d, b = %d\n&quot;, a, b);
    f();
    printf(&quot;Main, a = %d, b = %d\n&quot;, a, b);
}
</code></pre>
<p>运行结果如下：</p>
<pre><code>//Consequence 03
Main, a = 0, b = 100
func, a = 50, b = 101
Main, a = 50, b = 100
</code></pre>
<p>我们发现，名字叫<code>a</code>的变量只有全局变量，那么被赋值之后就等于在函数<code>f()</code>中赋的值。但是<code>b</code>就不一样了。在函数<code>f()</code>中，也有一个变量叫做<code>b</code>，那么此时编译器的做法是，在函数<code>f()</code>里先暂时屏蔽全局变量<code>b</code>，使用自己的局部变量。等走出了函数<code>f()</code>，局部变量被释放。</p>
<p>而我们还发现一个问题，我们可以直接输出没有被初始化的<code>a</code>！这也是全局变量的一个特点，不同于局部变量，全局变量在没有手动初始化的时候，会被系统自动初始化为<code>0</code>而不是像局部变量那样的很小的一个很奇怪的数。</p>
<p>另外，如果没有需要，尽量不要大量使用全局变量。因为全局变量的内存将会伴随着这个程序，直到程序执行完毕。如果大量使用全局变量的话，可能会造成内存占用过多等问题。这在嵌入式开发这种领域，内存空间寸土寸金，不当使用全局变量会导致资源的浪费。其次，全局变量会造成程序可读性变差。最后，全局变量会使得程序牵连性变强，牵一发而动全身的情况可能会再次出现。</p>
<p>因此全局变量虽然是个好东西，但也要谨慎使用。</p>
<h1 id="作用域和链接属性">作用域和链接属性</h1>
<p>在上一节，我们简单地了解了不同的变量，它能够有不同的作用范围，那么这个范围，就是我们所说的<strong>作用域</strong>。C语言的编译器一共能够确认4种不同的作用域：<code>代码块作用域</code> <code>文件作用域</code> <code>原型作用域</code> <code>函数作用域</code></p>
<h2 id="代码块作用域">代码块作用域</h2>
<pre><code class="language-c">//Example 04
#include &lt;stdio.h&gt;
int main(void)
{
    int i = 1;
    {
        int i = 2;
        printf(&quot;i = %d\n&quot;, i);
    }
    {
        printf(&quot;i = %d\n&quot;, i);
        int i = 3;
        printf(&quot;i = %d\n&quot;, i);
    }
    printf(&quot;i = %d\n&quot;, i);
    return 0;
}
</code></pre>
<p>运行结果如下：</p>
<pre><code>//Consequence 04
i = 2
i = 1
i = 3
i = 1
</code></pre>
<p>我们通常管一个大括号里面的语句叫做代码块，那么看这个程序，一个代码块里面的变量只能作用于所在的代码块里，超出了的就无效了。若存在代码块嵌套，那么优先内层代码块的变量。这就是<strong>代码块作用域</strong>。</p>
<p>当然，有一点需要说说，就是函数的形参也是代码块作用域，只能作用于函数定义代码块里面，即便它没有写在代码块里面。</p>
<h2 id="文件作用域">文件作用域</h2>
<p>在任何代码块之外定义的变量，都具有<strong>文件作用域</strong>。它们的作用域是从变量声明开始，一直到文件尾结束。另外，函数名也是文件作用域，因为函数名本身也在代码块之外。</p>
<h2 id="原型作用域">原型作用域</h2>
<p>原型作用域只适合那些在函数原型中声明的参数名。我们知道，在声明一个函数的时候，形参的名字是可以不用写的，只需要把类型写好就行了。但是，其实不妨可以试试写上名字，即便这个名字和正式定义的时候形参的名字不一样，也是没问题的（当然这样做毫无意义），这其实就是原型作用域在起作用。</p>
<h2 id="函数作用域">函数作用域</h2>
<p>函数作用域只适用于<code>goto</code>语句的标签，作用是将<code>goto</code>语句的标签限定在一个函数的内部，避免出现重名的标签。</p>
<h2 id="链接属性">链接属性</h2>
<p>简单来说，编译器将源代码转换成机器码的时候需要有两个步骤：<strong>编译</strong>和<strong>链接</strong>。</p>
<p>所谓编译，就是将我们写的源代码转换为机器码，而链接，就是将相关的库文件添加进来。比如我们在写程序的时候加入的头文件，在最终生成的时候就是要链接进来的。</p>
<p>我们知道，大型程序是由很多源文件构成的，那么在不同的文件中的同名标识符，编译器是入场处理的呢？</p>
<p>在C语言中，链接属性一共有以下3种：</p>
<ul>
<li>external(外部的)：多个文件中声明的同名标识符表示同一个实体</li>
<li>internal(内部的)：单个文件中声明的同名标识符表示同一个实体</li>
<li>none(无)：声明的同名标识符被当作独立不同的实体。比如，函数的局部变量。</li>
</ul>
<p>默认情况下，具备文件作用域的标识符拥有<code>external</code>属性，也就是说，这种标识符允许跨文件访问。使用<code>static</code>可以使原先拥有<code>external</code>属性的标识符变为<code>internal</code>属性。但是<code>static</code>只能修改具有文件作用域的标识符，并且是不可逆修改。</p>
<h1 id="生存期和存储类型">生存期和存储类型</h1>
<h2 id="生存期">生存期</h2>
<p>上一节我们用空间的角度去解释了不同的变量，但其实，还可以从时间的角度来分析。</p>
<p>C语言的变量通常有两种生存期，静态存储期(static storage duration)和自动存储期(automatic storage duration)。</p>
<p>具有文件作用域的变量具有静态存储期（如全局变量），函数名也有静态存储期。静态存储期的变量在程序执行的期间内将一直占据存储空间。</p>
<p>具有代码块作用域的变量通常具有自动存储期（如局部变量和形参），具有自动存储期的变量将在代码块执行完毕的时候释放内存。</p>
<h2 id="存储类型">存储类型</h2>
<p>变量的存储类型实际上是指存储变量值的内存类型。C语言提供了5种存储类型：<code>auto</code> <code>register</code> <code>static</code> <code>extern</code> <code>typedef</code></p>
<h3 id="1-自动变量">1. 自动变量</h3>
<p>在代码块中声明的变量默认就是自动变量(auto)。</p>
<pre><code class="language-c">//Example 05
#include &lt;stdio.h&gt;
int main(void)
{
    auto int a, b, c;
    return 0;
}
</code></pre>
<p>但是由于是默认存储类型，所以<code>auto</code>一般不写也完全没问题。函数中的形参、局部变量以及复合语句中定义的局部变量都具有自动变量。自动变量拥有代码块作用域、自动存储期和空链接属性。</p>
<h3 id="2-寄存器变量">2. 寄存器变量</h3>
<p>如果你学过汇编语言，或者对计算机的原理比较了解的话，一定没少听说<strong>寄存器</strong>这个词。寄存及就集成在CPU内部，因此它和CPU之间的交流几乎可以说没有延迟。</p>
<p>如果你申请了寄存器变量，那么就有可能被存储到寄存器里面去。当然，编译器也有自己的优化方案，它会在程序运行的时候权衡哪些变量更应该被放到寄存器的位置，因此，你的申请只是做一个参考而已。那么那些没有被放入寄存器的变量就会成为<strong>自动变量</strong>，所以，寄存器变量和自动变量在很多地方是一样的，也拥有代码块作用域、自动存储期和空链接属性。</p>
<p>但是，如果是寄存器变量的话，那么理论上就没法通过**取地址运算符&amp;**来获取地址了，因为我们知道这个是针对内存的。</p>
<pre><code class="language-c">//Example 06
#include &lt;stdio.h&gt;
int main(void)
{
    register int i = 100;
    printf(&quot;addr of i is %p\n&quot;, &amp;i);
    return 0;
}
</code></pre>
<p>但是VS可能对这种代码有优化，将变量转换成自动变量了：</p>
<pre><code>//Consequence 06 of Visual Studio 2019
addr of i is 00CFFE90
</code></pre>
<h3 id="3-静态局部变量">3. 静态局部变量</h3>
<p><code>static</code>用于描述具有文件作用域的变量或者函数时，表示将其链接属性从<code>external</code>修改成<code>internal</code>，它的作用范围就变成了仅当前文件可访问。如果<code>static</code>用于描述局部变量，那可就不太一样了。</p>
<p>默认情况下，局部变量是自动变量，具有自动存储期。如果使用了<code>static</code>来声明，那么就可以将局部变量指定为静态局部变量(static)。这使得局部变量具有静态存储期，所以它的生存期和全局变量一样。但是作用域依旧是局部变量，在别的函数中是无法访问这个局部变量的。</p>
<h3 id="4-extern">4.  extern</h3>
<p><code>extern</code>关键字告诉编译器这个变量或函数在别的地方已经定义过了，先在别的地方找找，不要急着报错。</p>
<p>通常情况下，这个关键词可以不写，但是为了程序更加完善，更加易读。在多人协作的时候，可以避免很多重名的问题。</p>
<h3 id="5-typedef">5.  typedef</h3>
<p><code>typedef</code>与其他四个存储类型的语义不同，<code>typedef</code>与内存存储无关，用于为数据类型定义一个新名字。</p>
<h1 id="递归">递归</h1>
<p>虽然递归隶属于算法的范畴，但是几乎所有的程序语言教程，都会讲到这个知识点。因为，递归是一个非常好的编程思路，有时候一个很难解决的问题，使用递归就可以巧妙地搞定。</p>
<h2 id="什么是递归">什么是递归</h2>
<p>递归说白了，就是函数在执行的时候，调用自身的行为。其实递归在生活中有很多实例，比如：</p>
<ol>
<li>
<p>汉诺塔游戏</p>
<figure data-type="image" tabindex="1"><img src="https://ss0.bdstatic.com/70cFuHSh_Q1YnxGkpoWK1HF6hhy/it/u=2591095191,1547695417&amp;fm=26&amp;gp=0.jpg" alt="汉诺塔游戏" loading="lazy"></figure>
<p>这个游戏要求将中间的柱子的圆盘全部移动到另外一个柱子上，要求每次只能移动一个圆盘，并且较大的圆盘始终在下方。</p>
</li>
<li>
<p>谢尔宾斯基三角形</p>
<figure data-type="image" tabindex="2"><img src="https://ss1.bdstatic.com/70cFvXSh_Q1YnxGkpoWK1HF6hhy/it/u=3361120212,184359007&amp;fm=26&amp;gp=0.jpg" alt="谢尔宾斯基三角形" loading="lazy"></figure>
<p>三角形里边填充三角形，只要空间够大，它可以撑满整个宇宙。</p>
</li>
</ol>
<p>甚至还诞生了一门数学分支：分形几何。专门研究这种递归现象。</p>
<p>说了这么多，那么递归在程序里面该如何实现呢？</p>
<pre><code class="language-c">//Example 07
#include &lt;stdio.h&gt;
void r(void);
void r(void)
{
    printf(&quot;Hi!&quot;);
    r();
}
int main(void)
{
    r();
    return 0;
}
</code></pre>
<p>运行结果如下：</p>
<pre><code>//Consequence 08
...
Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Segmentation fault
</code></pre>
<p>可以看到，满屏幕的Hi！这就是初学者经常会犯的错误，程序无休止地执行下去，直到消耗掉所有的内存。这就像我们讲过的“从前有座山，山里有座庙……”这个故事一样，没有中止的条件，讲多久都讲不完。</p>
<p>修改下代码：</p>
<pre><code class="language-c">//Example 07 V2
#include &lt;stdio.h&gt;
void r(void);
void r(void)
{
    static int count = 5;//设置计数变量
    printf(&quot;Hi!\n&quot;);
    if (--count)//设置跳出条件
    {
        r();
    }
}

int main(void)
{
    r();
    return 0;
}
</code></pre>
<p>运行结果如下：</p>
<pre><code>//Consequence 07 V2
Hi!
Hi!
Hi!
Hi!
Hi!
</code></pre>
<p>这样，递归这头小猛兽，就这样被我们控制住了。</p>
<h2 id="递归求斐波那契数列">递归求斐波那契数列</h2>
<p>斐波那契数列每一项等于前两项之和，正好符合递归的思路：</p>
<pre><code class="language-c">#include &lt;stdio.h&gt;
int fibo(int n)
{
    if (n &lt;= 2)
    {
        return 1;
    }
    else
    {
        return fibo(n - 1) + fibo(n - 2);
    }
}
int main()
{
    int n;
    printf(&quot;请输入斐波那契数列长度：&quot;);
    scanf(&quot;%d&quot;, &amp;n);
    for (int i = 1; i &lt;= n; ++i)
    {
        printf(&quot;%d&quot;, fibo(i));
        if (i &lt; n)
        {
            printf(&quot;, &quot;);
        }
    }
    return 0;
}
</code></pre>
<p>程序执行如下：</p>
<pre><code>请输入斐波那契数列长度：10
1, 1, 2, 3, 5, 8, 13, 21, 34, 55
</code></pre>
<h2 id="递归求汉诺塔">递归求汉诺塔</h2>
<p>其实，不论有多少层汉诺塔，都可以使用递归一层一层往下解包。</p>
<pre><code class="language-c">//Example 08
#include &lt;stdio.h&gt;
void hanoi(int, char, char, char);
void hanoi(int n, char x, char y, char z)
{
    if (n == 1)
    {
        printf(&quot;%c --&gt; %c\n&quot;, x, z);//剩下底部的圆盘
    }
    else
    {
        hanoi(n - 1, x, z, y);//将n-1个圆盘从x移动到y
        printf(&quot;x --&gt; z\n&quot;);
        hanoi(n - 1, y, x, z);//将n-1个圆盘从y移动到z
    }
}
int main(void)
{
    int n;
    printf(&quot;请输入汉诺塔的层数：&quot;);
    scanf(&quot;%d&quot;, &amp;n);
    hanoi(n, 'X', 'Y', 'Z');
    return 0;
}
</code></pre>
<p>运行结果如下：</p>
<pre><code>//Consequence 08
请输入汉诺塔的层数：4
X --&gt; Y
x --&gt; z
Y --&gt; Z
x --&gt; z
Z --&gt; X
x --&gt; z
X --&gt; Y
x --&gt; z
Y --&gt; Z
x --&gt; z
Z --&gt; X
x --&gt; z
X --&gt; Y
x --&gt; z
Y --&gt; Z
</code></pre>
<h2 id="分治法">分治法</h2>
<p>所谓分治法，就是大事化小的思维。递归实际上就是一种分治。层层递归，然后从最简单的问题开始解决。</p>
<p>说到这里，就不得不提到一种排序算法，就是十分经典的——快速排序。</p>
<p>作为20世纪十大算法之一，快速排序的基本思想是：通过一项将待排序数据分割成独立的两部分，其中一部分元素均比另一部分小，然后分别对这两部分继续排序，重复步骤直到完成。</p>
<figure data-type="image" tabindex="3"><img src="https://www.cxyxiaowu.com/wp-content/uploads/2019/10/1571057581-e7b9d65b41e66df.gif" alt="快速排序动画演示" loading="lazy"></figure>
<p>代码如下：</p>
<pre><code class="language-c">//Example 09
#include &lt;stdio.h&gt;
void qs(int, int, int);
void qs(int array[], int left, int right)
{
    int i = left, j = right;
    int temp;
    int pivot;
    
    //基准点设置为中间元素，当然别的也可以
    pivot = array[(left + right) / 2];
    
    while (i &lt;= j)
    {
        //找到左边大于等于基准点的元素
        while (array[i] &lt; pivot)
        {
            ++i;
        }
        //找到右边小于等于基准点的元素
        while (array[j] &gt; pivot)
        {
            --j;
        }
        //如果左边下标小于右边，则交换元素
        if (i &lt;= j)
        {
            temp = array[i];
            array[i] = array[j];
            array[j] = temp;
            ++i;
            --j;
        }
    }
    
    //递归遍历左子
    if (left &lt; j)
    {
        qs(array, left, j);
    }
    //递归遍历右子
    if (i &lt; right)
    {
        qs(array, i, right);
    }
}

int main(void)
{
    int array[] = {135, 156, 120, 102, 130, 62, 410, 158, 173, 113, 124, 184, 131, 214};
    int length;
    length = sizeof(array) / sizeof(array[0]);
    qs(array, 0, length - 1);
    
    printf(&quot;排序后结果为：&quot;);
    for (int i = 0; i &lt; length; i++)
    {
        printf(&quot;%d&quot;, array[i]);
        if (i &lt; length - 1)
        {
            printf(&quot;, &quot;);
        }
    }
    putchar('\n');
    return 0;
}
</code></pre>
<p>执行结果如下：</p>
<pre><code>//Consequence 09
排序后结果为：62, 102, 113, 120, 124, 130, 131, 135, 156, 158, 173, 184, 214, 410
</code></pre>
<p>学了这么多，也该好好休息下了！下期再见！</p>

        </div>
        <!-- Share to Twitter, Weibo, Telegram -->
        <div class="flex items-center">
          <div class="mr-4 flex items-center">
            <i class="ri-share-forward-line text-gray-500"></i>
          </div>
          <div class="px-4 cursor-pointer text-blue-500 hover:bg-blue-100 dark:hover:bg-gray-600 inline-flex" @click="shareToTwitter">
            <i class="ri-twitter-line"></i>
          </div>
          <div class="px-4 cursor-pointer text-red-500 hover:bg-red-100 dark:hover:bg-gray-600 inline-flex" @click="shareToWeibo">
            <i class="ri-weibo-line"></i>
          </div>
          <div class="px-4 cursor-pointer text-indigo-500 hover:bg-indigo-100 dark:hover:bg-gray-600 inline-flex" @click="shareToTelegram">
            <i class="ri-telegram-line"></i>
          </div>
        </div>
      </div>

      

      

      <footer class="py-12 text-center px-4 md:px-0" v-pre>
  Powered by HarrisWilde
</footer>
    </div>

    <!-- TOC Container -->
    <div class="fixed right-0 bottom-0 mb-16 mr-4 shadow w-8 h-8 rounded-full flex justify-center items-center z-10 cursor-pointer bg-white dark:bg-gray-500 dark:text-gray-200 hover:shadow-lg transition-all animated fadeInRight" @click="showToc = true">
      <i class="ri-file-list-line"></i>
    </div>

    <div class="fixed right-0 top-0 bottom-0 overflow-y-auto w-64 bg-white dark:bg-gray-800 p-4 border-l border-gray-100 dark:border-gray-600 z-10 transition-fast" :class="{ '-mr-64': !showToc }">
      <div class="flex mb-4 justify-end">
        <div class="w-8 h-8 inline-flex justify-center items-center rounded-full cursor-pointer hover:bg-gray-200 dark:hover:bg-gray-600 transition-fast" @click="showToc = false">
          <i class="ri-close-line text-lg"></i>
        </div>
      </div>
      <div class="post-toc-container">
        <ul class="markdownIt-TOC">
<li><a href="#%E5%B1%80%E9%83%A8%E5%8F%98%E9%87%8F%E5%92%8C%E5%85%A8%E5%B1%80%E5%8F%98%E9%87%8F">局部变量和全局变量</a>
<ul>
<li><a href="#%E5%B1%80%E9%83%A8%E5%8F%98%E9%87%8F">局部变量</a></li>
<li><a href="#%E5%85%A8%E5%B1%80%E5%8F%98%E9%87%8F">全局变量</a></li>
</ul>
</li>
<li><a href="#%E4%BD%9C%E7%94%A8%E5%9F%9F%E5%92%8C%E9%93%BE%E6%8E%A5%E5%B1%9E%E6%80%A7">作用域和链接属性</a>
<ul>
<li><a href="#%E4%BB%A3%E7%A0%81%E5%9D%97%E4%BD%9C%E7%94%A8%E5%9F%9F">代码块作用域</a></li>
<li><a href="#%E6%96%87%E4%BB%B6%E4%BD%9C%E7%94%A8%E5%9F%9F">文件作用域</a></li>
<li><a href="#%E5%8E%9F%E5%9E%8B%E4%BD%9C%E7%94%A8%E5%9F%9F">原型作用域</a></li>
<li><a href="#%E5%87%BD%E6%95%B0%E4%BD%9C%E7%94%A8%E5%9F%9F">函数作用域</a></li>
<li><a href="#%E9%93%BE%E6%8E%A5%E5%B1%9E%E6%80%A7">链接属性</a></li>
</ul>
</li>
<li><a href="#%E7%94%9F%E5%AD%98%E6%9C%9F%E5%92%8C%E5%AD%98%E5%82%A8%E7%B1%BB%E5%9E%8B">生存期和存储类型</a>
<ul>
<li><a href="#%E7%94%9F%E5%AD%98%E6%9C%9F">生存期</a></li>
<li><a href="#%E5%AD%98%E5%82%A8%E7%B1%BB%E5%9E%8B">存储类型</a>
<ul>
<li><a href="#1-%E8%87%AA%E5%8A%A8%E5%8F%98%E9%87%8F">1. 自动变量</a></li>
<li><a href="#2-%E5%AF%84%E5%AD%98%E5%99%A8%E5%8F%98%E9%87%8F">2. 寄存器变量</a></li>
<li><a href="#3-%E9%9D%99%E6%80%81%E5%B1%80%E9%83%A8%E5%8F%98%E9%87%8F">3. 静态局部变量</a></li>
<li><a href="#4-extern">4.  extern</a></li>
<li><a href="#5-typedef">5.  typedef</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#%E9%80%92%E5%BD%92">递归</a>
<ul>
<li><a href="#%E4%BB%80%E4%B9%88%E6%98%AF%E9%80%92%E5%BD%92">什么是递归</a></li>
<li><a href="#%E9%80%92%E5%BD%92%E6%B1%82%E6%96%90%E6%B3%A2%E9%82%A3%E5%A5%91%E6%95%B0%E5%88%97">递归求斐波那契数列</a></li>
<li><a href="#%E9%80%92%E5%BD%92%E6%B1%82%E6%B1%89%E8%AF%BA%E5%A1%94">递归求汉诺塔</a></li>
<li><a href="#%E5%88%86%E6%B2%BB%E6%B3%95">分治法</a></li>
</ul>
</li>
</ul>

      </div>
    </div>

    <!-- Back to top -->
    <div class="fixed right-0 bottom-0 mb-4 mr-4 shadow w-8 h-8 rounded-full flex justify-center items-center z-10 cursor-pointer bg-white hover:shadow-lg transition-all dark:bg-gray-500 dark:text-gray-200" @click="backToUp" v-show="scrolled">
      <i class="ri-arrow-up-line"></i>
    </div>
  </div>

  <!-- Root element of PhotoSwipe. Must have class pswp. -->
<div class="pswp" tabindex="-1" role="dialog" aria-hidden="true">
  <!-- Background of PhotoSwipe. 
        It's a separate element as animating opacity is faster than rgba(). -->
  <div class="pswp__bg">
  </div>
  <!-- Slides wrapper with overflow:hidden. -->
  <div class="pswp__scroll-wrap">
    <!-- Container that holds slides. 
            PhotoSwipe keeps only 3 of them in the DOM to save memory.
            Don't modify these 3 pswp__item elements, data is added later on. -->
    <div class="pswp__container">
      <div class="pswp__item">
      </div>
      <div class="pswp__item">
      </div>
      <div class="pswp__item">
      </div>
    </div>
    <!-- Default (PhotoSwipeUI_Default) interface on top of sliding area. Can be changed. -->
    <div class="pswp__ui pswp__ui--hidden">
      <div class="pswp__top-bar">
        <!--  Controls are self-explanatory. Order can be changed. -->
        <div class="pswp__counter">
        </div>
        <button class="pswp__button pswp__button--close" title="Close (Esc)"></button>
        <button class="pswp__button pswp__button--fs" title="Toggle fullscreen"></button>
        <button class="pswp__button pswp__button--zoom" title="Zoom in/out"></button>
        <!-- Preloader demo http://codepen.io/dimsemenov/pen/yyBWoR -->
        <!-- element will get class pswp__preloader--active when preloader is running -->
        <div class="pswp__preloader">
          <div class="pswp__preloader__icn">
            <div class="pswp__preloader__cut">
              <div class="pswp__preloader__donut">
              </div>
            </div>
          </div>
        </div>
      </div>
      <div class="pswp__share-modal pswp__share-modal--hidden pswp__single-tap">
        <div class="pswp__share-tooltip">
        </div>
      </div>
      <button class="pswp__button pswp__button--arrow--left" title="Previous (arrow left)">
      </button>
      <button class="pswp__button pswp__button--arrow--right" title="Next (arrow right)">
      </button>
      <div class="pswp__caption">
        <div class="pswp__caption__center">
        </div>
      </div>
    </div>
  </div>
</div>

  <script src="https://cdn.jsdelivr.net/npm/vue/dist/vue.js"></script>
  <script src="https://harriswilde.github.io/media/scripts/main.js"></script>
  
  <!-- Code Highlight -->
  
    <script src="https://harriswilde.github.io/media/prism.js"></script>
    <script>
      Prism.highlightAll()
    </script>
  

  <script src="https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe-ui-default.min.js"></script>
  <script>
    //拿到预览框架，也就是上面的html代码
    var pswpElement = document.querySelectorAll('.pswp')[0];
    //定义图片数组变量
    var imgitems;
    /**
    * 用于显示预览界面
    * @param index 图片数组下标
    */
    function viewImg(index) {
      //其它选项这里不做过多阐述，详情见官网
      var pswpoptions = {
        index: parseInt(index, 10), // 开始幻灯片索引。0是第一张幻灯片。必须是整数，而不是字符串。
        bgOpacity: 0.7, // 背景透明度，0-1
        maxSpreadZoom: 3, // 缩放级别，不要太大
      };
      //初始化并打开PhotoSwipe，pswpElement对应上面预览框架，PhotoSwipeUI_Default为皮肤，imgitems为图片数组，pswpoptions为选项
      var gallery = new PhotoSwipe(pswpElement, PhotoSwipeUI_Default, imgitems, pswpoptions);
      gallery.init()
    }
    /**
    * 用于添加图片点击事件
    * @param img 图片元素
    * @param index 所属下标（在imgitems中的位置）
    */
    function addImgClick(img, index) {
      img.onclick = function() {
        viewImg(index)
      }
    }
    /**
    * 轮询所有图片，获取src、width、height等数据，加入imgitems，并给图片元素添加事件
    * 最好在onload中执行该方法，本站因放在最底部，所以直接初始化
    * 异步加载图片可在图片元素创建完成后调用此方法
    */
    function initImg() {
      //重置图片数组
      imgitems = [];
      //查找class:markdown 下的所有img元素并遍历
      var imgs = document.querySelectorAll('.markdown img');
      for (var i = 0; i < imgs.length; i++) {
        var img = imgs[i];
        //本站相册初始为loading图片，真实图片放在data-src
        var ds = img.getAttribute("data-src");
        //创建image对象，用于获取图片宽高
        var imgtemp = new Image();
        //判断是否存在data-src
        if (ds != null && ds.length > 0) {
          imgtemp.src = ds
        } else {
          imgtemp.src = img.src
        }
        //判断是否存在缓存
        if (imgtemp.complete) {
          var imgobj = {
            "src": imgtemp.src,
            "w": imgtemp.width,
            "h": imgtemp.height,
          };
          imgitems[i] = imgobj;
          addImgClick(img, i);
        } else {
          console.log('进来了2')
          imgtemp.index = i;
          imgtemp.img = img;
          imgtemp.onload = function() {
            var imgobj = {
              "src": this.src,
              "w": this.width,
              "h": this.height,
            };
            //不要使用push，因为onload前后顺序会不同
            imgitems[this.index] = imgobj
            //添加点击事件
            addImgClick(this.img, this.index);
          }
        }
      }
    }
    //初始化
    initImg();
  </script>
  
  
</body>

</html>