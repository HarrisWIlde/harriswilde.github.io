<!DOCTYPE html>
<html>
  <head>
    <meta charset="UTF-8"/>
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
<title>C语言的分支与循环 | TechZone</title>
<meta name="keywords" content="TechZone">
<meta name="description" content="HarrisWilde祝诸君元旦快乐🎉">
<link rel="shortcut icon" href="https://harriswilde.github.io/favicon.ico?v=1581055240293">
<link rel="stylesheet" href="https://harriswilde.github.io/styles/main.css">

<link rel="stylesheet" href="/media/css/pisces.css">

<link rel="stylesheet" href="/media/fonts/font-awesome.css">
<link href="//fonts.googleapis.com/css?family=Monda:300,300italic,400,400italic,700,700italic|Roboto Slab:300,300italic,400,400italic,700,700italic|Rosario:300,300italic,400,400italic,700,700italic|PT Mono:300,300italic,400,400italic,700,700italic&subset=latin,latin-ext" rel="stylesheet" type="text/css">

<link href="/media/hljs/styles/monokai-sublime.css" rel="stylesheet">  
<script src="/media/hljs/highlight.js"></script>

<script src="https://cdn.jsdelivr.net/npm/velocity-animate@1.5.0/velocity.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/velocity-animate@1.5.0/velocity.ui.min.js"></script>

<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.11.1/dist/katex.min.css" integrity="sha384-zB1R0rpPzHqg7Kpt0Aljp8JPLqbXI3bhnPWROx27a9N0Ll6ZP/+DiW/UqRcLbRjq" crossorigin="anonymous">
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.11.1/dist/katex.min.js" integrity="sha384-y23I5Q6l+B6vatafAwxRu/0oK/79VlbSz7Q9aiSZUvyWYIYsd+qj+o24G5ZU2zJz" crossorigin="anonymous"></script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.11.1/dist/contrib/auto-render.min.js" integrity="sha384-kWPLUVMOks5AQFrykwIup5lo0m3iMkkHrD0uJ4H5cjeGihAutqP0yW0J6dpFiVkI" crossorigin="anonymous"
    onload="renderMathInElement(document.body);"></script>
    <meta name="description" content="C语言的分支与循环" />
    <meta name="keywords" content="Clang" />
    <meta name="theme-color" content="#222222"/>
  </head>
  <body>
    <div class="head-top-line"></div>
    <div class="header-box">
      
<div class=" pisces">
  <header class="header bg-color ">
    <div class="blog-header box-shadow-wrapper bg-color " id="header">
      <div class="nav-toggle" id="nav_toggle">
        <div class="toggle-box">
          <div class="line line-top"></div>
          <div class="line line-center"></div>
          <div class="line line-bottom"></div>
        </div>
      </div>
      <div class="site-meta">       
        <div class="site-title">
          
            <a href="/" class="brand">
              <span>TechZone</span>
            </a>  
          
        </div>
        
          <p class="subtitle">HarrisWilde的官方个人博客</p>
        
      </div>
      <nav class="site-nav" id="site_nav">
        <ul id="nav_ul">
          
            <li class="nav-item ">
              
                <a href="/">
                  <i class="fa fa-home"></i> 首页
                </a>
              
            </li>
          
            <li class="nav-item ">
              
                <a href="/archives">
                  <i class="fa fa-archive"></i> 归档
                </a>
              
            </li>
          
            <li class="nav-item ">
              
                <a href="/tags">
                  <i class="fa fa-tags"></i> 分类
                </a>
              
            </li>
          
            <li class="nav-item ">
              
                <a href="https://www.jianshu.com/u/766d2f134900" target="_blank">
                  <i class="fa fa-globe"></i> 简书
                </a>
              
            </li>
          
          <li class="nav-item">
            <a>
              <i class="fa fa-search"></i> 搜索
            </a>
          </li>
        </ul>
      </nav>
    </div>
  </header>
</div>

<script type="text/javascript"> 
 
  let showNav = true;

  let navToggle = document.querySelector('#nav_toggle'),
  siteNav = document.querySelector('#site_nav');
  
  function navClick() {
    let sideBar = document.querySelector('.sidebar');
    let navUl = document.querySelector('#nav_ul');
    navToggle.classList.toggle('nav-toggle-active');
    siteNav.classList.toggle('nav-menu-active');
    if (siteNav.classList.contains('nav-menu-active')) {
      siteNav.style = "height: " + (navUl.children.length * 42) +"px !important";
    } else {
      siteNav.style = "";
    }
  }

  navToggle.addEventListener('click',navClick);  
</script>
    </div>
    <div class="main-continer">
      
      <div class="section-layout pisces ">
        <div class="section-layout-wrapper">
          

<div class="sidebar">
    <div class="sidebar-box box-shadow-wrapper bg-color right-motion" id="sidebar">
      
        <div class="post-list-sidebar">
          <div class="sidebar-title">
            <span id="tocSideBar" class="sidebar-title-item sidebar-title-active">文章目录</span>
            <span id="metaSideBar" class="sidebar-title-item">站点概览</span>
          </div>
        </div>
      
      <div class="sidebar-body pisces" id="sidebar_body">
        
          <div class="post-side-meta" id="post_side_meta">
            
<div class="sidebar-wrapper box-shadow-wrapper bg-color">
  <div class="sidebar-item">
    <img class="site-author-image right-motion" src="https://harriswilde.github.io/images/avatar.png"/>
    <p class="site-author-name">TechZone</p>
    <p class="site-description right-motion">2020，共同进步！</p>
  </div>
  <div class="sidebar-item side-item-stat right-motion">
    <div class="sidebar-item-box">
      <a href="/archives/">
        
        <span class="site-item-stat-count">18</span>
        <span class="site-item-stat-name">文章</span>
      </a>
    </div>
    <div class="sidebar-item-box">
      <a href="">
        <span class="site-item-stat-count">6</span>
        <span class="site-item-stat-name">分类</span>
      </a>
    </div>
    <div class="sidebar-item-box">
      <a href="/tags/">
        <span class="site-item-stat-count">6</span>
        <span class="site-item-stat-name">标签</span>
      </a>
    </div>
  </div>
  
    
      <div class="sidebar-item" style="border-top: 1px dotted #ccc; margin-top: 10px;">
      </div>
    
  
  


</div>
          </div>
          <div class="post-toc sidebar-body-active" id="post_toc" style="opacity: 1;">
            <div class="toc-box right-motion">
  <div class="toc-wrapper auto-number auto" id="toc_wrapper">
    <ul class="markdownIt-TOC">
<li><a href="#%E5%AD%97%E7%AC%A6%E4%B8%B2">字符（串）</a></li>
<li><a href="#%E5%BC%BA%E5%88%B6%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2">强制类型转换</a></li>
<li><a href="#%E5%88%86%E6%94%AF%E6%9D%A1%E4%BB%B6%E8%AF%AD%E5%8F%A5">分支(条件语句)</a>
<ul>
<li><a href="#%E7%9F%AD%E8%B7%AF%E6%B1%82%E5%80%BC">短路求值</a></li>
<li><a href="#if%E8%AF%AD%E5%8F%A5">if语句</a></li>
<li><a href="#switch-%E8%AF%AD%E5%8F%A5">switch 语句</a></li>
</ul>
</li>
<li><a href="#%E5%BE%AA%E7%8E%AF">循环</a>
<ul>
<li><a href="#while%E5%BE%AA%E7%8E%AF">while循环</a></li>
<li><a href="#do-while%E5%BE%AA%E7%8E%AF">do-while循环</a></li>
<li><a href="#for%E5%BE%AA%E7%8E%AF">for循环</a></li>
<li><a href="#break%E8%AF%AD%E5%8F%A5">break语句</a></li>
<li><a href="#continue%E8%AF%AD%E5%8F%A5">continue语句</a></li>
<li><a href="#%E9%80%97%E5%8F%B7%E8%BF%90%E7%AE%97%E7%AC%A6">逗号运算符</a></li>
<li><a href="#%E6%9D%A1%E4%BB%B6%E8%BF%90%E7%AE%97%E7%AC%A6">条件运算符</a></li>
<li><a href="#goto%E8%AF%AD%E5%8F%A5">goto语句</a></li>
<li><a href="#%E5%B5%8C%E5%A5%97%E5%BE%AA%E7%8E%AF">嵌套循环</a></li>
</ul>
</li>
</ul>

  </div>
</div>

<script>

let lastTop = 0, lList = [], hList = [], postBody, lastIndex = -1; 
let active = 'active-show', activeClass = 'active-current';
let tocWrapper = document.querySelector('#toc_wrapper');
let tocContent = tocWrapper.children[0];
let autoNumber = tocWrapper&&tocWrapper.classList.contains('auto-number');

function addTocNumber(elem, deep) {
  if (!elem) {
    return;
  }
  let prop = elem.__proto__;

  if (prop === HTMLUListElement.prototype) {
    for (let i = 0; i < elem.children.length; i++) {
      addTocNumber(elem.children[i], deep + (i + 1) + '.');
    }
  } else if (prop === HTMLLIElement.prototype) {
    // 保存li元素
    lList.push(elem);
    for (let i = 0; i < elem.children.length; i++) {
      let cur = elem.children[i];
      if (cur.__proto__ === HTMLAnchorElement.prototype) {
        if (autoNumber) {
          cur.text =  deep + ' ' + cur.text;
        }
      } else if (cur.__proto__ === HTMLUListElement.prototype) {
        addTocNumber(cur, deep);
      }
    }
  }
}


document.addEventListener('scroll', function(e) {
  if (lList.length <= 0) {
    return;
  }
  let scrollTop = document.scrollingElement.scrollTop;
  let dir;

  if (lastTop - scrollTop > 0) {
    dir = 'up';
  } else {
    dir = 'down';
  }

  lastTop = scrollTop;
  if (scrollTop <= 0) {
    if (lastIndex >= 0 && lastIndex < hList.length) {
      lList[lastIndex].classList.remove(activeClass);
    }
    return;
  }

  let current = 0, hasFind = false;
  for (let i = 0; i < hList.length; i++) {
    if (hList[i].offsetTop > scrollTop) {
      current = i;
      hasFind = true;
      break;
    }
  }
  if (!hasFind && scrollTop > lList[lList.length - 1].offsetTop) {
    current = hList.length - 1;
  } else {
    current--;
  }
  if (dir === 'down') {
    if (current > lastIndex) {
      addActiveClass(current);
      removeActiveClass(lastIndex) 
      lastIndex = current;
      removeParentActiveClass();
      lList[current] && addActiveLiElemment(lList[current].parentElement,tocContent);
    }
  } else {
    if (current < lastIndex) {
      addActiveClass(current);
      removeActiveClass(lastIndex);
      lastIndex = current;
      removeParentActiveClass();
      lList[current] && addActiveLiElemment(lList[current].parentElement,tocContent);
    }
  }
});

function removeParentActiveClass() {
  let parents = tocContent.querySelectorAll('.'+active)
  parents.forEach(function(elem) {
    elem.classList.remove(active);
  });
}

function addActiveClass(index) {
  if (index >= 0 && index < hList.length) {
    lList[index].classList.add(activeClass);
  }
}

function removeActiveClass(index) {
  if (index >= 0 && index < hList.length) {
    lList[index].classList.remove(activeClass);
  }
}

function addActiveLiElemment(elem, parent) {
  if (!elem || elem === parent) {
    return;
  } else {
    if (elem.__proto__ === HTMLLIElement.prototype) {
      elem.classList.add(active);
    }
    addActiveLiElemment(elem.parentElement, parent);
  }
}

function showToc() {
  if (tocWrapper) {
    postBody = document.querySelector('#post_body');
    for (let i = 0; i < postBody.children.length; i++) {
      if (postBody.children[i].__proto__ === HTMLHeadingElement.prototype) {
        hList.push(postBody.children[i]);
      }
    }
    if (tocWrapper.classList.contains('compress')) {
        tocContent.classList.add('closed');
    } else if (tocWrapper.classList.contains('no_compress')){
      tocContent.classList.add('expanded');
    } else {
      if (hList.length > 10) {
        active = 'active-hidden'
        tocContent.classList.add('closed');
      } else {
        tocContent.classList.add('expanded');
      }
    }
  }
}
addTocNumber(tocContent, '');

window.addEventListener('load', function() {
  showToc();
  document.querySelector('#sidebar').style='display: block;';
  tocWrapper.classList.add('toc-active');
  setTimeout(function() {
    if ("createEvent" in document) {
      let evt = document.createEvent("HTMLEvents");
      evt.initEvent("scroll", false, true);
      document.dispatchEvent(evt);
    }
    else {
      document.fireEvent("scroll");
    }
  }, 500)
})

</script>
          </div>
        
      </div>
    </div>
</div>
<script>
  const SIDEBAR_TITLE_ACTIVE = 'sidebar-title-active';
  const SIDEBAR_BODY_ACTIVE = 'sidebar-body-active';
  const SLIDE_UP_IN = 'slide-up-in';

  let sidebar = document.querySelector('#sidebar'),
  tocSideBar = document.querySelector('#tocSideBar'),
  metaSideBar = document.querySelector('#metaSideBar'),
  postToc = document.querySelector('#post_toc'),
  postSiteMeta = document.querySelector('#post_side_meta'),
  sidebarTitle = document.querySelector('.sidebar-title'),
  sidebarBody = document.querySelector('#sidebar_body');

  tocSideBar && tocSideBar.addEventListener('click', (e) => {
    toggleSidebar(e);
  });

  metaSideBar && metaSideBar.addEventListener('click', (e) => {
    toggleSidebar(e);
  });

  function toggleSidebar(e) {
    let currentTitle = document.querySelector("."+SIDEBAR_TITLE_ACTIVE);
    if (currentTitle == e.srcElement) {
      return ;
    }
    let current, showElement, hideElement;
    if (e.srcElement == metaSideBar) {
      showElement = postSiteMeta;
      hideElement = postToc;
    } else if (e.srcElement == tocSideBar){
      showElement = postToc;
      hideElement = postSiteMeta;
    }
    currentTitle.classList.remove(SIDEBAR_TITLE_ACTIVE);
    e.srcElement.classList.add(SIDEBAR_TITLE_ACTIVE);

    window.Velocity(hideElement, 'stop');
    window.Velocity(hideElement, 'transition.slideUpOut', {
      display: 'none',
      duration: 200,
      complete: function () {
        window.Velocity(showElement, 'transition.slideDownIn', {
          duration: 200
        });
      }
    })
    hideElement.classList.remove(SIDEBAR_BODY_ACTIVE);
    showElement.classList.add(SIDEBAR_BODY_ACTIVE);
  }

  postToc.addEventListener('transitionend', function() {
    this.classList.remove(SLIDE_UP_IN);
  });


  if (sidebarBody.classList.contains('pisces') || sidebarBody.classList.contains('gemini')) {
    let hasFix = false;
    let scrollEl = document.querySelector('.main-continer');
    let limitTop = document.querySelector('#nav_ul').children.length * 42 + 162;
    window.addEventListener('scroll', function(e) {
    if (document.scrollingElement.scrollTop >= limitTop) {
      if (!hasFix) {
        sidebar.classList.add('sidebar-fixed');
        hasFix = true;
      }
    } else {
      if (hasFix) {
        sidebar.classList.remove('sidebar-fixed');
        hasFix = false;
      }
    }
  });
  }
  
</script>
          <div class="section-box box-shadow-wrapper">
            <div class="section bg-color post post-page">
              <div class="article-box">
    <header class="post-header">
  <h1 class="post-title">
    <a class="post-title-link" href="https://harriswilde.github.io/post/CBranchCycle">
      C语言的分支与循环
    </a>
  </h1>
  <div class="post-meta">
    
    <span class="meta-item pc-show">
      <i class="fa fa-calendar-o"></i>
      <span>发布于</span>
      <span>2019-11-07</span>
    </span>
    
      <span class="meta-item">
        <span class="post-meta-divider pc-show">|</span>
        <i class="fa fa-folder-o"></i>
        <span class="pc-show">分类于</span>
        
          
            <a href="https://harriswilde.github.io/tag/qrA-i8flt">
              <span>Clang</span>
            </a>
          
        
      </span>
      <span class="post-meta-divider">|</span>
    
    <span class="meta-item">
      <i class="fa fa-clock-o"></i>
      <span>22分钟</span>
    </span>
    <span class="meta-item">
      <span class="post-meta-divider">|</span>
      <i class="fa fa-file-word-o"></i>
      <span>5348<span class="pc-show">字数</span></span>
    </span>
  </div>
</header>
</div>
              <div class="post-body next-md-body" id="post_body">
                <p>如果说我们之前写过的代码都是“直男”，也就是说不管三七二十一，一路走到黑，那么今天我们就来见识下“多虑”型的还有“徘徊”型的代码。（你没有看错，代码不仅可以犹豫，还可以徘徊）</p>
<p>不过，在这之前，我还是来介绍两个之前就应该讲到的知识，与下文可能关系不大，但是放哪儿讲都差不多。</p>
<h1 id="字符串">字符（串）</h1>
<p>我们其实已经知道了C语言只有<strong>字符</strong>一种变量，就是<code>char</code>，而并没有像某些语言那样规定<strong>字符串</strong>这种类型。但是，是不是字符串在C语言里面就没有呢？</p>
<p>其实不然，只不过没有专属的类型而已。</p>
<p>定义一个字符的的方法，想必大家都已经掌握了，就像下面这个例子一样：</p>
<pre><code class="language-c">//Example 01
#include &lt;stdio.h&gt;
int main(void)
{
    char Letter;
    Letter = 'A';
    return 0;
}
</code></pre>
<p>这样，我们就定义了一个叫Letter的字符变量,并且赋值为字符A。</p>
<p>那么字符串该如何定义呢？</p>
<pre><code class="language-c">//Example 02
#include &lt;stdio.h&gt;
int main(void)
{
    char String[8];
    String = {'T','e','c','h','Z','o','n','e'};
    printf(&quot;%s&quot;,String);
    return 0;
}
</code></pre>
<p>这样，我们就定义了一个名字叫String的<strong>字符串</strong>，还让它输出到我们屏幕上了。如果你了解过<strong>数组</strong>，就觉得这种方式很像数组对吧，这里提前告诉大家，<strong>字符串就是一种数组</strong>。但是，如果你去执行下这段代码你就会发现问题了。输出的TechZone后面，还会跟着一些乱码……</p>
<p>咦？我明明只定义了8个字符，怎么还多出来这些鬼东西呢？</p>
<p>那么，我们来了解下C语言时如何处理字符串的。我们可以理解，字符串的长度是有限的，而且长度<strong>一旦确定</strong>，在其生命周期里就<strong>无法再次更改</strong>。那么，系统为了确保字符串是真的结束了，会在<strong>末尾</strong>加一个<code>\0</code>来表示字符串的结束。我们做如下的修改，就可以让字符串正常工作了：</p>
<pre><code class="language-c">//Example 03
#include &lt;stdio.h&gt;
int main(void)
{
    char String[9];
    String = {'T','e','c','h','Z','o','n','e','\0'};
    printf(&quot;%s&quot;,String);
    return 0;
}
</code></pre>
<p>你可能会想了，这样也太麻烦了吧，要是我要输入一句话，那得多少个引号逗号，最后还可能忘记加\0。你这是把程序员不当人看？？</p>
<p>当然不会。我们可以这样定义：</p>
<pre><code class="language-c">//Example 04
#include &lt;stdio.h&gt;
int main(void)
{
    char String[];
    String = {&quot;TechZone&quot;};
    printf(&quot;%s&quot;,String);
    return 0;
}
</code></pre>
<p>看到了吧，是不是简单很多了？而且后面还会<strong>自动补上</strong>一个<code>\0</code>，简直就是高枕无忧了。</p>
<p>有人可能有意见了，说你怎么不早点告诉我，害得我差点不学了……</p>
<p>学习当然得从学基础的开始啦，别打我，别打我……</p>
<h1 id="强制类型转换">强制类型转换</h1>
<p>在<strong>操作数不同</strong>的情况下，大部分的运算符中，都会将<strong>精度低</strong>的类型转成<strong>精度高</strong>的类型，这样做，其实也就是为了确保精度罢了。</p>
<p>但是有的时候，我们也许并不希望像系统那样的转换，那么我们可以自己进行强制转换。</p>
<p>具体方法：<code>(类型名称)变量名或值</code></p>
<p>例如：</p>
<pre><code class="language-c">//Example 05
#include &lt;stdio.h&gt;
int main(void)
{
    int num;
    num = (float)5/9;
    printf(&quot;%d&quot;,num);
    return 0;
}
</code></pre>
<p>在这个例子中，我们将5这个<strong>整型</strong>转化成了<strong>浮点型</strong>，那么为了确保精度，系统也会将后面的9也转化成浮点型。那么这样就可以输出结果，不然结果就是0（因为两个整型相除结果也会<strong>取整</strong>，然鹅，强制取整的结果就是<strong>保留整数</strong>，而<strong>不是</strong>四舍五入）。</p>
<hr>
<h1 id="分支条件语句">分支(条件语句)</h1>
<p>我们高中数学中，如果有学过程序框图的同学，应该就还依稀记得程序的几种结构，其中<strong>分支</strong>和<strong>循环</strong>就是今天要谈的两大结构。</p>
<p>首先我们来看看一些分支里面经常使用的运算符：</p>
<ol>
<li>
<p>关系运算符</p>
<table>
<thead>
<tr>
<th>运算符</th>
<th>优先级</th>
</tr>
</thead>
<tbody>
<tr>
<td>&lt;</td>
<td>高</td>
</tr>
<tr>
<td>&lt;=</td>
<td>高</td>
</tr>
<tr>
<td>&gt;</td>
<td>高</td>
</tr>
<tr>
<td>&gt;=</td>
<td>高</td>
</tr>
<tr>
<td>==</td>
<td>低</td>
</tr>
<tr>
<td>!=</td>
<td>低</td>
</tr>
</tbody>
</table>
</li>
<li>
<p>逻辑运算符</p>
<table>
<thead>
<tr>
<th>运算符</th>
<th>优先级</th>
</tr>
</thead>
<tbody>
<tr>
<td>!    (逻辑非)</td>
<td>高</td>
</tr>
<tr>
<td>&amp;&amp;(逻辑与)</td>
<td>中</td>
</tr>
<tr>
<td>||   (逻辑或)</td>
<td>低</td>
</tr>
</tbody>
</table>
</li>
</ol>
<p>此外，在编译器中，所有的字符都被看成ASCII，因此ASCII字符之间运算或者比较等等都是<strong>合法的</strong>。</p>
<h2 id="短路求值">短路求值</h2>
<p>在C语言中，如果设置两个表达式，在求出<strong>第一个式子</strong>即可判断出结果的时候，系统就<strong>不会</strong>继续求第二个式子。这看上去是编译器的一种算法的优化，但是如果写代码的时候不注意的话，很有可能造成一些隐性的漏洞，看下面的例子：</p>
<pre><code class="language-c">//Example 06
#include &lt;stdio.h&gt;
int main(void)
{
    int a = 3,b = 3;
    (a = 0) &amp;&amp; (b = 5);
    printf(&quot;a=%d, b=%d\n&quot;,a,b);
    //==========================
    (a = 1) || (b = 5);
    printf(&quot;a=%d, b=%d\n&quot;,a,b);
    return 0;
}
</code></pre>
<p>如果你愿意自己尝试的话，可以自己去环境里面试试，如果不愿意的话那直接看下面的结果：</p>
<pre><code>//Consequence 06
a=0,b=3
a=1,b=3
</code></pre>
<p>如果没有开头的那段解释，我相信很多初学者都会很懵逼，怎么会这样？</p>
<p>不着急，我们来分析下代码。</p>
<p>我们看看分割线上面的那部分，a和b都被初始化成了整型并且赋值为3。在第一句逻辑判断语句里面，是判断的<strong>逻辑与</strong>，也就是说，<strong>全真则真，一假全假</strong>。那么在判断数字的时候，则默认0为假，非0为真。那么这句<code>(a = 0) &amp;&amp; (b = 5);</code>前面，a已经被赋值为0，那么已经为假了，在逻辑与的情况下，就算后面的条件再真，整体也是假的了，这就是所谓的<strong>一假全假</strong>。那么，在判断了第一个表达式之后，就可以做出判断结果，那么后面的<code>b=5</code>就<strong>不会</strong>被执行。</p>
<p>同理，分割线下面的代码也是一个道理。只不过这里判断变成了<strong>逻辑或</strong>。逻辑或的标准就是<strong>一真则真，全假才假</strong>。那么，前面的<code>a=1</code>，系统发现，欸，已经是真了哟！那么马上罢工，后面的<code>b=5</code>也就<strong>不予理会</strong>了。那么输出的结果就是上面那样了，理解了吧？</p>
<p>我们现在单独这样讲这个特性，貌似感觉看不出什么，但是以后写代码的时候其实要留意下短路求值，因为这样子可能就会造成你的程序里面有Bug，而且还相当<strong>不好找</strong>！！</p>
<h2 id="if语句">if语句</h2>
<p>if语句实际上就是判断条件，若符合的就输出。之所以叫它分支，那是因为如果到了条件语句，那么这里面的代码就<strong>不一定都能</strong>执行了，而是看情况来。也就是说，条件语句里面的<strong>部分代码</strong>，可能你的程序跑完了都没有没用到，因此就叫分支。</p>
<p>那么if语句的通式就像下面那样</p>
<pre><code class="language-c">if (...)
{
    ...;
}
else if (...)//可选
{
    ...;
}
else if (...)//可选
{
    ...;
}
...;//else if可有多个
else //上述条件都不符合，则执行这个语句，可选
{
    ...;
}
</code></pre>
<p>我想大家看里面的注释就能够大致明白的差不多了。其中if语句是<strong>必须</strong>的，其他的是<strong>可选</strong>的。else if则表示的是当if的条件不符合的时候，就会继续判断所有的else if，若有符合条件的就执行后面的语句，若都不符合就执行else的语句。如果没有else if而有else，那么当if不符合的时候就执行else后面的语句。若有else if没有else，则无符合条件的话不执行任何语句。else if和else都没有的话，那么if不符合的时候就啥都不干。</p>
<p>看下面的例子，我们来制作一个识别星期的程序并且给出建议：</p>
<pre><code class="language-c">//Example 07
#include &lt;stdio.h&gt;
int main(void)
{
    int Weekday;
    printf(&quot;输入今天星期的数字：&quot;);
    scanf(&quot;%d&quot;,&amp;Weekday);//此处用于获取用户输入的内容并赋值给Weekday
    if (Weekday &gt;= 1 &amp;&amp; WeekDay &lt;= 5)
    {
        printf(&quot;今天是工作日！好好工作！\n&quot;);
    }
    else if (Weekday &gt;=6 &amp;&amp; Weekday &lt;=7)
    {
        printf(&quot;今天是周末！好好休息！&quot;);
    }
    else
    {
        printf(&quot;你输入有误哦！&quot;);
    }
    return 0;
}
</code></pre>
<p>看到了吧，我们成功地运用了分支。这个只是一个简单的例子，以后大家写程序的时候，大概就没有这么简单的了。很多情况下，我们需要<strong>嵌套分支</strong>来使用。那么嵌套的时候，有些地方就要注意了，下面引用一个例子：</p>
<pre><code class="language-c">//Example 08
#include &lt;stdio.h&gt;
int main(void)
{
    char isRain,isFree;
    
    printf(&quot;是否有空？（Y/N）&quot;);
    scanf(&quot;%c&quot;,&amp;isFree);
    
    printf(&quot;是否下雨？（Y/N）&quot;);
    scanf(&quot;%c&quot;,&amp;isRain);
    
    if (isFree == 'Y' || isFree == 'y')
        if (isRain == 'Y' || isRain == 'y')
            printf(&quot;记得带伞哦！\n&quot;);
    else 
        printf(&quot;女神没空！\n&quot;);
    return 0;
}
</code></pre>
<p>程序实现如下：</p>
<pre><code>//Consequence 08-1
是否有空？（Y/N）Y
是否下雨？（Y/N）Y
记得带伞哦！
</code></pre>
<p>貌似没什么问题，但是如果下面这样：</p>
<pre><code>//Consequence 08-2
是否有空？（Y/N）Y
是否下雨？（Y/N）N
女神没空！
</code></pre>
<p>我的天，女神有空而且天公作美的情况下，程序居然告诉我女神没空？？？</p>
<p>其实我们分析下代码。代码的意思，大概是先在有空的情况下，如果下雨就提醒带伞，如果没空就直接告诉你没空。可是上面的问题是怎么回事呢？</p>
<p>其实你们被上面的<strong>缩进</strong>骗了。从上面的缩进来看，else应该是与第一个if同级，而不是第二个。但是！由于你<strong>没有</strong>加大括号，C语言没法判断你的语句块从属关系，那么就<strong>默认</strong>else跟随<strong>最近</strong>的那一个if。所以，这里的else是跟随第二个if的，这么看就不难理解输出结果了。如果要更改，那么像下面这样就可以了：</p>
<pre><code class="language-c">//Example 08 V2
#include &lt;stdio.h&gt;
int main(void)
{
    char isRain,isFree;
    
    printf(&quot;是否有空？（Y/N）&quot;);
    scanf(&quot;%c&quot;,&amp;isFree);
    
    printf(&quot;是否下雨？（Y/N）&quot;);
    scanf(&quot;%c&quot;,&amp;isRain);
    
    if (isFree == 'Y' || isFree == 'y')
    {
        if (isRain == 'Y' || isRain == 'y')
        {
            printf(&quot;记得带伞哦！\n&quot;);
        }
    }
    else 
        printf(&quot;女神没空！\n&quot;);
    return 0;
}
</code></pre>
<p>建议所有的if都打上大括号，至于怎么打，是个人习惯，比如<code>{</code>是打在if之后还是下一行，这都无所谓，但是确定了就尽量使用一种，不然以后自己看自己写的代码都会感觉很奇怪了。</p>
<h2 id="switch-语句">switch 语句</h2>
<p>虽然if语句十分方便而且灵活，但是在某些情况下，使用switch还是会更直观一些。</p>
<p>switch的通式为：</p>
<pre><code class="language-c">switch(变量名)
{
    case 常量1:语句1;break;
    case 常量2:语句2;break;
    case 常量3:语句3;break;
    case 常量4:语句4;break;
    case 常量5:语句5;break;
    case 常量6:语句6;break;
        ...
    case 常量n:语句n;break;
    default 常量:语句;break;
}
</code></pre>
<p>switch语句中case后面只能跟一个<strong>确定的值</strong>，而不能是范围等等。所以在特定的条件下会很直观，但是不够灵活。</p>
<p>比如上面Example 07中的代码，用switch可以这么改写：</p>
<pre><code class="language-C">//Example 07 V2
#include &lt;stdio.h&gt;
int main(void)
{
    int (Weekday);
    printf(&quot;输入今天星期的数字：&quot;);
    scanf(&quot;%d&quot;,&amp;Weekday);//此处用于获取用户输入的内容并赋值给Weekday
    switch Weekday
    {
        case 1:printf(&quot;今天周一，一鼓作气&quot;);break;
        case 2:printf(&quot;今天周二，再接再厉&quot;);break;
        case 3:printf(&quot;今天周三，坚持到底&quot;);break;
        case 4:printf(&quot;今天周四，效率第一&quot;);break;
        case 5:printf(&quot;今天周五，最后一击&quot;);break;
        case 6:printf(&quot;今天周六，好好休息&quot;);break;
        case 7:printf(&quot;今天周日，玩的开心&quot;);break;
        default:printf(&quot;你输入的有误哦！&quot;);break;
    }
}
</code></pre>
<p>这样一来是不是很直观呢？但是虽然直观，不是所有的时候都适合用这样的语句，大家根据自身的情况来选就行啦。</p>
<p>至于为什么一定要加break，那是因为其实case在这里面只是一个<strong>标记</strong>而已，也就是说，如果我满足case3，那么程序就自动<strong>跳到</strong>case3，然后<strong>继续往下</strong>执行。假设我一共有case7，那么不加break的话，case3一直到case7的语句都会被<strong>逐个执行</strong>，明白了吧？</p>
<hr>
<h1 id="循环">循环</h1>
<p>上面分支讲了那么多，现在我们来看看循环。</p>
<p>可以说，循环的出现，大大减少了程序员的工作量。而且正因为有了循环，程序员才能够通过巧妙的算法来使用循环去解决问题。比如，我现在想输出1-100之间的所有整数，如果没学循环，你可能会这么写：</p>
<pre><code class="language-c">//Example 09
#include &lt;stdio.h&gt;
int main(void)
{
    printf(&quot;1\n&quot;);
    printf(&quot;2\n&quot;);
    printf(&quot;3\n&quot;);
    ...
    printf(&quot;100\n&quot;);
    return 0;
}
</code></pre>
<p>这样写的逻辑思路没有错，但是谁会愿意呢？这样的编程有什么意义？我还不如拿一张纸记下来还更快呢。但是，我们是可以发现其中的规律的，就是每次输出都比之前的数大1，对吧？这就是接下来要讲的循环。</p>
<h2 id="while循环">while循环</h2>
<p>while循环也就是我们所说的<strong>当型循环</strong>。它的通式是：</p>
<pre><code>while(条件表达式)
	循环体
</code></pre>
<p>当满足一定的条件的时候，程序会自动循环写在循环体中的代码。比如上面的例子09中所体现出的，输出1-100。那么我们实现思路可以先设置一个变量，让这个变量<strong>每循环一次就加个1</strong>，然后当加到101的时候停止即可。写成代码如下：</p>
<pre><code class="language-c">//Example 09 V2
#include &lt;stdio.h&gt;
int main(void)
{
    int i = 1;
    while (i &lt; 101)
    {
        printf(&quot;%d\n&quot;,i);
        i++;
    }
    return 0;
}
</code></pre>
<p>这样，程序就自动执行输出我们想要的结果了，比一个一个手动要快了太多。</p>
<h2 id="do-while循环">do-while循环</h2>
<p>如果说while循环是个君子，那么do-while就是莽夫。while是<strong>先判断再执行</strong>，而本少爷则是管他什么，<strong>先执行再说</strong>。你可能已经猜到了，这就是直到型循环。do-while的语句通式如下：</p>
<pre><code class="language-c">do
    循环体
while (条件表达式);//(注意，这里有分号)
</code></pre>
<p>比如我们要算1加到100的和，也可以通过上面的例子用do-while进行更改：</p>
<pre><code class="language-c">//Example 09 V3
#include &lt;stdio.h&gt;
int main(void)
{
    int i = 1,sum = 0;
    do
    {
        sum += i;
        i++;
    }
    while (i&lt;101);
    printf(&quot;结果是%d\n&quot;,sum);
    return 0;
}
</code></pre>
<p>这次就不是每次都输出i了，而是每次吧i的值加到sum里面去，这样就可以算出最终结果了。</p>
<h2 id="for循环">for循环</h2>
<p>通过上面的两个例子大家也应该有点感觉了，在循环之前，一般是要定义一个<strong>计数变量</strong>，以此作为循环<strong>结束</strong>的参考。那么既然这样，有没有一种东西可以一次完成呢？这就是for语句。for循环就把计数变量和条件整合到一起去了，看通式：</p>
<pre><code class="language-c">for (循环初始化;循环条件;循环调整)
    循环体;
</code></pre>
<p>具体是啥意思，我们还是看例子。我们把上面的求和代码改成使用for：</p>
<pre><code class="language-c">//Example 09 V4
#include &lt;stdio.h&gt;
int main(void)
{
	int i, sum = 0;
	for (i = 1; i &lt; 101; i++)
	{
		sum += i;
	}
	printf(&quot;结果是%d&quot;, sum);
	return 0;
}
</code></pre>
<p>其实也是非常直观的。for语句其实三个成分可以<strong>不用都写</strong>甚至可以<strong>不写</strong>，但是分号一定要<strong>保留</strong>。如果没有明确的目的，那么最好不要这样用，因为会使代码可读性下降。</p>
<h2 id="break语句">break语句</h2>
<p>这个语句用于跳出循环。如果我们遍历<code>i</code>来寻找一个值，但凡找到，那其实就不用往下继续找了，那么就可以在循环中设置一个条件语句，如果找到结果则使用<code>break</code>跳出循环，这样可以节约算力。</p>
<p>但是，<code>break</code>只能跳出<strong>当前所在</strong>的循环，使用的时候一定注意。</p>
<h2 id="continue语句">continue语句</h2>
<p>跳过本轮循环然后进入下一轮循环。这个直接说可能没什么概念，我们看看下面的例子：</p>
<pre><code class="language-c">//Example 10
#include &lt;stdio.h&gt;
int main(void)
{
    int ch;
    while ((ch = getchar()) != '\n')
    {
        if (ch == 'e')
        {
            countinue;
        }
        putchar(ch);
    }
    putchar('\n');
    return 0;
}
</code></pre>
<p>这段代码是让用户输入一些字符，然后剔除其中的e然后再输出。</p>
<pre><code>//Consequence 10
TechZone
TchZon
</code></pre>
<p>应该很好理解吧，只要遇到了e就跳出本次循环，于是<code>putchar()</code>就被跳过去了。</p>
<p>可能有很多同学都觉得<code>for</code>和<code>while</code>其实差不多，但是，在<code>continue</code>语句里面很有可能就不一样。比如：</p>
<pre><code class="language-c">//Example 11
#include &lt;stdio.h&gt;
int main(void)
{
    int i;
    for (i = 1; i &lt; 10; i++)
    {
        if (i == 5)
        {
            continue;
        }
        printf(&quot;i = %d\n&quot;, i);
    }
    return 0;
}
</code></pre>
<p>如果让你把这个改成<code>while</code>，可能有的小伙伴会这么改：</p>
<pre><code class="language-c">//Example 11 V2
#include &lt;stdio.h&gt;
int main(void)
{
    int i = 1;
    while (i &lt; 10)
    {
        if ( i == 5)
        {
            continue;
            i++;
        }
        printf(&quot;i = %d\n&quot;, i);
        i++;
    }
}
</code></pre>
<p>这么看起来好像没有问题，但是执行到<code>continue</code>的时候，程序就陷入了<strong>死循环</strong>，无法执行到<code>i++</code>。因此不要随意更改已有的循环，如果真的有需要去改，也一定要思考清楚逻辑，想当然多半是会犯错误的。</p>
<h2 id="逗号运算符">逗号运算符</h2>
<p>当某个部分需要多个表达式的时候，使用逗号运算符来拼接。逗号运算符的优先级是<strong>最低</strong>的，但是它可以<strong>使整体</strong>从左到右进行。比如：</p>
<pre><code class="language-c">//Example 12
#include &lt;stdio.h&gt;
int main(void)
{
    int a,b,c;
    a = (b = 3, (c = b + 4) + 5);
    printf(&quot;a = %d, b = %d, c = %d\n&quot;, a, b, c);
    return 0;
}
</code></pre>
<p>在第6行里面。虽然<code>c = b + 4</code>被优先级最高的小括号括了起来，但是由于逗号运算符，还是优先从<code>b = 3</code>开始执行。</p>
<h2 id="条件运算符">条件运算符</h2>
<p>在C语言中，还有一种分支表达式就是条件运算符，它的通式为<code>exp1?exp2:exp3;</code>，其中exp1是<strong>条件表达式</strong>，当这个表达式判断为<strong>真</strong>时，执行exp2，反之执行exp3。比如下面的分支：</p>
<pre><code class="language-c">//Example 13
#include &lt;stdio.h&gt;
int main(void)
{
    int a = 3,b = 2;
    if (a &gt; b)
    {
        printf(&quot;Max is a\n&quot;);
    }
    else
    {
        printf(&quot;Max is b\n&quot;);
    }
    return 0;
}
</code></pre>
<p>这个就可以改成：</p>
<pre><code class="language-c">//Example 13 V2
#include &lt;stdio.h&gt;
int main(void)
{
    int a = 3,b = 2;
    a &gt; b ? printf(&quot;Max is a\n&quot;):printf(&quot;Max is b\n&quot;);
    return 0;
}
</code></pre>
<p>在条件不复杂的情况下使用这种语句其实更加方便，具体还是看个人的习惯来使用。</p>
<h2 id="goto语句">goto语句</h2>
<p>goto语句其实是个历史遗留问题。早期的编程语言都有<strong>汇编语言</strong>留下来的痕迹，goto就是其中之一。goto的作用就是让程序直接跳转到指定的位置。比如：</p>
<pre><code class="language-c">//Example 14
#include &lt;stdio.h&gt;
int main(void)
{
    int i = 5;
    while (i++)
    {
        if (i &gt; 10)
        {
            goto Lable;
        }
    }
Lable: printf(&quot;Here, i = %d\n&quot;, i);
    return 0;
}
</code></pre>
<p>当<code>i&gt;10</code>的时候直接跳转到<code>Lable</code>处了。</p>
<p>很多初学者刚刚接触<code>goto</code>的时候可能会觉得很实用，但是提醒大家，在实际开发的过程中，<strong>最好不用</strong><code>goto</code>语句。因为在代码之间跳来跳去，会破坏程序原有的逻辑。早期的程序代码就是满篇的<code>goto</code>，没有强大的大脑，很难一次性看懂代码在讲什么。所以早期的程序员还真不是一般人能揽下的活儿。</p>
<p>但是，有一种情况可以使用，就是要<strong>一次性跳出多层循环</strong>的时候，使用<code>goto</code>会更加直观，比多个<code>break</code>好用。</p>
<h2 id="嵌套循环">嵌套循环</h2>
<p>刚刚讲过，在实际的开发中，多层嵌套循环是会经常出现的。那么，在这里我们举个简单的例子来说明下，输出九九乘法表：</p>
<pre><code class="language-c">//Example 15
#include &lt;stdio.h&gt;
int main(void)
{
    int i,j;
    for (i=1; i&lt;=9; i++)
    {
        for (j=1; j&lt;=i; j++)
        {
            printf(&quot;%d×%d=%-2d\t&quot;, i, j, i*j);
        }
        putchar('\n');
    }
    return 0;
}
</code></pre>
<p>输出结果：</p>
<pre><code>//Consequence 15
1×1=1
2×1=2   2×2=4
3×1=3   3×2=6   3×3=9
4×1=4   4×2=8   4×3=12  4×4=16
5×1=5   5×2=10  5×3=15  5×4=20  5×5=25
6×1=6   6×2=12  6×3=18  6×4=24  6×5=30  6×6=36
7×1=7   7×2=14  7×3=21  7×4=28  7×5=35  7×6=42  7×7=49
8×1=8   8×2=16  8×3=24  8×4=32  8×5=40  8×6=48  8×7=56  8×8=64
9×1=9   9×2=18  9×3=27  9×4=36  9×5=45  9×6=54  9×7=63  9×8=72  9×9=81
</code></pre>
<hr>
<p>以上就是分支与循环的基础知识了，如果觉得学会了，那就赶紧开始实践。只有通过不断的debug，才能提升自己！这期博客就到此结束啦，是目前为止最长的一篇博客了，下期见！</p>

              </div>
              <div class="post-footer">
  <ul class="post-copyright">
    <li class="post-copyright-author">
      <strong>本文作者：</strong>
      TechZone
    </li>
    <li class="post-copyright-link">
      <strong>本文链接：</strong>
      <a href="https://harriswilde.github.io/post/CBranchCycle" title="C语言的分支与循环">C语言的分支与循环</a>
    </li>
    <li class="post-copyright-license">
      <strong>版权声明： </strong>
      本博客所有文章除特别声明外，转载请注明出处！
    </li>
  </ul>
  <div class="tags">
    
      <a href="https://harriswilde.github.io/tag/qrA-i8flt"># Clang</a>
    
  </div>
  <div class="nav">
    <div class="nav-prev">
      
        <i class="fa fa-chevron-left"></i>
        <a class="nav-pc-next" title="杂谈·一个神一般的随机算法" href="https://harriswilde.github.io/post/GreatRandom">杂谈·一个神一般的随机算法</a class="nav-pc-next">
        <a class="nav-mobile-prev" title="杂谈·一个神一般的随机算法" href="https://harriswilde.github.io/post/GreatRandom">上一篇</a>
      
    </div>
    <div class="nav-next">
      
        <a class="nav-pc-next" title="C语言运算符优先级及ASCII对照表" href="https://harriswilde.github.io/post/COperatorASCII">C语言运算符优先级及ASCII对照表</a>
        <a class="nav-mobile-next" title="C语言运算符优先级及ASCII对照表" href="https://harriswilde.github.io/post/COperatorASCII">下一篇</a>
        <i class="fa fa-chevron-right"></i>
      
    </div>
  </div>
</div>
              
            </div>
          </div>
        </div>
      </div>
      <div class="footer-box">
  <footer class="footer">
    <div class="copyright">
      © 2019-2020 | TechZone
    </div>
    <div class="poweredby">
      Powered by HarrisWilde
    </div>
  </footer>
  
  
  <div class="pisces back-to-top" id="back_to_top">
    <i class="fa fa-arrow-up"></i>
    
    <span class="scrollpercent">
      <span id="back_to_top_text">0</span>%
    </span>
    
  </div>
  
  
  
</div>
<script>

  let sideBarOpen = 'sidebar-open';
  let body = document.body;
  let back2Top = document.querySelector('#back_to_top'),
  back2TopText = document.querySelector('#back_to_top_text'),
  drawerBox = document.querySelector('#drawer_box'),
  rightSideBar = document.querySelector('.sidebar'),
  viewport = document.querySelector('body');

  function scrollAnimation(currentY, targetY) {
   
    let needScrollTop = targetY - currentY
    let _currentY = currentY
    setTimeout(() => {
      const dist = Math.ceil(needScrollTop / 10)
      _currentY += dist
      window.scrollTo(_currentY, currentY)
      if (needScrollTop > 10 || needScrollTop < -10) {
        scrollAnimation(_currentY, targetY)
      } else {
        window.scrollTo(_currentY, targetY)
      }
    }, 1)
  }

  back2Top.addEventListener("click", function(e) {
    scrollAnimation(document.scrollingElement.scrollTop, 0);
    e.stopPropagation();
    return false;
  });
  
  window.addEventListener('scroll', function(e) {
    let percent = document.scrollingElement.scrollTop / (document.scrollingElement.scrollHeight - document.scrollingElement.clientHeight) * 100;
    if (percent > 1 && !back2Top.classList.contains('back-top-active')) {
      back2Top.classList.add('back-top-active');
    }
    if (percent == 0) {
      back2Top.classList.remove('back-top-active');
    }
    if (back2TopText) {
      back2TopText.textContent = Math.floor(percent);
    }
  });

  
  let hasCacu = false;
  window.onresize = function() {
    if (window.width > 991) {
      calcuHeight();
    } else {
      hasCacu = false;
    }
  }

  function calcuHeight() {
    // 动态调整站点概览高度
    if (!hasCacu && back2Top.classList.contains('pisces') || back2Top.classList.contains('gemini')) {
      let sideBar = document.querySelector('.sidebar');
      let navUl = document.querySelector('#site_nav');
      sideBar.style = 'margin-top:' + (navUl.offsetHeight + navUl.offsetTop + 15) + 'px;';
      hasCacu = true;
    }
  }
  calcuHeight();
  
  let open = false, MOTION_TIME = 300, RIGHT_MOVE_DIS = '320px';

  if (drawerBox) {
    let rightMotions = document.querySelectorAll('.right-motion');
    let right = drawerBox.classList.contains('right');

    let transitionDir = right ? "transition.slideRightIn" : "transition.slideLeftIn";

    let openProp, closeProp;
    if (right) {
      openProp = {
        paddingRight: RIGHT_MOVE_DIS 
      };
      closeProp = {
        paddingRight: '0px'
      };
    } else {
      openProp = {
        paddingLeft: RIGHT_MOVE_DIS 
      };
      closeProp = {
        paddingLeft: '0px'
      };
    }

    drawerBox.onclick = function() {
      open = !open;
      window.Velocity(rightSideBar, 'stop');
      window.Velocity(viewport, 'stop');
      window.Velocity(rightMotions, 'stop');
      if (open) {
        window.Velocity(rightSideBar, {
          width: RIGHT_MOVE_DIS
        }, {
          duration: MOTION_TIME,
          begin: function() {
            window.Velocity(rightMotions, transitionDir,{ });
          }
        })
        window.Velocity(viewport, openProp,{
          duration: MOTION_TIME
        });
      } else {
        window.Velocity(rightSideBar, {
          width: '0px'
        }, {
          duration: MOTION_TIME,
          begin: function() {
            window.Velocity(rightMotions, {
              opacity: 0
            });
          }
        })
        window.Velocity(viewport, closeProp ,{
          duration: MOTION_TIME
        });
      }
      for (let i = 0; i < drawerBox.children.length; i++) {
        drawerBox.children[i].classList.toggle('muse-line');
      }
      drawerBox.classList.toggle(sideBarOpen);
    }
  }

  // 代码高亮
  hljs.initHighlightingOnLoad();
</script>
    </div>
  </body>
  <script src="/media/js/motion.js"></script>
</html>