<html>
  <head>
      <meta charset="UTF-8"/>
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
<title>TechZone</title>
<link rel="shortcut icon" href="https://harriswilde.github.io/favicon.ico?v=1577714742733">
<link rel="stylesheet" href="https://harriswilde.github.io/styles/main.css">
<meta name="description" content="HarrisWilde祝诸君元旦快乐🎉" />

<link rel="stylesheet" href="/media/fonts/iconfont.css">
<link href="//fonts.googleapis.com/css?family=Monda:300,300italic,400,400italic,700,700italic|Roboto Slab:300,300italic,400,400italic,700,700italic|Rosario:300,300italic,400,400italic,700,700italic|PT Mono:300,300italic,400,400italic,700,700italic&subset=latin,latin-ext" rel="stylesheet" type="text/css">

<script src="https://cdn.bootcss.com/highlight.js/9.12.0/highlight.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/velocity-animate@1.5.0/velocity.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/velocity-animate@1.5.0/velocity.ui.min.js"></script>
  </head>
  <body>
    <div class="head-top-line"></div>
    <div class="header-box">
      <header class="header">
  <div class="blog-header" id="header">
    <div class="site-meta">
      <div class="nav-toggle" id="nav_toggle">
        <div class="toggle-box">
          <div class="line line-top"></div>
          <div class="line line-center"></div>
          <div class="line line-bottom"></div>
        </div>
      </div>
      <div class="site-title">
        <a href="/" class="brand">
          <span>TechZone</span>
        </a>
      </div>
      <p class="subtitle">Quick notes</p>
    </div>
    <nav class="site-nav" id="site_nav">
      <ul>
        <li class="nav-item ">
          
            
          
            
          
            
          
            
          
        </li>
        <li class="nav-item ">
          
            
          
            
          
            
          
            
          
        </li>
        <li class="nav-item ">
          
            
          
            
          
            
          
            
          
        </li>
        <li class="nav-item">
          <a>
            <i class="iconfont icon-search"></i> 搜索
          </a>
        </li>
      </ul>
    </nav>
  </div>
</header>
<script type="text/javascript"> 
 
  let showNav = true;

  let navToggle = document.querySelector('#nav_toggle'),
  siteNav = document.querySelector('#site_nav');
  
  function navClick() {
    navToggle.classList.toggle('nav-toggle-active');
    siteNav.classList.toggle('nav-menu-active');
  }

  navToggle.addEventListener('click',navClick);  
</script>
    </div>
    <div class="main-continer">
      <div class="section-layout">
        <div class="section-layout-wrapper">
          
<div class="sidebar">
    <div class="sidebar-wrapper" id="sidebar">
      
        <div class="post-list-sidebar">
          <div class="sidebar-title">
            <span id="tocSideBar" class="sidebar-title-item sidebar-title-active">文章目录</span>
            <span id="metaSideBar" class="sidebar-title-item">站点概览</span>
          </div>
        </div>
      
      <div class="sidebar-body" id="sidebar_body">
        
          <div class="post-side-meta" id="post_side_meta">
            <div class="sidebar-wrapper">
  <div class="sidebar-item">
    <img class="site-author-image" src="https://harriswilde.github.io/images/avatar.png"/>
    <p class="site-author-name">TechZone</p>
    <p class="site-description">HarrisWilde祝诸君元旦快乐🎉</p>
  </div>
  <div class="sidebar-item side-item-stat">
    <div class="sidebar-item-box">
      <a href="/archives/">
        <span class="site-item-stat-count">11</span>
        <span class="site-item-stat-name">日志</span>
      </a>
    </div>
    <div class="sidebar-item-box">
      <a href="">
        <span class="site-item-stat-count">4</span>
        <span class="site-item-stat-name">分类</span>
      </a>
    </div>
    <div class="sidebar-item-box">
      <a href="/tags/">
        <span class="site-item-stat-count">4</span>
        <span class="site-item-stat-name">标签</span>
      </a>
    </div>
  </div>
  <div class="sidebar-item">
    <span class="site-item-rss">
        <i class="iconfont icon-rss"></i>
        <a href="https://harriswilde.github.io/atom.xml" target="_blank">RSS</a>
    </span>
  </div>
  <div class="sidebar-item sidebar-item-social">
    <div class="social-item">
      <a href="https://www.github.com/hsxyhao">
        <i class="iconfont icon-github"></i> GitHub
      </a>
      <a href="">
        <i class="iconfont icon-twitter"></i> Twitter
      </a>
    </div>
    <div class="social-item">
      <a href="">
        <i class="iconfont icon-globe"></i> 豆瓣
      </a>
      <a href="">
        <i class="iconfont icon-globe"></i> 知乎
      </a>
    </div>
  </div>
</div>
          </div>
          <div class="post-toc sidebar-body-active" id="post_toc" style="opacity: 1;">
            <div class="toc-box">
  <div class="toc-wrapper" id="toc_wrapper">
    <ul class="markdownIt-TOC">
<li><a href="#%E5%AD%97%E7%AC%A6%E4%B8%B2">字符（串）</a></li>
<li><a href="#%E5%BC%BA%E5%88%B6%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2">强制类型转换</a></li>
<li><a href="#%E5%88%86%E6%94%AF%E6%9D%A1%E4%BB%B6%E8%AF%AD%E5%8F%A5">分支(条件语句)</a>
<ul>
<li><a href="#%E7%9F%AD%E8%B7%AF%E6%B1%82%E5%80%BC">短路求值</a></li>
<li><a href="#if%E8%AF%AD%E5%8F%A5">if语句</a></li>
<li><a href="#switch-%E8%AF%AD%E5%8F%A5">switch 语句</a></li>
</ul>
</li>
<li><a href="#%E5%BE%AA%E7%8E%AF">循环</a>
<ul>
<li><a href="#while%E5%BE%AA%E7%8E%AF">while循环</a></li>
<li><a href="#do-while%E5%BE%AA%E7%8E%AF">do-while循环</a></li>
<li><a href="#for%E5%BE%AA%E7%8E%AF">for循环</a></li>
<li><a href="#break%E8%AF%AD%E5%8F%A5">break语句</a></li>
<li><a href="#continue%E8%AF%AD%E5%8F%A5">continue语句</a></li>
<li><a href="#%E9%80%97%E5%8F%B7%E8%BF%90%E7%AE%97%E7%AC%A6">逗号运算符</a></li>
<li><a href="#%E6%9D%A1%E4%BB%B6%E8%BF%90%E7%AE%97%E7%AC%A6">条件运算符</a></li>
<li><a href="#goto%E8%AF%AD%E5%8F%A5">goto语句</a></li>
<li><a href="#%E5%B5%8C%E5%A5%97%E5%BE%AA%E7%8E%AF">嵌套循环</a></li>
</ul>
</li>
</ul>

  </div>
</div>

<script>

let lastTop = 0, lList = [], hList = [], postBody, lastIndex = -1; 
let active = 'active-show', activeClass = 'active-current';
let tocWrapper = document.querySelector('#toc_wrapper');
let tocContent = tocWrapper.children[0];

function addTocNumber(elem, deep) {
  if (!elem) {
    return;
  }
  let prop = elem.__proto__;

  if (prop === HTMLUListElement.prototype) {
    for (let i = 0; i < elem.children.length; i++) {
      addTocNumber(elem.children[i], deep + (i + 1) + '.');
    }
  } else if (prop === HTMLLIElement.prototype) {
    // 保存li元素
    lList.push(elem);
    for (let i = 0; i < elem.children.length; i++) {
      let cur = elem.children[i];
      if (cur.__proto__ === HTMLAnchorElement.prototype) {
        cur.text =  deep + ' ' + cur.text;
      } else if (cur.__proto__ === HTMLUListElement.prototype) {
        addTocNumber(cur, deep);
      }
    }
  }
}


document.addEventListener('scroll', function(e) {
  if (lList.length <= 0) {
    return;
  }
  let scrollTop = document.body.scrollTop;
  let dir;

  if (lastTop - scrollTop > 0) {
    dir = 'up';
  } else {
    dir = 'down';
  }

  lastTop = scrollTop;
  if (scrollTop <= 0) {
    if (lastIndex >= 0 && lastIndex < hList.length) {
      lList[lastIndex].classList.remove(activeClass);
    }
    return;
  }

  let current = 0, hasFind = false;
  for (let i = 0; i < hList.length; i++) {
    if (hList[i].offsetTop > scrollTop) {
      current = i;
      hasFind = true;
      break;
    }
  }
  if (!hasFind && scrollTop > lList[lList.length - 1].offsetTop) {
    current = hList.length - 1;
  } else {
    current--;
  }
  if (dir === 'down') {
    if (current > lastIndex) {
      addActiveClass(current);
      removeActiveClass(lastIndex) 
      lastIndex = current;
      removeParentActiveClass();
      lList[current] && addActiveLiElemment(lList[current].parentElement,tocContent);
    }
  } else {
    if (current < lastIndex) {
      addActiveClass(current);
      removeActiveClass(lastIndex);
      lastIndex = current;
      removeParentActiveClass();
      lList[current] && addActiveLiElemment(lList[current].parentElement,tocContent);
    }
  }
});

function removeParentActiveClass() {
  let parents = tocContent.querySelectorAll('.'+active)
  parents.forEach(function(elem) {
    elem.classList.remove(active);
  });
}

function addActiveClass(index) {
  if (index >= 0 && index < hList.length) {
    lList[index].classList.add(activeClass);
  }
}

function removeActiveClass(index) {
  if (index >= 0 && index < hList.length) {
    lList[index].classList.remove(activeClass);
  }
}

function addActiveLiElemment(elem, parent) {
  if (!elem || elem === parent) {
    return;
  } else {
    if (elem.__proto__ === HTMLLIElement.prototype) {
      elem.classList.add(active);
    }
    addActiveLiElemment(elem.parentElement, parent);
  }
}

function showToc() {
  if (tocWrapper) {
    postBody = document.querySelector('#post_body');
    for (let i = 0; i < postBody.children.length; i++) {
      if (postBody.children[i].__proto__ === HTMLHeadingElement.prototype) {
        hList.push(postBody.children[i]);
      }
    }

    if (hList.length > 10) {
      active = 'active-hidden'
      tocContent.classList.add('closed');
    } else {
      tocContent.classList.add('expanded');
    }
  }
}
addTocNumber(tocContent, '');

window.addEventListener('load', function() {
  showToc();
  document.querySelector('#sidebar').style='display: block;';
  tocWrapper.classList.add('toc-active');
  setTimeout(function() {
    if ("createEvent" in document) {
      let evt = document.createEvent("HTMLEvents");
      evt.initEvent("scroll", false, true);
      document.dispatchEvent(evt);
    }
    else {
      document.fireEvent("scroll");
    }
  }, 500)
})

</script>
          </div>
        
      </div>
    </div>
</div>
<script>
  const SIDEBAR_TITLE_ACTIVE = 'sidebar-title-active';
  const SIDEBAR_BODY_ACTIVE = 'sidebar-body-active';
  const SLIDE_UP_IN = 'slide-up-in';

  let sidebar = document.querySelector('#sidebar'),
  tocSideBar = document.querySelector('#tocSideBar'),
  metaSideBar = document.querySelector('#metaSideBar'),
  postToc = document.querySelector('#post_toc'),
  postSiteMeta = document.querySelector('#post_side_meta'),
  sidebarTitle = document.querySelector('.sidebar-title'),
  sidebarBody = document.querySelector('#sidebar_body');

  tocSideBar.addEventListener('click', (e) => {
    toggleSidebar(e);
  });

  metaSideBar.addEventListener('click', (e) => {
    toggleSidebar(e);
  });

  function toggleSidebar(e) {
    let currentTitle = document.querySelector("."+SIDEBAR_TITLE_ACTIVE);
    if (currentTitle == e.srcElement) {
      return ;
    }
    let current, showElement, hideElement;
    if (e.srcElement == metaSideBar) {
      showElement = postSiteMeta;
      hideElement = postToc;
    } else if (e.srcElement == tocSideBar){
      showElement = postToc;
      hideElement = postSiteMeta;
    }
    currentTitle.classList.remove(SIDEBAR_TITLE_ACTIVE);
    e.srcElement.classList.add(SIDEBAR_TITLE_ACTIVE);

    window.Velocity(hideElement, 'stop');
    window.Velocity(hideElement, 'transition.slideUpOut', {
      display: 'none',
      duration: 200,
      complete: function () {
        window.Velocity(showElement, 'transition.slideDownIn', {
          duration: 200
        });
      }
    })
    hideElement.classList.remove(SIDEBAR_BODY_ACTIVE);
    showElement.classList.add(SIDEBAR_BODY_ACTIVE);

  }

  postToc.addEventListener('transitionend', function() {
    this.classList.remove(SLIDE_UP_IN);
  });

  let limitTop = sidebar.offsetTop;
  let hasFix = false;
  window.addEventListener('scroll', function(e) {
    if (document.body.scrollTop >= limitTop) {
      if (!hasFix) {
        sidebar.classList.add('sidebar-fixed');
        hasFix = true;
      }
    } else {
      if (hasFix) {
        sidebar.classList.remove('sidebar-fixed');
        hasFix = false;
      }
    }
  });
</script>
          <div class="section-box">
            <div class="section post">
              <div class="article-box">
    <header class="post-header">
  <h1 class="post-title">
    <a class="post-title-link" href="https://harriswilde.github.io/post/CBranchCycle">
      C语言的分支与循环
    </a>
  </h1>
  <div class="post-meta">
    <span class="meta-item">
      <i class="iconfont icon-calendar_empty"></i>
      <span class="pc-show">发布于</span>
      <span>2019-11-07</span>
    </span>
    
      <span class="meta-item">
        <span class="post-meta-divider">|</span>
        <i class="iconfont icon-folder_open_alt"></i>
        <span class="pc-show">分类于</span>
        
          
            <a href="https://harriswilde.github.io/tag/qrA-i8flt">
              <span>Clang</span>
            </a>
          
        
      </span>
    
    <span class="meta-item">
      <span class="post-meta-divider">|</span>
      <i class="iconfont icon-time"></i>
      <span>22分钟</span>
    </span>
    <span class="meta-item">
      <span class="post-meta-divider">|</span>
      <i class="iconfont icon-keyboard"></i>
      <span class="pc-show">5351字数</span>
    </span>
  </div>
</header>
</div>
              <div class="post-body next-md-body" id="post_body">
                <pre><code>    如果说我们之前写过的代码都是“直男”，也就是说不管三七二十一，一路走到黑，那么今天我们就来见识下“多虑”型的还有“徘徊”型的代码。（你没有看错，代码不仅可以犹豫，还可以徘徊）

    不过，在这之前，我还是来介绍两个之前就应该讲到的知识，与下文可能关系不大，但是放哪儿讲都差不多。
</code></pre>
<h1 id="字符串">字符（串）</h1>
<pre><code>    我们其实已经知道了C语言只有**字符**一种变量，就是`char`，而并没有像某些语言那样规定**字符串**这种类型。但是，是不是字符串在C语言里面就没有呢？

    其实不然，只不过没有专属的类型而已。

    定义一个字符的的方法，想必大家都已经掌握了，就像下面这个例子一样：
</code></pre>
<pre><code class="language-c">//Example 01
#include &lt;stdio.h&gt;
int main(void)
{
    char Letter;
    Letter = 'A';
    return 0;
}
</code></pre>
<pre><code>    这样，我们就定义了一个叫Letter的字符变量,并且赋值为字符A。

    那么字符串该如何定义呢？
</code></pre>
<pre><code class="language-c">//Example 02
#include &lt;stdio.h&gt;
int main(void)
{
    char String[8];
    String = {'T','e','c','h','Z','o','n','e'};
    printf(&quot;%s&quot;,String);
    return 0;
}
</code></pre>
<pre><code>    这样，我们就定义了一个名字叫String的**字符串**，还让它输出到我们屏幕上了。如果你了解过**数组**，就觉得这种方式很像数组对吧，这里提前告诉大家，**字符串就是一种数组**。但是，如果你去执行下这段代码你就会发现问题了。输出的TechZone后面，还会跟着一些乱码……

    咦？我明明只定义了8个字符，怎么还多出来这些鬼东西呢？

    那么，我们来了解下C语言时如何处理字符串的。我们可以理解，字符串的长度是有限的，而且长度**一旦确定**，在其生命周期里就**无法再次更改**。那么，系统为了确保字符串是真的结束了，会在**末尾**加一个`\0`来表示字符串的结束。我们做如下的修改，就可以让字符串正常工作了：
</code></pre>
<pre><code class="language-c">//Example 03
#include &lt;stdio.h&gt;
int main(void)
{
    char String[9];
    String = {'T','e','c','h','Z','o','n','e','\0'};
    printf(&quot;%s&quot;,String);
    return 0;
}
</code></pre>
<pre><code>    你可能会想了，这样也太麻烦了吧，要是我要输入一句话，那得多少个引号逗号，最后还可能忘记加\0。你这是把程序员不当人看？？
</code></pre>
<p>当然不会。我们可以这样定义：</p>
<pre><code class="language-c">//Example 04
#include &lt;stdio.h&gt;
int main(void)
{
    char String[];
    String = {&quot;TechZone&quot;};
    printf(&quot;%s&quot;,String);
    return 0;
}
</code></pre>
<pre><code>    看到了吧，是不是简单很多了？而且后面还会**自动补上**一个`\0`，简直就是高枕无忧了。

    有人可能有意见了，说你怎么不早点告诉我，害得我差点不学了……

    学习当然得从学基础的开始啦，别打我，别打我……
</code></pre>
<h1 id="强制类型转换">强制类型转换</h1>
<pre><code>    在**操作数不同**的情况下，大部分的运算符中，都会将**精度低**的类型转成**精度高**的类型，这样做，其实也就是为了确保精度罢了。

    但是有的时候，我们也许并不希望像系统那样的转换，那么我们可以自己进行强制转换。
</code></pre>
<p>具体方法：<code>(类型名称)变量名或值</code></p>
<p>例如：</p>
<pre><code class="language-c">//Example 05
#include &lt;stdio.h&gt;
int main(void)
{
    int num;
    num = (float)5/9;
    printf(&quot;%d&quot;,num);
    return 0;
}
</code></pre>
<pre><code>    在这个例子中，我们将5这个**整型**转化成了**浮点型**，那么为了确保精度，系统也会将后面的9也转化成浮点型。那么这样就可以输出结果，不然结果就是0（因为两个整型相除结果也会**取整**，然鹅，强制取整的结果就是**保留整数**，而**不是**四舍五入）。
</code></pre>
<hr>
<h1 id="分支条件语句">分支(条件语句)</h1>
<pre><code>    我们高中数学中，如果有学过程序框图的同学，应该就还依稀记得程序的几种结构，其中**分支**和**循环**就是今天要谈的两大结构。

    首先我们来看看一些分支里面经常使用的运算符：
</code></pre>
<ol>
<li>
<p>关系运算符</p>
<table>
<thead>
<tr>
<th>运算符</th>
<th>优先级</th>
</tr>
</thead>
<tbody>
<tr>
<td>&lt;</td>
<td>高</td>
</tr>
<tr>
<td>&lt;=</td>
<td>高</td>
</tr>
<tr>
<td>&gt;</td>
<td>高</td>
</tr>
<tr>
<td>&gt;=</td>
<td>高</td>
</tr>
<tr>
<td>==</td>
<td>低</td>
</tr>
<tr>
<td>!=</td>
<td>低</td>
</tr>
</tbody>
</table>
</li>
<li>
<p>逻辑运算符</p>
<table>
<thead>
<tr>
<th>运算符</th>
<th>优先级</th>
</tr>
</thead>
<tbody>
<tr>
<td>!    (逻辑非)</td>
<td>高</td>
</tr>
<tr>
<td>&amp;&amp;(逻辑与)</td>
<td>中</td>
</tr>
<tr>
<td>||   (逻辑或)</td>
<td>低</td>
</tr>
</tbody>
</table>
<pre><code> 此外，在编译器中，所有的字符都被看成ASCII，因此ASCII字符之间运算或者比较等等都是**合法的**。
</code></pre>
</li>
</ol>
<h2 id="短路求值">短路求值</h2>
<pre><code>    在C语言中，如果设置两个表达式，在求出**第一个式子**即可判断出结果的时候，系统就**不会**继续求第二个式子。这看上去是编译器的一种算法的优化，但是如果写代码的时候不注意的话，很有可能造成一些隐性的漏洞，看下面的例子：
</code></pre>
<pre><code class="language-c">//Example 06
#include &lt;stdio.h&gt;
int main(void)
{
    int a = 3,b = 3;
    (a = 0) &amp;&amp; (b = 5);
    printf(&quot;a=%d, b=%d\n&quot;,a,b);
    //==========================
    (a = 1) || (b = 5);
    printf(&quot;a=%d, b=%d\n&quot;,a,b);
    return 0;
}
</code></pre>
<pre><code>    如果你愿意自己尝试的话，可以自己去环境里面试试，如果不愿意的话那直接看下面的结果：
</code></pre>
<pre><code>//Consequence 06
a=0,b=3
a=1,b=3
</code></pre>
<pre><code>    如果没有开头的那段解释，我相信很多初学者都会很懵逼，怎么会这样？

    不着急，我们来分析下代码。

    我们看看分割线上面的那部分，a和b都被初始化成了整型并且赋值为3。在第一句逻辑判断语句里面，是判断的**逻辑与**，也就是说，**全真则真，一假全假**。那么在判断数字的时候，则默认0为假，非0为真。那么这句`(a = 0) &amp;&amp; (b = 5);`前面，a已经被赋值为0，那么已经为假了，在逻辑与的情况下，就算后面的条件再真，整体也是假的了，这就是所谓的**一假全假**。那么，在判断了第一个表达式之后，就可以做出判断结果，那么后面的`b=5`就**不会**被执行。

    同理，分割线下面的代码也是一个道理。只不过这里判断变成了**逻辑或**。逻辑或的标准就是**一真则真，全假才假**。那么，前面的`a=1`，系统发现，欸，已经是真了哟！那么马上罢工，后面的`b=5`也就**不予理会**了。那么输出的结果就是上面那样了，理解了吧？

    我们现在单独这样讲这个特性，貌似感觉看不出什么，但是以后写代码的时候其实要留意下短路求值，因为这样子可能就会造成你的程序里面有Bug，而且还相当**不好找**！！
</code></pre>
<h2 id="if语句">if语句</h2>
<pre><code>    if语句实际上就是判断条件，若符合的就输出。之所以叫它分支，那是因为如果到了条件语句，那么这里面的代码就**不一定都能**执行了，而是看情况来。也就是说，条件语句里面的**部分代码**，可能你的程序跑完了都没有没用到，因此就叫分支。
</code></pre>
<p>那么if语句的通式就像下面那样</p>
<pre><code class="language-c">if (...)
{
    ...;
}
else if (...)//可选
{
    ...;
}
else if (...)//可选
{
    ...;
}
...;//else if可有多个
else //上述条件都不符合，则执行这个语句，可选
{
    ...;
}
</code></pre>
<pre><code>    我想大家看里面的注释就能够大致明白的差不多了。其中if语句是**必须**的，其他的是**可选**的。else if则表示的是当if的条件不符合的时候，就会继续判断所有的else if，若有符合条件的就执行后面的语句，若都不符合就执行else的语句。如果没有else if而有else，那么当if不符合的时候就执行else后面的语句。若有else if没有else，则无符合条件的话不执行任何语句。else if和else都没有的话，那么if不符合的时候就啥都不干。

    看下面的例子，我们来制作一个识别星期的程序并且给出建议：
</code></pre>
<pre><code class="language-c">//Example 07
#include &lt;stdio.h&gt;
int main(void)
{
    int Weekday;
    printf(&quot;输入今天星期的数字：&quot;);
    scanf(&quot;%d&quot;,&amp;Weekday);//此处用于获取用户输入的内容并赋值给Weekday
    if (Weekday &gt;= 1 &amp;&amp; WeekDay &lt;= 5)
    {
        printf(&quot;今天是工作日！好好工作！\n&quot;);
    }
    else if (Weekday &gt;=6 &amp;&amp; Weekday &lt;=7)
    {
        printf(&quot;今天是周末！好好休息！&quot;);
    }
    else
    {
        printf(&quot;你输入有误哦！&quot;);
    }
    return 0;
}
</code></pre>
<pre><code>    看到了吧，我们成功地运用了分支。这个只是一个简单的例子，以后大家写程序的时候，大概就没有这么简单的了。很多情况下，我们需要**嵌套分支**来使用。那么嵌套的时候，有些地方就要注意了，下面引用一个例子：
</code></pre>
<pre><code class="language-c">//Example 08
#include &lt;stdio.h&gt;
int main(void)
{
    char isRain,isFree;
    
    printf(&quot;是否有空？（Y/N）&quot;);
    scanf(&quot;%c&quot;,&amp;isFree);
    
    printf(&quot;是否下雨？（Y/N）&quot;);
    scanf(&quot;%c&quot;,&amp;isRain);
    
    if (isFree == 'Y' || isFree == 'y')
        if (isRain == 'Y' || isRain == 'y')
            printf(&quot;记得带伞哦！\n&quot;);
    else 
        printf(&quot;女神没空！\n&quot;);
    return 0;
}
</code></pre>
<p>程序实现如下：</p>
<pre><code>//Consequence 08-1
是否有空？（Y/N）Y
是否下雨？（Y/N）Y
记得带伞哦！
</code></pre>
<p>貌似没什么问题，但是如果下面这样：</p>
<pre><code>//Consequence 08-2
是否有空？（Y/N）Y
是否下雨？（Y/N）N
女神没空！
</code></pre>
<pre><code>    我的天，女神有空而且天公作美的情况下，程序居然告诉我女神没空？？？

    其实我们分析下代码。代码的意思，大概是先在有空的情况下，如果下雨就提醒带伞，如果没空就直接告诉你没空。可是上面的问题是怎么回事呢？

    其实你们被上面的**缩进**骗了。从上面的缩进来看，else应该是与第一个if同级，而不是第二个。但是！由于你**没有**加大括号，C语言没法判断你的语句块从属关系，那么就**默认**else跟随**最近**的那一个if。所以，这里的else是跟随第二个if的，这么看就不难理解输出结果了。如果要更改，那么像下面这样就可以了：
</code></pre>
<pre><code class="language-c">//Example 08 V2
#include &lt;stdio.h&gt;
int main(void)
{
    char isRain,isFree;
    
    printf(&quot;是否有空？（Y/N）&quot;);
    scanf(&quot;%c&quot;,&amp;isFree);
    
    printf(&quot;是否下雨？（Y/N）&quot;);
    scanf(&quot;%c&quot;,&amp;isRain);
    
    if (isFree == 'Y' || isFree == 'y')
    {
        if (isRain == 'Y' || isRain == 'y')
        {
            printf(&quot;记得带伞哦！\n&quot;);
        }
    }
    else 
        printf(&quot;女神没空！\n&quot;);
    return 0;
}
</code></pre>
<pre><code>    建议所有的if都打上大括号，至于怎么打，是个人习惯，比如`{`是打在if之后还是下一行，这都无所谓，但是确定了就尽量使用一种，不然以后自己看自己写的代码都会感觉很奇怪了。
</code></pre>
<h2 id="switch-语句">switch 语句</h2>
<pre><code>    虽然if语句十分方便而且灵活，但是在某些情况下，使用switch还是会更直观一些。
</code></pre>
<p>switch的通式为：</p>
<pre><code class="language-c">switch(变量名)
{
    case 常量1:语句1;break;
    case 常量2:语句2;break;
    case 常量3:语句3;break;
    case 常量4:语句4;break;
    case 常量5:语句5;break;
    case 常量6:语句6;break;
        ...
    case 常量n:语句n;break;
    default 常量:语句;break;
}
</code></pre>
<pre><code>    switch语句中case后面只能跟一个**确定的值**，而不能是范围等等。所以在特定的条件下会很直观，但是不够灵活。

    比如上面Example 07中的代码，用switch可以这么改写：
</code></pre>
<pre><code class="language-C">//Example 07 V2
#include &lt;stdio.h&gt;
int main(void)
{
    int (Weekday);
    printf(&quot;输入今天星期的数字：&quot;);
    scanf(&quot;%d&quot;,&amp;Weekday);//此处用于获取用户输入的内容并赋值给Weekday
    switch Weekday
    {
        case 1:printf(&quot;今天周一，一鼓作气&quot;);break;
        case 2:printf(&quot;今天周二，再接再厉&quot;);break;
        case 3:printf(&quot;今天周三，坚持到底&quot;);break;
        case 4:printf(&quot;今天周四，效率第一&quot;);break;
        case 5:printf(&quot;今天周五，最后一击&quot;);break;
        case 6:printf(&quot;今天周六，好好休息&quot;);break;
        case 7:printf(&quot;今天周日，玩的开心&quot;);break;
        default:printf(&quot;你输入的有误哦！&quot;);break;
    }
}
</code></pre>
<pre><code>    这样一来是不是很直观呢？但是虽然直观，不是所有的时候都适合用这样的语句，大家根据自身的情况来选就行啦。

    至于为什么一定要加break，那是因为其实case在这里面只是一个**标记**而已，也就是说，如果我满足case3，那么程序就自动**跳到**case3，然后**继续往下**执行。假设我一共有case7，那么不加break的话，case3一直到case7的语句都会被**逐个执行**，明白了吧？
</code></pre>
<hr>
<h1 id="循环">循环</h1>
<pre><code>    上面分支讲了那么多，现在我们来看看循环。

    可以说，循环的出现，大大减少了程序员的工作量。而且正因为有了循环，程序员才能够通过巧妙的算法来使用循环去解决问题。比如，我现在想输出1-100之间的所有整数，如果没学循环，你可能会这么写：
</code></pre>
<pre><code class="language-c">//Example 09
#include &lt;stdio.h&gt;
int main(void)
{
    printf(&quot;1\n&quot;);
    printf(&quot;2\n&quot;);
    printf(&quot;3\n&quot;);
    ...
    printf(&quot;100\n&quot;);
    return 0;
}
</code></pre>
<pre><code>    这样写的逻辑思路没有错，但是谁会愿意呢？这样的编程有什么意义？我还不如拿一张纸记下来还更快呢。但是，我们是可以发现其中的规律的，就是每次输出都比之前的数大1，对吧？这就是接下来要讲的循环。
</code></pre>
<h2 id="while循环">while循环</h2>
<pre><code>    while循环也就是我们所说的**当型循环**。它的通式是：
</code></pre>
<pre><code>while(条件表达式)
	循环体
</code></pre>
<pre><code>    当满足一定的条件的时候，程序会自动循环写在循环体中的代码。比如上面的例子09中所体现出的，输出1-100。那么我们实现思路可以先设置一个变量，让这个变量**每循环一次就加个1**，然后当加到101的时候停止即可。写成代码如下：
</code></pre>
<pre><code class="language-c">//Example 09 V2
#include &lt;stdio.h&gt;
int main(void)
{
    int i = 1;
    while (i &lt; 101)
    {
        printf(&quot;%d\n&quot;,i);
        i++;
    }
    return 0;
}
</code></pre>
<pre><code>    这样，程序就自动执行输出我们想要的结果了，比一个一个手动要快了太多。
</code></pre>
<h2 id="do-while循环">do-while循环</h2>
<pre><code>    如果说while循环是个君子，那么do-while就是莽夫。while是**先判断再执行**，而本少爷则是管他什么，**先执行再说**。你可能已经猜到了，这就是直到型循环。do-while的语句通式如下：
</code></pre>
<pre><code class="language-c">do
    循环体
while (条件表达式);//(注意，这里有分号)
</code></pre>
<pre><code>    比如我们要算1加到100的和，也可以通过上面的例子用do-while进行更改：
</code></pre>
<pre><code class="language-c">//Example 09 V3
#include &lt;stdio.h&gt;
int main(void)
{
    int i = 1,sum = 0;
    do
    {
        sum += i;
        i++;
    }
    while (i&lt;101);
    printf(&quot;结果是%d\n&quot;,sum);
    return 0;
}
</code></pre>
<pre><code>    这次就不是每次都输出i了，而是每次吧i的值加到sum里面去，这样就可以算出最终结果了。
</code></pre>
<h2 id="for循环">for循环</h2>
<pre><code>    通过上面的两个例子大家也应该有点感觉了，在循环之前，一般是要定义一个**计数变量**，以此作为循环**结束**的参考。那么既然这样，有没有一种东西可以一次完成呢？这就是for语句。for循环就把计数变量和条件整合到一起去了，看通式：
</code></pre>
<pre><code class="language-c">for (循环初始化;循环条件;循环调整)
    循环体;
</code></pre>
<pre><code>    具体是啥意思，我们还是看例子。我们把上面的求和代码改成使用for：
</code></pre>
<pre><code class="language-c">//Example 09 V4
#include &lt;stdio.h&gt;
int main(void)
{
	int i, sum = 0;
	for (i = 1; i &lt; 101; i++)
	{
		sum += i;
	}
	printf(&quot;结果是%d&quot;, sum);
	return 0;
}
</code></pre>
<pre><code>    其实也是非常直观的。for语句其实三个成分可以**不用都写**甚至可以**不写**，但是分号一定要**保留**。如果没有明确的目的，那么最好不要这样用，因为会使代码可读性下降。
</code></pre>
<h2 id="break语句">break语句</h2>
<pre><code>    这个语句用于跳出循环。如果我们遍历`i`来寻找一个值，但凡找到，那其实就不用往下继续找了，那么就可以在循环中设置一个条件语句，如果找到结果则使用`break`跳出循环，这样可以节约算力。

    但是，`break`只能跳出**当前所在**的循环，使用的时候一定注意。
</code></pre>
<h2 id="continue语句">continue语句</h2>
<pre><code>    跳过本轮循环然后进入下一轮循环。这个直接说可能没什么概念，我们看看下面的例子：
</code></pre>
<pre><code class="language-c">//Example 10
#include &lt;stdio.h&gt;
int main(void)
{
    int ch;
    while ((ch = getchar()) != '\n')
    {
        if (ch == 'e')
        {
            countinue;
        }
        putchar(ch);
    }
    putchar('\n');
    return 0;
}
</code></pre>
<pre><code>    这段代码是让用户输入一些字符，然后剔除其中的e然后再输出。
</code></pre>
<pre><code>//Consequence 10
TechZone
TchZon
</code></pre>
<pre><code>    应该很好理解吧，只要遇到了e就跳出本次循环，于是`putchar()`就被跳过去了。

    可能有很多同学都觉得`for`和`while`其实差不多，但是，在`continue`语句里面很有可能就不一样。比如：
</code></pre>
<pre><code class="language-c">//Example 11
#include &lt;stdio.h&gt;
int main(void)
{
    int i;
    for (i = 1; i &lt; 10; i++)
    {
        if (i == 5)
        {
            continue;
        }
        printf(&quot;i = %d\n&quot;, i);
    }
    return 0;
}
</code></pre>
<p>如果让你把这个改成<code>while</code>，可能有的小伙伴会这么改：</p>
<pre><code class="language-c">//Example 11 V2
#include &lt;stdio.h&gt;
int main(void)
{
    int i = 1;
    while (i &lt; 10)
    {
        if ( i == 5)
        {
            continue;
            i++;
        }
        printf(&quot;i = %d\n&quot;, i);
        i++;
    }
}
</code></pre>
<pre><code>    这么看起来好像没有问题，但是执行到`continue`的时候，程序就陷入了**死循环**，无法执行到`i++`。因此不要随意更改已有的循环，如果真的有需要去改，也一定要思考清楚逻辑，想当然多半是会犯错误的。
</code></pre>
<h2 id="逗号运算符">逗号运算符</h2>
<pre><code>    当某个部分需要多个表达式的时候，使用逗号运算符来拼接。逗号运算符的优先级是**最低**的，但是它可以**使整体**从左到右进行。比如：
</code></pre>
<pre><code class="language-c">//Example 12
#include &lt;stdio.h&gt;
int main(void)
{
    int a,b,c;
    a = (b = 3, (c = b + 4) + 5);
    printf(&quot;a = %d, b = %d, c = %d\n&quot;, a, b, c);
    return 0;
}
</code></pre>
<pre><code>    在第6行里面。虽然`c = b + 4`被优先级最高的小括号括了起来，但是由于逗号运算符，还是优先从`b = 3`开始执行。
</code></pre>
<h2 id="条件运算符">条件运算符</h2>
<pre><code>    在C语言中，还有一种分支表达式就是条件运算符，它的通式为`exp1?exp2:exp3;`，其中exp1是**条件表达式**，当这个表达式判断为**真**时，执行exp2，反之执行exp3。比如下面的分支：
</code></pre>
<pre><code class="language-c">//Example 13
#include &lt;stdio.h&gt;
int main(void)
{
    int a = 3,b = 2;
    if (a &gt; b)
    {
        printf(&quot;Max is a\n&quot;);
    }
    else
    {
        printf(&quot;Max is b\n&quot;);
    }
    return 0;
}
</code></pre>
<p>这个就可以改成：</p>
<pre><code class="language-c">//Example 13 V2
#include &lt;stdio.h&gt;
int main(void)
{
    int a = 3,b = 2;
    a &gt; b ? printf(&quot;Max is a\n&quot;):printf(&quot;Max is b\n&quot;);
    return 0;
}
</code></pre>
<pre><code>    在条件不复杂的情况下使用这种语句其实更加方便，具体还是看个人的习惯来使用。
</code></pre>
<h2 id="goto语句">goto语句</h2>
<pre><code>    goto语句其实是个历史遗留问题。早期的编程语言都有**汇编语言**留下来的痕迹，goto就是其中之一。goto的作用就是让程序直接跳转到指定的位置。比如：
</code></pre>
<pre><code class="language-c">//Example 14
#include &lt;stdio.h&gt;
int main(void)
{
    int i = 5;
    while (i++)
    {
        if (i &gt; 10)
        {
            goto Lable;
        }
    }
Lable: printf(&quot;Here, i = %d\n&quot;, i);
    return 0;
}
</code></pre>
<pre><code>    当`i&gt;10`的时候直接跳转到`Lable`处了。

    很多初学者刚刚接触`goto`的时候可能会觉得很实用，但是提醒大家，在实际开发的过程中，**最好不用**`goto`语句。因为在代码之间跳来跳去，会破坏程序原有的逻辑。早期的程序代码就是满篇的`goto`，没有强大的大脑，很难一次性看懂代码在讲什么。所以早期的程序员还真不是一般人能揽下的活儿。

    但是，有一种情况可以使用，就是要**一次性跳出多层循环**的时候，使用`goto`会更加直观，比多个`break`好用。
</code></pre>
<h2 id="嵌套循环">嵌套循环</h2>
<pre><code>    刚刚讲过，在实际的开发中，多层嵌套循环是会经常出现的。那么，在这里我们举个简单的例子来说明下，输出九九乘法表：
</code></pre>
<pre><code class="language-c">//Example 15
#include &lt;stdio.h&gt;
int main(void)
{
    int i,j;
    for (i=1; i&lt;=9; i++)
    {
        for (j=1; j&lt;=i; j++)
        {
            printf(&quot;%d×%d=%-2d\t&quot;, i, j, i*j);
        }
        putchar('\n');
    }
    return 0;
}
</code></pre>
<p>输出结果：</p>
<pre><code>//Consequence 15
1×1=1
2×1=2   2×2=4
3×1=3   3×2=6   3×3=9
4×1=4   4×2=8   4×3=12  4×4=16
5×1=5   5×2=10  5×3=15  5×4=20  5×5=25
6×1=6   6×2=12  6×3=18  6×4=24  6×5=30  6×6=36
7×1=7   7×2=14  7×3=21  7×4=28  7×5=35  7×6=42  7×7=49
8×1=8   8×2=16  8×3=24  8×4=32  8×5=40  8×6=48  8×7=56  8×8=64
9×1=9   9×2=18  9×3=27  9×4=36  9×5=45  9×6=54  9×7=63  9×8=72  9×9=81
</code></pre>
<hr>
<pre><code>    以上就是分支与循环的基础知识了，如果觉得学会了，那就赶紧开始实践。只有通过不断的debug，才能提升自己！这期博客就到此结束啦，是目前为止最长的一篇博客了，下期见！</code></pre>

              </div>
              <div class="post-footer">
  <ul class="post-copyright">
    <li class="post-copyright-author">
      <strong>本文作者：</strong>
      TechZone
    </li>
    <li class="post-copyright-link">
      <strong>本文链接：</strong>
      <a href="https://harriswilde.github.io/post/CBranchCycle" title="C语言的分支与循环">https://harriswilde.github.io/post/CBranchCycle</a>
    </li>
    <li class="post-copyright-license">
      <strong>版权声明： </strong>
      本博客所有文章除特别声明外,转载请注明出处！
    </li>
  </ul>
  <div class="tags">
    
      <a href="https://harriswilde.github.io/tag/qrA-i8flt"># Clang</a>
    
  </div>
  <div class="nav">
    <div class="nav-prev">
      
        <i class="iconfont icon-angle_left"></i>
        <a class="nav-pc-next" href="https://harriswilde.github.io/post/GreatRandom">杂谈·一个神一般的随机算法</a class="nav-pc-next">
        <a class="nav-mobile-prev" href="https://harriswilde.github.io/post/GreatRandom">上一篇</a>
      
    </div>
    <div class="nav-next">
      
        <a class="nav-pc-next" href="https://harriswilde.github.io/post/COperatorASCII">C语言运算符优先级及ASCII对照表</a>
        <a class="nav-mobile-next" href="https://harriswilde.github.io/post/COperatorASCII">下一篇</a>
        <i class="iconfont icon-angle_right"></i>
      
    </div>
  </div>
</div>
              
            </div>
          </div>
        </div>
      </div>
      <div class="footer-box">
  <footer class="footer">
    <div class="poweredby">
      <div class="power-left">Power By HarrisWilde</div>
      <div>Copy<a href="https://github.com/iissnan/hexo-theme-next"> Hexo Next Theme</a></div>
    </div>
  </footer>
  <div class="back-to-top" id="back_to_top">
    <i class="iconfont icon-arrow_up"></i>
    <span class="scrollpercent">
      <span id="back_to_top_text">100</span>%
    </span>
  </div>
</div>

<script>

  let body = document.body;

  let back2Top = document.querySelector('#back_to_top'),
  back2TopText = document.querySelector('#back_to_top_text');

  function scrollAnimation(currentY, targetY) {
   
    let needScrollTop = targetY - currentY
    let _currentY = currentY
    setTimeout(() => {
      const dist = Math.ceil(needScrollTop / 10)
      _currentY += dist
      window.scrollTo(_currentY, currentY)
      if (needScrollTop > 10 || needScrollTop < -10) {
        scrollAnimation(_currentY, targetY)
      } else {
        window.scrollTo(_currentY, targetY)
      }
    }, 1)
  }

  back2Top.addEventListener("click", function(e) {
    scrollAnimation(body.scrollTop, 0);
    e.stopPropagation();
    return false;
  });
  
  window.addEventListener('scroll', function(e) {
    let percent = body.scrollTop / (body.scrollHeight - body.clientHeight) * 100;
    if (percent > 1 && !back2Top.classList.contains('back-top-active')) {
      back2Top.classList.add('back-top-active');
    }
    if (percent == 0) {
      back2Top.classList.remove('back-top-active');
    }
    back2TopText.textContent = Math.floor(percent);
  });

  // 代码高亮
  hljs.initHighlightingOnLoad();
</script>
    </div>
  </body>
  <script src="/media/js/motion.js"></script>
</html>